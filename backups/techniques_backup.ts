import { Technique } from "../types";

export const techniques: Technique[] = [
  {
    id: "equivalence-partitioning",
    name: "同値分割法",
    category: "blackbox",
    categoryName: "ブラックボックス",
    shortDescription: "入力値を同じ振る舞いをする同値クラスに分割し、各クラスから代表値をテストする技法",
    effectiveness: "高",
    complexity: "低",
    description: "同値分割法（Equivalence Partitioning）は、テスト対象システムへの入力データを「同値クラス」と呼ばれるグループに分割し、各グループから代表的な値をテストする手法です。同じグループ内の値は同じ振る舞いをすると仮定されるため、すべての値をテストする必要がなく、テストケース数を大幅に削減できます。",
    principles: [
      "入力データを「有効同値クラス」と「無効同値クラス」に分割",
      "有効同値クラス：システムが正常に処理できるデータ値の範囲",
      "無効同値クラス：エラーを引き起こすデータ値の範囲",
      "各同値クラスから少なくとも1つの値をテストケースとして選択"
    ],
    suitableCases: [
      "入力範囲が明確に定義されているとき",
      "入力データが範囲で表現できるとき",
      "テストケース数を効率的に削減したいとき"
    ],
    history: "同値分割法は1970年代に体系化されたテスト設計手法で、ソフトウェアテストの基礎的な技法として広く採用されています。IEEE 829や国際ソフトウェアテスト資格認定委員会（ISTQB）のシラバスでも重要なテスト技法として位置づけられています。",
    examples: [
      {
        title: "年齢入力フォーム",
        description: "あるシステムでは、18歳から60歳までのユーザーのみ登録が許可されているとします。",
        steps: {
          title: "同値クラスの識別",
          items: [
            { label: "有効同値クラス", value: "18歳～60歳" },
            { label: "無効同値クラス1", value: "17歳以下" },
            { label: "無効同値クラス2", value: "61歳以上" }
          ]
        },
        testCases: {
          title: "テストケース設計",
          headers: ["No.", "テストケース", "入力値", "期待結果"],
          rows: [
            ["1", "有効同値クラス", "30歳", "登録成功"],
            ["2", "無効同値クラス1", "15歳", "エラーメッセージ表示"],
            ["3", "無効同値クラス2", "70歳", "エラーメッセージ表示"]
          ]
        }
      },
      {
        title: "商品割引率の計算",
        description: "商品の購入数に応じて異なる割引率が適用されるシステムがあるとします：\n- 1～9個: 割引なし\n- 10～49個: 5%割引\n- 50～99個: 10%割引\n- 100個以上: 15%割引\n- 0個以下: 無効入力",
        steps: {
          title: "同値クラスの識別",
          items: [
            { label: "有効同値クラス1", value: "1～9個（割引なし）" },
            { label: "有効同値クラス2", value: "10～49個（5%割引）" },
            { label: "有効同値クラス3", value: "50～99個（10%割引）" },
            { label: "有効同値クラス4", value: "100個以上（15%割引）" },
            { label: "無効同値クラス", value: "0個以下" }
          ]
        },
        testCases: {
          title: "テストケース設計",
          headers: ["No.", "テストケース", "入力値", "期待結果"],
          rows: [
            ["1", "有効同値クラス1", "5個", "割引なし（0%）"],
            ["2", "有効同値クラス2", "25個", "5%割引"],
            ["3", "有効同値クラス3", "75個", "10%割引"],
            ["4", "有効同値クラス4", "150個", "15%割引"],
            ["5", "無効同値クラス", "-5個", "エラーメッセージ表示"]
          ]
        }
      }
    ],
    applicationSteps: [
      {
        title: "テスト対象の入力条件を特定",
        description: "テスト対象システムの入力パラメータを特定し、その制約条件や取りうる値の範囲を明確にします。",
        example: "例：ユーザー登録フォームの「年齢」フィールドは18歳から60歳まで"
      },
      {
        title: "同値クラスの識別",
        description: "入力値を有効同値クラスと無効同値クラスに分類します。システムの振る舞いが同じと予想される値のグループを特定します。",
        example: "例：\n・有効同値クラス：18歳～60歳\n・無効同値クラス1：17歳以下\n・無効同値クラス2：61歳以上"
      },
      {
        title: "代表値の選択",
        description: "各同値クラスから代表的な値を少なくとも1つ選びます。これがテストケースとなります。",
        example: "例：\n・有効同値クラスから「30歳」を選択\n・無効同値クラス1から「15歳」を選択\n・無効同値クラス2から「70歳」を選択"
      },
      {
        title: "テストケースの作成",
        description: "選択した代表値を使用してテストケースを作成します。各テストケースには、入力値、前提条件、期待される結果を記述します。",
        example: "例：\n・テストケース1：30歳を入力 → 登録成功\n・テストケース2：15歳を入力 → エラーメッセージ表示\n・テストケース3：70歳を入力 → エラーメッセージ表示"
      },
      {
        title: "テストの実行と評価",
        description: "作成したテストケースを実行し、結果を評価します。期待される結果と実際の結果を比較します。"
      }
    ],
    benefits: [
      {
        title: "テストケース数の削減",
        description: "同じ振る舞いをする値は1つのテストケースで代表させることで、効率的にテストが可能"
      },
      {
        title: "テストカバレッジの向上",
        description: "入力条件を体系的に分析することで、テストのもれを防止"
      },
      {
        title: "テスト設計の効率化",
        description: "テスト設計プロセスが明確で、テスターによるバラつきが少ない"
      },
      {
        title: "保守性の向上",
        description: "要件変更時に、影響を受ける同値クラスを特定しやすい"
      },
      {
        title: "初心者にも適用しやすい",
        description: "比較的理解しやすく、実践しやすい技法"
      }
    ],
    drawbacks: [
      {
        title: "同値クラス内での相違点の見落とし",
        description: "同値クラス内でも振る舞いが異なる特殊なケースを見逃す可能性"
      },
      {
        title: "複数の入力パラメータの組み合わせに弱い",
        description: "単一パラメータのテストには効果的だが、複数パラメータの組み合わせには別の技法が必要"
      },
      {
        title: "境界値のテストが不十分",
        description: "代表値のみのテストでは境界値での不具合を見逃す可能性（境界値分析と組み合わせることで改善）"
      },
      {
        title: "要件の解釈によって同値クラスが異なる",
        description: "テスターによって同値クラスの分割方法が異なる可能性がある"
      }
    ],
    effectiveUsage: [
      "境界値分析と組み合わせて使用することで、より効果的なテストが可能",
      "複数の入力パラメータがある場合は、デシジョンテーブルやペアワイズテストなど他の技法と併用する",
      "同値クラスの特定には、要件仕様書や設計書を十分に理解することが重要",
      "経験ベースのテスト技法も併用し、特殊なケースをカバーする"
    ],
    relatedTechniques: [
      {
        id: "boundary-value-analysis",
        name: "境界値分析",
        description: "同値クラスの境界に焦点を当てたテスト技法"
      },
      {
        id: "decision-table",
        name: "デシジョンテーブル",
        description: "複数の条件と動作の組み合わせをテストする技法"
      },
      {
        id: "error-guessing",
        name: "エラー推測法",
        description: "経験に基づいて特殊なケースをテストする技法"
      }
    ]
  },
  {
    id: "boundary-value-analysis",
    name: "境界値分析",
    category: "blackbox",
    categoryName: "ブラックボックス",
    shortDescription: "有効・無効同値クラスの境界値に焦点を当てる技法。バグが発生しやすい境界部分を重点的にテスト",
    effectiveness: "高",
    complexity: "中",
    description: "境界値分析は、同値分割法の拡張として位置づけられ、入力データの境界値に焦点を当てるテスト技法です。同値クラスの境界部分はバグが発生しやすい領域と言われており、この境界値を検証することで効果的にバグを発見できます。",
    principles: [
      "同値クラスの境界値および境界値の直前・直後の値をテスト",
      "最小値と最大値、およびその前後の値を特に重視",
      "エラーは境界条件で発生しやすいという経験則に基づく",
      "同値分割法と組み合わせて用いることで効果を発揮"
    ],
    suitableCases: [
      "数値範囲を扱うシステム",
      "日付や時刻の制約がある場合",
      "データサイズやファイルサイズに制限がある場合",
      "特定の文字数や桁数の入力を扱う場合"
    ],
    history: "境界値分析は、1970年代にGlenford Myersによって提唱されたテスト技法です。エラーが境界値で発生しやすいという経験則から生まれ、同値分割法と共にブラックボックステストの基本技法として広く採用されています。",
    examples: [
      {
        title: "成績評価システム",
        description: "90点以上がA、80-89点がB、70-79点がC、60-69点がD、60点未満がFとする成績評価システムをテストします。",
        steps: {
          title: "境界値の識別",
          items: [
            { label: "A/B境界", value: "90点" },
            { label: "B/C境界", value: "80点" },
            { label: "C/D境界", value: "70点" },
            { label: "D/F境界", value: "60点" }
          ]
        },
        testCases: {
          title: "テストケース設計",
          headers: ["No.", "テストケース", "入力値", "期待結果"],
          rows: [
            ["1", "A/B境界 (境界値)", "90点", "A評価"],
            ["2", "A/B境界 (境界値-1)", "89点", "B評価"],
            ["3", "B/C境界 (境界値)", "80点", "B評価"],
            ["4", "B/C境界 (境界値-1)", "79点", "C評価"],
            ["5", "C/D境界 (境界値)", "70点", "C評価"],
            ["6", "C/D境界 (境界値-1)", "69点", "D評価"],
            ["7", "D/F境界 (境界値)", "60点", "D評価"],
            ["8", "D/F境界 (境界値-1)", "59点", "F評価"]
          ]
        }
      }
    ],
    applicationSteps: [
      {
        title: "同値クラスを特定する",
        description: "まずは同値分割法を用いて、入力データの同値クラスを特定します。",
        example: "例：成績評価システムの場合、A(90-100)、B(80-89)、C(70-79)、D(60-69)、F(0-59)という5つの同値クラス"
      },
      {
        title: "境界値を識別する",
        description: "各同値クラスの境界値を特定します。通常、クラスの最小値と最大値が境界となります。",
        example: "例：90点（A/B境界）、80点（B/C境界）、70点（C/D境界）、60点（D/F境界）"
      },
      {
        title: "境界値の前後の値も考慮する",
        description: "境界値そのものに加え、境界値の前後の値もテストケースに含めます。",
        example: "例：89点（90-1）、91点（90+1）など"
      },
      {
        title: "テストケースを設計する",
        description: "特定した境界値と前後の値を使ってテストケースを設計します。",
        example: "例：\n・テストケース1：90点を入力 → A評価\n・テストケース2：89点を入力 → B評価"
      },
      {
        title: "テストを実行して結果を評価する",
        description: "設計したテストケースを実行し、期待される結果と実際の結果を比較評価します。"
      }
    ],
    benefits: [
      {
        title: "エラー検出率の向上",
        description: "境界値付近はバグが生じやすいため、集中的にテストすることで効率よくバグを発見できる"
      },
      {
        title: "同値分割法の弱点を補完",
        description: "同値分割法では見逃しやすい境界条件のエラーを検出できる"
      },
      {
        title: "テストケースの絞り込み",
        description: "すべての値をテストするのではなく、効果的な境界値に絞ることでコスト効率の良いテストが可能"
      },
      {
        title: "理解のしやすさ",
        description: "概念がシンプルで理解しやすく、実践しやすい"
      }
    ],
    drawbacks: [
      {
        title: "テストケース数の増加",
        description: "同値分割法だけより多くのテストケースが必要になる"
      },
      {
        title: "すべての不具合を検出できない",
        description: "境界以外の条件や複雑な論理エラーは検出できない場合がある"
      },
      {
        title: "複数パラメータの組み合わせに弱い",
        description: "複数の入力パラメータの相互作用による不具合を検出するには不十分"
      }
    ],
    effectiveUsage: [
      "同値分割法と組み合わせて使用する",
      "数値や日付など、順序や範囲が明確なデータに特に有効",
      "バグが発生しやすい境界を優先的にテストする",
      "複雑なシステムでは他のテスト技法と併用する"
    ],
    relatedTechniques: [
      {
        id: "equivalence-partitioning",
        name: "同値分割法",
        description: "入力データを同値クラスに分割してテストする技法"
      },
      {
        id: "decision-table",
        name: "デシジョンテーブル",
        description: "複数条件の組み合わせをテストする技法"
      }
    ]
  },
  {
    id: "decision-table",
    name: "デシジョンテーブル",
    category: "blackbox",
    categoryName: "ブラックボックス",
    shortDescription: "複数の条件と動作の組み合わせを表形式で整理し、各組み合わせをテストする技法",
    effectiveness: "高",
    complexity: "中",
    description: "デシジョンテーブルテストは、複数の条件と結果の組み合わせを表形式で整理し、全ての組み合わせをもれなくテストするための技法です。条件の組み合わせに基づいて異なる結果や振る舞いが生じるシステムのテストに特に有効です。",
    principles: [
      "入力条件（TRUE/FALSE）と期待される結果の組み合わせを表形式で整理",
      "条件の組み合わせごとに列（ルール）を作成し、結果を定義",
      "すべての可能な条件の組み合わせを体系的に検討",
      "テーブルの各列（ルール）が1つのテストケースに対応"
    ],
    suitableCases: [
      "複数の条件によって動作が分岐するシステム",
      "ビジネスルールの実装の検証",
      "組み合わせによって結果が変わる計算ロジック",
      "複雑な条件分岐を含むシステム"
    ],
    history: "デシジョンテーブルは、1950年代のビジネスシステム開発において用いられた技法で、複雑なビジネスルールを明確に表現するために発展しました。その後、ソフトウェアテストの分野でも効果的なテスト設計技法として広く採用されています。",
    examples: [
      {
        title: "保険料割引システム",
        description: "安全運転歴と年齢に基づいて自動車保険料の割引を決定するシステムをテストします。\n- 条件1: 安全運転歴3年以上（Yes/No）\n- 条件2: 25歳以上（Yes/No）",
        steps: {
          title: "デシジョンテーブルの作成",
          items: [
            { label: "条件と結果", value: "すべての条件の組み合わせと、各組み合わせに対する期待結果を表形式で整理" }
          ]
        },
        testCases: {
          title: "デシジョンテーブル",
          headers: ["ルール", "1", "2", "3", "4"],
          rows: [
            ["条件1: 安全運転歴3年以上", "Yes", "Yes", "No", "No"],
            ["条件2: 25歳以上", "Yes", "No", "Yes", "No"],
            ["結果: 割引率", "20%", "15%", "10%", "0%"]
          ]
        }
      }
    ],
    applicationSteps: [
      {
        title: "テスト対象の条件と結果を特定する",
        description: "システムの入力条件（真偽値）と、それによって生じる結果や振る舞いを特定します。",
        example: "例：条件1「安全運転歴3年以上」、条件2「25歳以上」、結果「保険料割引率」"
      },
      {
        title: "デシジョンテーブルを作成する",
        description: "条件の全ての組み合わせを列挙し、各組み合わせに対する期待結果を表形式で整理します。",
        example: "例：条件の組み合わせは2^2=4通りあり、それぞれに対応する割引率を定義"
      },
      {
        title: "テーブルを簡略化する（オプション）",
        description: "場合によっては、条件の組み合わせが多すぎる場合に、不可能な組み合わせを除外したり、類似の結果をまとめたりして簡略化します。"
      },
      {
        title: "テストケースを設計する",
        description: "デシジョンテーブルの各列（ルール）をテストケースとして設計します。",
        example: "例：ルール1（安全運転歴3年以上=Yes、25歳以上=Yes）→割引率20%を検証"
      },
      {
        title: "テストを実行して結果を評価する",
        description: "設計したテストケースを実行し、期待される結果と実際の結果を比較評価します。"
      }
    ],
    benefits: [
      {
        title: "全ての条件組み合わせの網羅",
        description: "可能な全ての条件の組み合わせを体系的に洗い出せる"
      },
      {
        title: "複雑な条件分岐のテスト",
        description: "複数の条件が絡む複雑なロジックのテストに最適"
      },
      {
        title: "テスト漏れの防止",
        description: "条件の組み合わせをもれなく検証できる"
      },
      {
        title: "仕様の明確化",
        description: "曖昧な仕様の矛盾や不足を洗い出せる"
      }
    ],
    drawbacks: [
      {
        title: "条件が多いと組み合わせ爆発",
        description: "条件の数が増えると、組み合わせの数が指数関数的に増加し管理が難しくなる"
      },
      {
        title: "作成の手間",
        description: "複雑なシステムでは、テーブルの作成と維持に時間と労力がかかる"
      },
      {
        title: "条件の相互依存関係の扱いが難しい",
        description: "条件間に依存関係がある場合、表現が複雑になる"
      }
    ],
    effectiveUsage: [
      "複雑なビジネスルールや条件分岐を含むシステムに適用する",
      "条件数が多い場合は簡略化手法（縮小デシジョンテーブル等）を検討する",
      "要件定義段階から活用することで、仕様の曖昧さを早期に解消できる",
      "自動化テストとの組み合わせによる効率化も検討する"
    ],
    relatedTechniques: [
      {
        id: "equivalence-partitioning",
        name: "同値分割法",
        description: "入力データを同値クラスに分割してテストする技法"
      },
      {
        id: "state-transition",
        name: "状態遷移テスト",
        description: "システムの状態変化に基づくテスト技法"
      },
      {
        id: "pairwise-testing",
        name: "ペアワイズテスト",
        description: "全ての2つの要素の組み合わせをカバーするテスト技法"
      }
    ]
  },
  {
    id: "state-transition",
    name: "状態遷移テスト",
    category: "blackbox",
    categoryName: "ブラックボックス",
    shortDescription: "システムの状態と遷移を考慮したテスト技法。状態図を用いて状態の変化を検証",
    effectiveness: "高",
    complexity: "高",
    description: "状態遷移テストは、システムが持つ様々な状態と、ある状態から別の状態への遷移条件、および各遷移で発生するアクションに着目するテスト技法です。状態遷移図やテーブルを用いて、システムの動的な振る舞いを体系的にテストします。",
    principles: [
      "システムの状態、遷移条件、遷移後のアクションを特定",
      "状態遷移図または状態遷移テーブルを作成して視覚化",
      "全ての状態と遷移を網羅するテストケースを設計",
      "無効な遷移も含めてテスト"
    ],
    suitableCases: [
      "状態を持つシステム（ログイン状態、予約状態など）",
      "ワークフローを含むシステム",
      "組み込みシステムやリアルタイムシステム",
      "順序依存の操作を扱うシステム"
    ],
    history: "状態遷移テスト技法は、有限状態機械（Finite State Machine）の理論に基づいており、1960年代から計算機科学で使われてきた概念です。ソフトウェアテストにおいては、特に状態を持つシステムの動的な振る舞いを検証するための重要な技法として発展しました。",
    examples: [
      {
        title: "ログイン機能",
        description: "ユーザーログイン機能の状態遷移テストを行います。システムは「未ログイン」「認証中」「ログイン済み」「ロック」の4つの状態を持ちます。",
        steps: {
          title: "状態遷移の定義",
          items: [
            { label: "状態", value: "未ログイン、認証中、ログイン済み、ロック" },
            { label: "イベント", value: "認証情報入力、認証成功、認証失敗、ログアウト、連続失敗" },
            { label: "遷移", value: "各状態間の遷移条件と結果アクション" }
          ]
        },
        testCases: {
          title: "テストケース設計",
          headers: ["No.", "初期状態", "イベント", "期待される遷移先", "確認内容"],
          rows: [
            ["1", "未ログイン", "認証情報入力", "認証中", "認証処理が開始される"],
            ["2", "認証中", "認証成功", "ログイン済み", "ユーザーがログインされ、メイン画面が表示される"],
            ["3", "認証中", "認証失敗", "未ログイン", "エラーメッセージが表示される"],
            ["4", "認証中", "連続失敗(3回)", "ロック", "アカウントロックメッセージが表示される"],
            ["5", "ログイン済み", "ログアウト", "未ログイン", "ログイン画面に戻る"]
          ]
        }
      }
    ],
    applicationSteps: [
      {
        title: "システムの状態を特定する",
        description: "テスト対象システムが取りうる全ての状態（初期状態、通常状態、終了状態など）を特定します。",
        example: "例：ログイン機能の場合、「未ログイン」「認証中」「ログイン済み」「ロック」"
      },
      {
        title: "イベントと遷移条件を特定する",
        description: "ある状態から別の状態への遷移を引き起こすイベントや条件を特定します。",
        example: "例：「認証情報入力」「認証成功」「認証失敗」「ログアウト」など"
      },
      {
        title: "状態遷移図またはテーブルを作成する",
        description: "状態、イベント、遷移条件、およびアクションを図またはテーブル形式で整理します。"
      },
      {
        title: "テストケースを設計する",
        description: "状態遷移の網羅を考慮してテストケースを設計します。一般的には、状態網羅、遷移網羅、N-スイッチ網羅などのカバレッジレベルを考慮します。",
        example: "例：全ての状態を少なくとも1回通過するテストケース（状態網羅）"
      },
      {
        title: "テストを実行して結果を評価する",
        description: "設計したテストケースを実行し、期待される状態遷移と実際の結果を比較評価します。"
      }
    ],
    benefits: [
      {
        title: "システムの動的な振る舞いの検証",
        description: "静的な機能だけでなく、状態変化を伴う動的な振る舞いを検証できる"
      },
      {
        title: "予期しない状態遷移の検出",
        description: "異常系や例外系の状態遷移も体系的にテストできる"
      },
      {
        title: "テスト範囲の明確化",
        description: "状態と遷移を可視化することで、テスト範囲が明確になる"
      },
      {
        title: "要件の曖昧さの発見",
        description: "状態遷移図を作成する過程で、要件の矛盾や不足を発見できる"
      }
    ],
    drawbacks: [
      {
        title: "状態や遷移が多いと複雑化",
        description: "大規模なシステムでは状態や遷移の数が多くなり、扱いが難しくなる"
      },
      {
        title: "準備と設計に時間がかかる",
        description: "状態遷移図の作成とテストケース設計に時間と労力が必要"
      },
      {
        title: "状態の定義が難しい場合がある",
        description: "複雑なシステムでは、明確に状態を定義することが難しい場合がある"
      }
    ],
    effectiveUsage: [
      "明確に状態を定義できるシステムに適用する",
      "状態数が多い場合は、重要な状態と遷移に焦点を絞る",
      "要件定義段階から状態遷移図を活用することで、設計の品質向上につながる",
      "自動化テストと組み合わせることで、回帰テストの効率が向上する"
    ],
    relatedTechniques: [
      {
        id: "decision-table",
        name: "デシジョンテーブル",
        description: "複数条件の組み合わせをテストする技法"
      },
      {
        id: "equivalence-partitioning",
        name: "同値分割法",
        description: "入力データを同値クラスに分割してテストする技法"
      },
      {
        id: "boundary-value-analysis",
        name: "境界値分析",
        description: "同値クラスの境界値をテストする技法"
      }
    ]
  },
  {
    id: "statement-coverage",
    name: "命令網羅",
    category: "whitebox",
    categoryName: "ホワイトボックス",
    shortDescription: "プログラム内のすべての命令（ステートメント）が少なくとも1回は実行されるようにテストする技法",
    effectiveness: "中",
    complexity: "中",
    description: "命令網羅（Statement Coverage）は、プログラムの全てのステートメント（命令）が少なくとも1回は実行されることを確認するホワイトボックステスト技法です。コードの実行可能な全ての部分を通過するテストケースを設計することで、基本的なコード品質を確保します。",
    principles: [
      "プログラム内の全ての命令（実行文）を少なくとも1回実行する",
      "実行されないコード（デッドコード）を検出できる",
      "コード網羅率の基本的な指標として使用",
      "テストケースの網羅性を定量的に評価可能"
    ],
    suitableCases: [
      "新規開発されたコードの基本的な品質確保",
      "コンパイル時エラーは検出できないが実行時エラーが懸念される場合",
      "デッドコードの検出",
      "基本的なコード網羅率を測定したい場合"
    ],
    history: "命令網羅は、1960年代から使用されている最も基本的なコードカバレッジ指標の一つです。構造化テスト（Structural Testing）の基礎として位置づけられ、より高度なカバレッジ指標（分岐網羅、条件網羅など）の基盤となっています。",
    examples: [
      {
        title: "割引計算関数",
        description: "購入金額に応じて割引率を計算する関数のテストを行います。",
        steps: {
          title: "コード例",
          items: [
            { label: "関数", value: "function calculateDiscount(amount) {\n  let discount = 0;\n  if (amount >= 10000) {\n    discount = 0.2;\n  } else if (amount >= 5000) {\n    discount = 0.1;\n  } else {\n    discount = 0.05;\n  }\n  return amount * discount;\n}" }
          ]
        },
        testCases: {
          title: "命令網羅のためのテストケース",
          headers: ["No.", "テストケース", "入力値", "期待結果", "網羅する命令"],
          rows: [
            ["1", "高額購入", "12000", "2400 (12000 * 0.2)", "割引率0.2の設定"],
            ["2", "中額購入", "7000", "700 (7000 * 0.1)", "割引率0.1の設定"],
            ["3", "少額購入", "3000", "150 (3000 * 0.05)", "割引率0.05の設定"]
          ]
        }
      }
    ],
    applicationSteps: [
      {
        title: "テスト対象のコードを分析する",
        description: "コードの流れを理解し、全ての実行可能な命令（ステートメント）を特定します。",
        example: "例：if文、else文、代入文、戻り値など全ての実行文"
      },
      {
        title: "テストケースを設計する",
        description: "全ての命令が少なくとも1回実行されるようなテストケースを設計します。",
        example: "例：条件分岐を含むコードでは、各分岐を実行するテストケース"
      },
      {
        title: "テストカバレッジを測定する",
        description: "テストを実行し、命令網羅率（Statement Coverage）を測定します。コード網羅率測定ツールを使用すると効率的です。",
        example: "例：カバレッジツールで、全体の95%の命令が実行されたことを確認"
      },
      {
        title: "未網羅の命令を分析する",
        description: "実行されなかった命令があれば、その理由を分析し、追加のテストケースを設計するか、デッドコードの可能性を検討します。"
      },
      {
        title: "テストケースを改善する",
        description: "必要に応じてテストケースを追加し、命令網羅率を向上させます。"
      }
    ],
    benefits: [
      {
        title: "基本的なコード品質の確保",
        description: "最低限のコードカバレッジを保証できる"
      },
      {
        title: "デッドコードの検出",
        description: "実行されない命令（デッドコード）を特定できる"
      },
      {
        title: "テスト作業の定量的評価",
        description: "網羅率という明確な指標で進捗を測定できる"
      },
      {
        title: "実装の理解促進",
        description: "コードの流れを理解する助けになる"
      }
    ],
    drawbacks: [
      {
        title: "条件判定の網羅性に弱い",
        description: "複合条件や条件の組み合わせを網羅していない場合がある"
      },
      {
        title: "網羅率だけでテスト品質を保証できない",
        description: "100%の命令網羅でも、ロジックの誤りを見逃す可能性がある"
      },
      {
        title: "例外処理の検証が不十分",
        description: "例外ケースやエラー処理のテストが不足する場合がある"
      }
    ],
    effectiveUsage: [
      "最低限のコード品質指標として活用する",
      "より高度なカバレッジ指標（分岐網羅、MCDC等）と組み合わせる",
      "自動化されたテストとカバレッジツールを使用して効率よく測定する",
      "テスト計画やCI/CDパイプラインに網羅率の目標値を設定する"
    ],
    relatedTechniques: [
      {
        id: "branch-coverage",
        name: "分岐網羅",
        description: "すべての条件分岐を網羅するテスト技法"
      },
      /* 条件網羅は下で詳細に定義しています */
      {
        id: "path-coverage",
        name: "パス網羅",
        description: "プログラム内の全ての実行パスをテストする技法"
      }
    ]
  },
  {
    id: "branch-coverage",
    name: "分岐網羅",
    category: "whitebox",
    categoryName: "ホワイトボックス",
    shortDescription: "プログラム内のすべての分岐（条件文のtrue/false）を少なくとも1回は通過するようにテストする技法",
    effectiveness: "高",
    complexity: "高",
    description: "分岐網羅（Branch Coverage）は、プログラム内のすべての分岐（if文やswitch文などの条件分岐）の真偽両方の結果が少なくとも1回ずつ実行されることを確認するホワイトボックステスト技法です。命令網羅より厳しい基準で、条件判断の正確性を検証できます。",
    principles: [
      "すべての分岐の真の場合と偽の場合の両方をテスト",
      "命令網羅を包含する（分岐網羅が100%なら命令網羅も100%）",
      "条件判断の基本的な正確性を確認",
      "分岐網羅率でテストの品質を定量的に評価"
    ],
    suitableCases: [
      "条件分岐を多く含むプログラム",
      "命令網羅だけでは不十分と判断される場合",
      "より厳密なテスト品質を要求される場合",
      "重要な判断ロジックを含むコード"
    ],
    history: "分岐網羅は、1970年代にホワイトボックステストの基本的指標として確立されました。命令網羅よりも厳しい基準として、より網羅的なテストの必要性から生まれ、現在も広く使われているコードカバレッジの指標です。",
    examples: [
      {
        title: "ログイン認証関数",
        description: "ユーザー名とパスワードを検証するログイン認証関数のテストを行います。",
        steps: {
          title: "コード例",
          items: [
            { label: "関数", value: "function authenticate(username, password) {\n  if (username === \"\") {\n    return \"ユーザー名を入力してください\";\n  }\n  if (password === \"\") {\n    return \"パスワードを入力してください\";\n  }\n  if (isValidUser(username, password)) {\n    return \"ログイン成功\";\n  } else {\n    return \"ユーザー名またはパスワードが不正です\";\n  }\n}" }
          ]
        },
        testCases: {
          title: "分岐網羅のためのテストケース",
          headers: ["No.", "テストケース", "入力値", "期待結果", "網羅する分岐"],
          rows: [
            ["1", "ユーザー名空", "username=\"\", password=\"pass\"", "ユーザー名を入力してください", "username === \"\" の真の分岐"],
            ["2", "パスワード空", "username=\"user\", password=\"\"", "パスワードを入力してください", "username === \"\" の偽の分岐、password === \"\" の真の分岐"],
            ["3", "有効な認証情報", "username=\"valid\", password=\"valid\"", "ログイン成功", "username === \"\" の偽、password === \"\" の偽、isValidUser()の真"],
            ["4", "無効な認証情報", "username=\"invalid\", password=\"invalid\"", "ユーザー名またはパスワードが不正です", "username === \"\" の偽、password === \"\" の偽、isValidUser()の偽"]
          ]
        }
      }
    ],
    applicationSteps: [
      {
        title: "テスト対象コードの分岐を特定する",
        description: "コード内のすべての条件分岐（if, else if, else, switch, ループ条件など）を特定します。",
        example: "例：if(username === \"\")の真/偽、if(password === \"\")の真/偽など"
      },
      {
        title: "各分岐を網羅するテストケースを設計する",
        description: "すべての分岐の真の場合と偽の場合の両方を実行するテストケースを設計します。",
        example: "例：ユーザー名が空の場合、空でない場合のテストケース"
      },
      {
        title: "分岐網羅率を測定する",
        description: "テストを実行し、分岐網羅率（Branch Coverage）を測定します。適切なカバレッジ測定ツールを使用すると効率的です。",
        example: "例：カバレッジツールで、全体の90%の分岐が実行されたことを確認"
      },
      {
        title: "未網羅の分岐を分析する",
        description: "網羅されていない分岐があれば、その理由を分析し、追加のテストケースを設計します。"
      },
      {
        title: "テストケースを改善する",
        description: "必要に応じてテストケースを追加し、分岐網羅率を向上させます。"
      }
    ],
    benefits: [
      {
        title: "条件判断の品質向上",
        description: "条件分岐の正確性をより厳密に検証できる"
      },
      {
        title: "命令網羅より強力",
        description: "命令網羅では検出できない条件判断の誤りを検出可能"
      },
      {
        title: "テスト品質の客観的評価",
        description: "分岐網羅率という明確な指標でテスト品質を測定できる"
      },
      {
        title: "ロジックの理解促進",
        description: "条件分岐の詳細な検討を通じてコードの理解が深まる"
      }
    ],
    drawbacks: [
      {
        title: "複合条件の検証が不十分",
        description: "複数の条件を組み合わせた複合条件の内部評価を完全に網羅しない"
      },
      {
        title: "テストケース数の増加",
        description: "命令網羅と比較して、より多くのテストケースが必要"
      },
      {
        title: "すべてのロジックエラーを検出できない",
        description: "100%の分岐網羅でもロジックの不具合を見逃す可能性がある"
      }
    ],
    effectiveUsage: [
      "重要な判断ロジックを含むコードに適用する",
      "命令網羅と組み合わせて基本的なコード品質を確保する",
      "条件が複雑な場合は、条件網羅やMCDCなどより厳密な手法も検討する",
      "自動化テストとカバレッジツールを活用して効率的に実施する"
    ],
    relatedTechniques: [
      {
        id: "statement-coverage",
        name: "命令網羅",
        description: "すべての命令を少なくとも1回実行するテスト技法"
      },
      {
        id: "condition-coverage",
        name: "条件網羅",
        description: "複合条件内の個々の条件の真/偽をテストする技法"
      },
      {
        id: "path-coverage",
        name: "パス網羅",
        description: "プログラム内のすべての実行パスをテストする技法"
      }
    ]
  },
  {
    id: "condition-coverage",
    name: "条件網羅",
    category: "whitebox",
    categoryName: "ホワイトボックステスト",
    shortDescription: "複合条件内の個々の条件の真/偽をテストする技法",
    effectiveness: "高",
    complexity: "中",
    description: "条件網羅（Condition Coverage）は、コード内の複合条件（論理式）において、各条件が個別にtrueとfalseの両方の値を取るようにテストするホワイトボックステスト技法です。この技法を使用することで、複合条件内の各要素が個別に評価される状況をテストできます。",
    principles: [
          "複合条件内の各条件が個別にtrueとfalseの値を取るテストケースを設計する",
          "各条件の値によって、コードの実行パスがどのように変化するかを検証する",
          "短絡評価（例: A && Bで、Aがfalseの場合にBが評価されない）の影響を考慮する"
        ],
        suitableCases: [
          "複雑な条件分岐を含むコード",
          "論理的な判断に基づく処理を行うシステム",
          "セキュリティ関連の条件チェック",
          "入力の検証ロジック"
        ],
        history: "条件網羅は、ソフトウェアテストの品質基準の一つとして1970年代に体系化された標準的なホワイトボックステスト技法です。複合条件網羅（Multiple Condition Coverage）のより簡易な代替としても利用されています。",
        examples: [
          {
            title: "複合条件のテスト例",
            description: "次のJavaScriptコードの条件網羅テストを考えます：\n\n```javascript\nfunction processOrder(order, user) {\n  if (order.total > 0 && (user.isPremium || user.credits >= order.total)) {\n    // 注文処理\n    return \"注文処理完了\";\n  } else {\n    return \"注文処理失敗\";\n  }\n}\n```\n\nこのコードには以下の条件があります：\n1. order.total > 0\n2. user.isPremium\n3. user.credits >= order.total\n\n条件網羅を達成するには、これらの各条件がtrueとfalseの両方の値を取るテストケースが必要です。",
            steps: {
              title: "条件網羅テストケースの設計",
              items: [
                {
                  label: "条件1のテスト",
                  value: "order.total > 0がtrueとfalseになるテストケース"
                },
                {
                  label: "条件2のテスト",
                  value: "user.isPremiumがtrueとfalseになるテストケース"
                },
                {
                  label: "条件3のテスト",
                  value: "user.credits >= order.totalがtrueとfalseになるテストケース"
                }
              ]
            },
            testCases: {
              title: "条件網羅テストケース",
              headers: ["テストケース", "order.total", "user.isPremium", "user.credits", "期待結果"],
              rows: [
                ["TC1", "100", "true", "50", "注文処理完了"],
                ["TC2", "0", "true", "100", "注文処理失敗"],
                ["TC3", "100", "false", "150", "注文処理完了"],
                ["TC4", "100", "false", "50", "注文処理失敗"]
              ]
            }
          },
          {
            title: "短絡評価の影響",
            description: "多くのプログラミング言語では、条件式の評価において短絡評価（Short-circuit evaluation）が行われます。例えば、A && Bという式では、Aがfalseの場合、Bは評価されません。同様に、A || Bという式では、Aがtrueの場合、Bは評価されません。\n\nこれは条件網羅テストに影響を与える重要な要素です。テストケースを設計する際には、短絡評価の影響を考慮して、すべての条件が確実に評価されるようにする必要があります。",
            steps: {
              title: "短絡評価を考慮したテスト設計",
              items: [
                {
                  label: "ANDの短絡評価",
                  value: "A && Bの場合、AがfalseだとBは評価されない"
                },
                {
                  label: "ORの短絡評価",
                  value: "A || Bの場合、AがtrueだとBは評価されない"
                },
                {
                  label: "テストケース設計への影響",
                  value: "各条件が確実に評価されるテストケースを選択する"
                }
              ]
            }
          }
        ],
        applicationSteps: [
          {
            title: "複合条件の特定",
            description: "テスト対象のコード内で複合条件（複数の条件が論理演算子ANDやORで結合されている部分）を特定します。",
            example: "例：if (age >= 18 && (hasID || isRegistered))"
          },
          {
            title: "各条件の識別",
            description: "複合条件を個別の条件に分解し、それぞれの条件を識別します。",
            example: "条件1: age >= 18、条件2: hasID、条件3: isRegistered"
          },
          {
            title: "テストケースの設計",
            description: "各条件がtrueとfalseの両方の値を取るテストケースを設計します。短絡評価の影響を考慮して、すべての条件が確実に評価されるようにします。",
            example: "条件1がtrueの場合、条件1がfalseの場合、条件2がtrueの場合、条件2がfalseの場合、条件3がtrueの場合、条件3がfalseの場合のテストケース"
          },
          {
            title: "テストの実行と検証",
            description: "設計したテストケースを実行し、各条件の評価結果と最終的な条件式の評価結果が期待通りであることを検証します。",
            example: "テストケース1：age=20, hasID=true, isRegistered=false → 条件全体はtrue\nテストケース2：age=15, hasID=true, isRegistered=true → 条件全体はfalse"
          },
          {
            title: "カバレッジの測定",
            description: "テストツールを使用して、条件網羅のカバレッジを測定します。すべての条件が少なくとも一度はtrueとfalseの値で評価されていることを確認します。",
            example: "条件網羅カバレッジ = (テストされた条件の真偽の状態数) / (全条件の真偽の状態数の合計) * 100%"
          }
        ],
        benefits: [
          {
            title: "複合条件内の弱点検出",
            description: "複合条件内の個々の条件の問題を効果的に検出できます。"
          },
          {
            title: "分岐網羅よりも詳細なテスト",
            description: "分岐網羅よりも詳細なテストが可能で、複合条件内の各条件がどのように評価されるかを検証できます。"
          },
          {
            title: "効率的なテスト設計",
            description: "複合条件網羅（すべての組み合わせをテスト）よりも少ないテストケースで実施できます。"
          },
          {
            title: "論理的なバグの検出",
            description: "論理演算の誤りや条件式の実装ミスを検出するのに効果的です。"
          }
        ],
        drawbacks: [
          {
            title: "組み合わせの欠落",
            description: "すべての条件の組み合わせをテストするわけではないため、特定の組み合わせによるバグを見逃す可能性があります。"
          },
          {
            title: "短絡評価の影響",
            description: "プログラミング言語の短絡評価により、一部の条件が評価されない場合があり、カバレッジの測定が複雑になることがあります。"
          },
          {
            title: "コード構造への依存",
            description: "コードの実装方法によっては、条件網羅を達成するためのテストケース設計が難しくなる場合があります。"
          },
          {
            title: "完全なパス検証ではない",
            description: "条件の組み合わせをすべてテストするわけではないため、すべての実行パスを検証するわけではありません。"
          }
        ],
        effectiveUsage: [
          "条件網羅と分岐網羅を組み合わせてテストする",
          "重要な複合条件に対しては、複合条件網羅（すべての組み合わせ）も検討する",
          "特にセキュリティに関わる条件や重要なビジネスロジックの条件に対して重点的に適用する",
          "テストツールを使用して条件網羅のカバレッジを測定し、テストの品質を評価する",
          "条件の実装が複雑な場合は、コードをリファクタリングしてテスト容易性を高めることも検討する"
        ],
        relatedTechniques: [
          {
            id: "branch-coverage",
            name: "分岐網羅",
            description: "条件の真偽による分岐をテストする技法。条件網羅と組み合わせることで、より効果的なテストが可能です。"
          },
          {
            id: "statement-coverage",
            name: "命令網羅",
            description: "プログラム内のすべての命令が少なくとも一度実行されるようにテストする基本的な技法。"
          },
          {
            id: "decision-table-testing",
            name: "デシジョンテーブルテスト",
            description: "複数の条件と結果の組み合わせを表形式で整理してテストするブラックボックステスト技法。条件の組み合わせを体系的にテストする点で条件網羅と補完的です。"
          },
          {
            id: "state-transition-testing",
            name: "状態遷移テスト",
            description: "システムの状態変化をテストする技法。状態の変化を引き起こす条件をテストする点で条件網羅と関連しています。"
          }
        ]
      },
      {
        id: "path-coverage",
        name: "パス網羅",
        description: "プログラム内のすべての実行パスをテストする技法"
      }
    ]
  },
  {
    id: "error-guessing",
    name: "エラー推測法",
    category: "experience",
    categoryName: "経験ベース",
    shortDescription: "テスターの経験や知識を用いて、発生しそうなエラーを予測してテストケースを設計する技法",
    effectiveness: "中",
    complexity: "低",
    description: "エラー推測法は、テスターの経験、知識、直感を活用して、システムでエラーが発生しそうな箇所や条件を予測し、それに基づいてテストケースを設計する経験ベースのテスト技法です。体系的なテスト技法を補完する役割を果たします。",
    principles: [
      "テスターの経験や知識に基づいてエラーが発生しやすい箇所を予測",
      "過去の類似システムでの不具合情報を活用",
      "「もし～したらどうなるか」という思考実験でテストケースを考案",
      "形式的なルールはなく、創造性と経験が重要"
    ],
    suitableCases: [
      "体系的なテスト技法の補完として",
      "時間的制約がある場合の効率的なテスト",
      "類似システムの過去の不具合情報がある場合",
      "特定のドメイン知識が重要な場合"
    ],
    history: "エラー推測法は、形式的なテスト技法が体系化される以前から、熟練テスターが自然と行っていた手法です。1979年にGlenford J. Myersが著書「The Art of Software Testing」で言及し、経験ベーステストの一つとして位置づけられました。",
    examples: [
      {
        title: "ユーザー登録フォーム",
        description: "ユーザー登録フォームのテストにエラー推測法を適用します。",
        steps: {
          title: "エラー推測のプロセス",
          items: [
            { label: "過去の経験", value: "類似システムで発生した不具合を思い出す" },
            { label: "ドメイン知識", value: "ユーザー登録で一般的に発生する問題を考慮" },
            { label: "直感", value: "この特定のシステムで起こりうる問題を推測" }
          ]
        },
        testCases: {
          title: "エラー推測によるテストケース例",
          headers: ["No.", "テストケース", "予測されるエラー", "根拠"],
          rows: [
            ["1", "特殊文字を含むユーザー名", "入力検証エラーまたはセキュリティ問題", "過去のシステムで特殊文字処理に問題があった"],
            ["2", "非常に長いパスワード", "文字数制限または処理遅延", "境界値を超える入力は問題を引き起こすことが多い"],
            ["3", "短時間での多数のアカウント作成", "レート制限またはセキュリティ検出", "自動化攻撃の可能性がある状況"],
            ["4", "既存ユーザーと似た名前での登録", "一意性チェックの問題", "ユーザー名の類似性チェックが不十分な場合がある"]
          ]
        }
      }
    ],
    applicationSteps: [
      {
        title: "システムとドメインを理解する",
        description: "テスト対象システムの機能や特性、およびビジネスドメインを十分に理解します。",
        example: "例：ユーザー登録システムの場合、認証プロセスやセキュリティ要件を理解"
      },
      {
        title: "過去の不具合情報を収集する",
        description: "類似のシステムで過去に発生した不具合や、一般的な問題パターンを調査します。",
        example: "例：過去のバグレポート、セキュリティ脆弱性データベース、同僚からの情報など"
      },
      {
        title: "エラーが発生しそうな状況を推測する",
        description: "システムの特性と過去の経験を組み合わせて、エラーが発生しそうな状況や条件を推測します。",
        example: "例：「もし大量のデータを短時間で処理したらどうなるか」など"
      },
      {
        title: "テストケースを設計する",
        description: "推測したエラー状況に基づいて、具体的なテストケースを設計します。",
        example: "例：システムに大量のデータを連続して入力するテストケース"
      },
      {
        title: "テストを実行して結果を評価する",
        description: "設計したテストケースを実行し、実際にエラーが発生するかどうかを検証します。"
      }
    ],
    benefits: [
      {
        title: "体系的技法では見つけにくい不具合の検出",
        description: "形式的なテスト技法では網羅しにくい特殊なケースを発見できる"
      },
      {
        title: "ドメイン知識の活用",
        description: "特定の業界やドメインの知識を効果的にテストに活かせる"
      },
      {
        title: "時間対効果の高さ",
        description: "経験豊富なテスターが短時間で重要な不具合を見つけられる可能性がある"
      },
      {
        title: "柔軟性",
        description: "形式的なルールに縛られず、状況に応じて柔軟に適用できる"
      }
    ],
    drawbacks: [
      {
        title: "テスターの経験に依存",
        description: "テスターの知識や経験によって効果が大きく異なる"
      },
      {
        title: "体系性や網羅性の欠如",
        description: "形式的な基準がなく、テストの網羅性を保証できない"
      },
      {
        title: "再現性と一貫性に欠ける",
        description: "テスターによって結果が異なる可能性があり、標準化しにくい"
      }
    ],
    effectiveUsage: [
      "体系的なテスト技法と組み合わせて使用する",
      "経験豊富なテスターの知識を活用する",
      "時間的制約がある場合の効率的なテスト手法として活用する",
      "過去の不具合情報やヒューリスティックスを文書化して共有する"
    ],
    relatedTechniques: [
      {
        id: "exploratory-testing",
        name: "探索的テスト",
        description: "テスト実行と設計を同時に行うテスト手法"
      },
      {
        id: "equivalence-partitioning",
        name: "同値分割法",
        description: "入力値を同値クラスに分割するテスト技法"
      },
      {
        id: "boundary-value-analysis",
        name: "境界値分析",
        description: "同値クラスの境界値をテストする技法"
      }
    ]
  },
  {
    id: "exploratory-testing",
    name: "探索的テスト",
    category: "experience",
    categoryName: "経験ベース",
    shortDescription: "テスト設計と実行を同時に行いながら、システムの動作を学習し、テスト戦略を改善していく手法",
    effectiveness: "中",
    complexity: "中",
    description: "探索的テストは、事前に詳細なテスト計画やテストケースを作成せず、テスターがシステムを探索しながら同時にテスト設計と実行を行い、得られた情報に基づいて次のテスト内容を決定していく動的なテスト手法です。テスターの創造性、経験、直感を活用する経験ベースのアプローチです。",
    principles: [
      "テスト設計と実行を同時並行で行う",
      "システムの探索と学習を重視",
      "発見した情報に基づいて次のテスト行動を決定",
      "テスターの創造性と批判的思考を活用",
      "時間枠（タイムボックス）を設定して集中的に実施"
    ],
    suitableCases: [
      "要件や仕様が不明確または変更が多い場合",
      "時間的制約がある場合",
      "新機能や新技術の導入時",
      "リスクベースのテストアプローチ",
      "体系的なテストの補完として"
    ],
    history: "探索的テストという用語は、1990年代にCem Kanerによって提唱されました。従来の「アドホックテスト」（場当たり的なテスト）とは異なり、探索的テストは構造化されたアプローチを持ち、テスターの学習と発見を重視します。アジャイル開発の普及と共に、その価値が広く認識されるようになりました。",
    examples: [
      {
        title: "ECサイトの新機能",
        description: "オンラインショッピングサイトに追加された新しい「お気に入り」機能の探索的テストを行います。",
        steps: {
          title: "探索的テストのアプローチ",
          items: [
            { label: "チャーター", value: "「お気に入り」機能の動作と他機能との連携を探索する（90分）" },
            { label: "テスト観点", value: "機能性、使いやすさ、パフォーマンス、異常系" },
            { label: "記録方法", value: "セッション中の発見や行動をメモツールに記録" }
          ]
        },
        testCases: {
          title: "探索的テストのセッション例",
          headers: ["発見した動作/問題", "次のアクション", "メモ"],
          rows: [
            ["商品をお気に入りに追加できた", "複数商品の追加、上限テスト", "アイコンが直感的でわかりやすい"],
            ["ログアウト後、お気に入りが保持されている", "別アカウントでログインして確認", "期待通りの動作だが確認が必要"],
            ["在庫切れ商品がお気に入りリストで特別表示されない", "UI改善の提案を報告", "ユーザビリティ問題"],
            ["大量の商品をお気に入りに追加するとページロードが遅くなる", "パフォーマンステストを詳細に実施", "最適化が必要な可能性"]
          ]
        }
      }
    ],
    applicationSteps: [
      {
        title: "テストの目的と範囲を定義する",
        description: "探索するシステムの領域とテストの目的を明確にします（チャーターと呼ばれる）。",
        example: "例：「新しい検索機能のユーザビリティと機能性を探索する（60分）」"
      },
      {
        title: "セッションベースでテストを実施する",
        description: "設定した時間枠（タイムボックス）内で、システムを探索しながらテストします。発見した情報を記録し、それに基づいて次のテスト行動を決定します。",
        example: "例：検索機能をテスト中に発見した動作の問題を深堀り"
      },
      {
        title: "テスト結果と学習内容を記録する",
        description: "テスト中の発見、行動、アイデアを継続的に記録します。セッション後にまとめをレポートします。",
        example: "例：SBTMフォーマットでの記録（セッションベーステスト管理）"
      },
      {
        title: "発見事項に基づいてテスト戦略を調整する",
        description: "テスト中に得られた知見に基づいて、次のセッションの焦点や戦略を見直します。",
        example: "例：発見された脆弱性に基づいて、セキュリティ面の探索を強化"
      },
      {
        title: "反復的にプロセスを続ける",
        description: "新たな発見や学びに基づいて、探索とテストを継続します。必要に応じて詳細なテストケースを作成することもあります。"
      }
    ],
    benefits: [
      {
        title: "柔軟性と適応力",
        description: "変化する要件や状況に迅速に対応できる"
      },
      {
        title: "効率的なバグ発見",
        description: "重要な問題を早期に発見できる可能性が高い"
      },
      {
        title: "学習と発見の促進",
        description: "システムについての理解が深まり、新たな視点が得られる"
      },
      {
        title: "テスターの創造性の活用",
        description: "事前に想定していなかった問題を発見できる"
      }
    ],
    drawbacks: [
      {
        title: "再現性と体系性の欠如",
        description: "同じテストを正確に再現することが難しい"
      },
      {
        title: "カバレッジの把握が困難",
        description: "テスト範囲の網羅性を定量的に評価しにくい"
      },
      {
        title: "テスターのスキルに依存",
        description: "テスターの経験や能力によって効果が大きく異なる"
      },
      {
        title: "計画性や予測可能性の低さ",
        description: "テスト工数や成果の予測が難しい場合がある"
      }
    ],
    effectiveUsage: [
      "体系的なテスト技法と組み合わせて使用する",
      "セッションベーステスト管理（SBTM）などの構造化アプローチを導入する",
      "テスト中の発見や学びを適切に記録し共有する",
      "経験豊富なテスターと初心者のペアで実施すると効果的"
    ],
    relatedTechniques: [
      {
        id: "error-guessing",
        name: "エラー推測法",
        description: "経験に基づいてエラーを予測するテスト技法"
      },
      {
        id: "risk-based-testing",
        name: "リスクベーステスト",
        description: "リスクの高い領域に重点を置くテスト手法"
      },
      {
        id: "usability-testing",
        name: "ユーザビリティテスト",
        description: "ユーザー体験の品質を評価するテスト手法"
      }
    ]
  },
  {
    id: "pairwise-testing",
    name: "ペアワイズテスト",
    category: "specialized",
    categoryName: "特殊技法",
    shortDescription: "パラメータの組み合わせを最適化し、すべての2つの要素の組み合わせをカバーするテスト技法",
    effectiveness: "高",
    complexity: "高",
    description: "ペアワイズテスト（または直交配列テスト）は、複数のパラメータの全ての組み合わせをテストするのではなく、任意の2つのパラメータの全ての組み合わせを少なくとも1回はテストするように設計された組み合わせテスト技法です。テストケース数を大幅に削減しながら、効果的に不具合を検出できます。",
    principles: [
      "全ての2つのパラメータの組み合わせをカバー",
      "バグの多くは単一のパラメータか2つのパラメータの相互作用から生じるという経験則に基づく",
      "組み合わせ爆発問題を解決し、テストケース数を大幅に削減",
      "特殊なアルゴリズムを用いてテストケースを生成"
    ],
    suitableCases: [
      "多数のパラメータの組み合わせテストが必要な場合",
      "全組み合わせテストが現実的でない場合",
      "コンフィギュレーションテスト",
      "GUI要素の組み合わせテスト",
      "テスト時間や資源に制約がある場合"
    ],
    history: "ペアワイズテストは1980年代後半から1990年代初頭にかけて研究され、実用化されました。もともとは「直交配列テスト（Orthogonal Array Testing）」として数学的な基盤を持ち、後にソフトウェアテスト分野で「ペアワイズテスト」として広く知られるようになりました。",
    examples: [
      {
        title: "Webアプリケーションのテスト",
        description: "ブラウザ、OS、言語設定などの異なる環境でWebアプリケーションをテストする場合のペアワイズアプローチを検討します。",
        steps: {
          title: "パラメータと値の特定",
          items: [
            { label: "ブラウザ", value: "Chrome, Firefox, Safari, Edge" },
            { label: "OS", value: "Windows, macOS, Linux" },
            { label: "言語設定", value: "日本語, 英語, 中国語" },
            { label: "画面サイズ", value: "デスクトップ, タブレット, モバイル" }
          ]
        },
        testCases: {
          title: "ペアワイズ生成テストケース（一部）",
          headers: ["No.", "ブラウザ", "OS", "言語設定", "画面サイズ"],
          rows: [
            ["1", "Chrome", "Windows", "日本語", "デスクトップ"],
            ["2", "Chrome", "macOS", "英語", "タブレット"],
            ["3", "Chrome", "Linux", "中国語", "モバイル"],
            ["4", "Firefox", "Windows", "英語", "モバイル"],
            ["5", "Firefox", "macOS", "中国語", "デスクトップ"],
            ["6", "Firefox", "Linux", "日本語", "タブレット"],
            ["7", "Safari", "Windows", "中国語", "タブレット"],
            ["8", "Safari", "macOS", "日本語", "モバイル"],
            ["9", "Safari", "Linux", "英語", "デスクトップ"],
            ["10", "Edge", "Windows", "日本語", "タブレット"]
          ]
        }
      }
    ],
    applicationSteps: [
      {
        title: "テスト対象のパラメータと値を特定する",
        description: "テスト対象システムの関連するパラメータ（入力または構成要素）と、各パラメータが取りうる値を特定します。",
        example: "例：ブラウザ（Chrome, Firefox, Safari, Edge）、OS（Windows, macOS, Linux）など"
      },
      {
        title: "ペアワイズ組み合わせを生成する",
        description: "ペアワイズテストツール（PICT, AllPairs, ACTS など）を使用して、全ての2つのパラメータの組み合わせをカバーする最小限のテストケースセットを生成します。",
        example: "例：12通りのテストケースで96の全組み合わせのうち全てのペアをカバー"
      },
      {
        title: "必要に応じて制約条件を追加する",
        description: "現実には存在しない組み合わせや、テスト不可能な組み合わせがある場合は、制約条件として指定します。",
        example: "例：「Safari」と「Linux」の組み合わせは存在しないため除外"
      },
      {
        title: "テストケースを実行する",
        description: "生成されたテストケースセットを実行し、結果を記録します。"
      },
      {
        title: "必要に応じて特定の組み合わせを追加する",
        description: "特に重要な組み合わせや、過去に問題があった組み合わせなど、特定のケースをテストセットに追加することを検討します。"
      }
    ],
    benefits: [
      {
        title: "テストケース数の大幅削減",
        description: "全組み合わせテストと比較して、テストケース数を劇的に削減（例：何百万から数十）"
      },
      {
        title: "高い不具合検出効率",
        description: "経験的に、多くの不具合が2つのパラメータの相互作用によって発生する"
      },
      {
        title: "体系的なアプローチ",
        description: "科学的な手法に基づいた組み合わせ選択で、テスト品質を担保"
      },
      {
        title: "リソースとコストの節約",
        description: "テスト量の削減による時間とコストの節約"
      }
    ],
    drawbacks: [
      {
        title: "3つ以上のパラメータ間の相互作用を網羅しない",
        description: "3つ以上のパラメータの組み合わせによるバグを見逃す可能性がある"
      },
      {
        title: "専用ツールの必要性",
        description: "効率的な実装には専用のペアワイズテストツールが必要"
      },
      {
        title: "テスト設計の複雑さ",
        description: "パラメータと値の適切な選択には専門知識が必要"
      },
      {
        title: "実行に時間がかかる場合がある",
        description: "生成されたテストケースが多い場合、実行に時間がかかる"
      }
    ],
    effectiveUsage: [
      "全組み合わせテストが現実的でない場合に適用する",
      "ドメイン知識を活用して重要なパラメータと値を選択する",
      "必要に応じて3-wayや4-wayの組み合わせテストも検討する",
      "自動化テストと組み合わせて効率的に実施する"
    ],
    relatedTechniques: [
      {
        id: "decision-table",
        name: "デシジョンテーブル",
        description: "条件と結果の組み合わせをテストする技法"
      },
      {
        id: "equivalence-partitioning",
        name: "同値分割法",
        description: "入力値を同値クラスに分割するテスト技法"
      },
      {
        id: "combinatorial-testing",
        name: "組み合わせテスト",
        description: "様々な入力の組み合わせをテストする技法群"
      }
    ]
  }
];
