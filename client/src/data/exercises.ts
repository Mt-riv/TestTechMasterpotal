import { PracticalExercise, BadgeDefinition } from '../types/exercise';

// サンプル演習データ
export const exercises: PracticalExercise[] = [
  {
    id: 'ex-001',
    title: '同値分割テストの演習',
    description: '同値分割（Equivalence Partitioning）テスト技法を使った実践演習です。',
    objective: 'この演習では、入力範囲を有効なクラスと無効なクラスに分割し、効率的なテストケースを設計する方法を学びます。',
    scenarioDescription: 
      'あなたは銀行の口座管理システムの開発チームに所属しています。システムには入金機能があり、1回の入金額は1円から100万円までという制約があります。\n\n' +
      'この機能に対して同値分割テスト技法を用いて効率的なテストケースを設計する必要があります。',
    steps: [
      {
        stepNumber: 1,
        description: '入金機能の仕様を確認し、入力の有効範囲と無効範囲を特定する'
      },
      {
        stepNumber: 2,
        description: '有効同値クラスと無効同値クラスを識別する'
      },
      {
        stepNumber: 3,
        description: '各同値クラスから代表値を選んでテストケースを設計する'
      },
      {
        stepNumber: 4,
        description: '設計したテストケースの有効性を評価する'
      }
    ],
    quiz: [
      {
        id: 'q-001-1',
        questionText: '銀行の入金機能（1円〜100万円まで有効）に対する同値分割テストで、以下のテストケースのうち冗長なものはどれですか？',
        options: [
          {
            id: 'q-001-1-a',
            text: '入金額: -10円',
            isCorrect: false,
            explanation: 'これは無効同値クラス（負の値）の代表値であり、重要なテストケースです。'
          },
          {
            id: 'q-001-1-b',
            text: '入金額: 0円',
            isCorrect: false,
            explanation: 'これは境界値（下限の外側）であり、重要なテストケースです。'
          },
          {
            id: 'q-001-1-c',
            text: '入金額: 500円と入金額: 50,000円',
            isCorrect: true,
            explanation: '両方とも有効同値クラス内の値であり、同じクラスから複数のケースをテストすることは冗長です。同値分割の考え方では、各同値クラスから1つのテストケースを選ぶことが効率的です。'
          },
          {
            id: 'q-001-1-d',
            text: '入金額: 1,000,001円',
            isCorrect: false,
            explanation: 'これは上限を超える値で、無効同値クラスの代表値として重要なテストケースです。'
          }
        ],
        explanation: '同値分割テスト技法では、各同値クラスから代表的な1つの値をテストすれば、そのクラス内の他の値も同じ振る舞いをすると仮定します。そのため、同じ同値クラス内から複数の値をテストすることは冗長になります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-001-2',
        questionText: '同値分割テストの主な利点は何ですか？',
        options: [
          {
            id: 'q-001-2-a',
            text: 'すべての可能な入力値を網羅的にテストできる',
            isCorrect: false,
            explanation: '同値分割は網羅的テストではなく、入力ドメインを効率的に削減するための技法です。'
          },
          {
            id: 'q-001-2-b',
            text: 'テストケース数を削減しながら効果的なカバレッジを実現できる',
            isCorrect: true,
            explanation: '同値分割の主な利点は、テストケース数を大幅に削減しながらも、効果的なテストカバレッジを実現できることです。'
          },
          {
            id: 'q-001-2-c',
            text: 'コードの複雑度を下げることができる',
            isCorrect: false,
            explanation: '同値分割はテスト設計技法であり、コードの複雑度を直接下げるものではありません。'
          },
          {
            id: 'q-001-2-d',
            text: '特定の境界値のみをテストすればよい',
            isCorrect: false,
            explanation: '境界値のテストは境界値分析の技法であり、同値分割とは異なります（ただし、相補的に使われることが多い）。'
          }
        ],
        explanation: '同値分割テスト技法の主な利点は、入力ドメインを同値クラスに分割し、各クラスから代表値を選ぶことで、テストケース数を削減しながらも効果的なテストを実現できる点にあります。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-001-3',
        questionText: '以下の例で、同値分割によって識別される有効同値クラスの数はいくつですか？\n\n例：ウェブフォームの年齢入力欄。有効な入力は13歳から120歳までの整数。',
        options: [
          {
            id: 'q-001-3-a',
            text: '1つ',
            isCorrect: true,
            explanation: '有効同値クラスは13〜120の範囲内の整数値のみの1つです。'
          },
          {
            id: 'q-001-3-b',
            text: '2つ',
            isCorrect: false,
            explanation: '有効範囲は1つの連続した範囲なので、有効同値クラスは1つです。'
          },
          {
            id: 'q-001-3-c',
            text: '3つ',
            isCorrect: false,
            explanation: '有効範囲が分割されていないため、有効同値クラスは1つです。'
          },
          {
            id: 'q-001-3-d',
            text: '4つ',
            isCorrect: false,
            explanation: '有効範囲が分割されていないため、有効同値クラスは1つです。'
          }
        ],
        explanation: '有効同値クラスは13〜120までの整数の範囲で1つです。無効同値クラスとしては、13未満の値、120を超える値、非整数値などが考えられます。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-001-4',
        questionText: '同値分割テストを実施する際、次のうち最も適切なアプローチはどれですか？',
        options: [
          {
            id: 'q-001-4-a',
            text: '全ての同値クラスから複数の値をテストする',
            isCorrect: false,
            explanation: '同値分割の考え方では、各クラスから1つの代表値をテストすれば十分です。'
          },
          {
            id: 'q-001-4-b',
            text: '有効同値クラスからのみテストケースを選択する',
            isCorrect: false,
            explanation: '無効同値クラスのテストも重要です。無効な入力に対するシステムの動作も検証する必要があります。'
          },
          {
            id: 'q-001-4-c',
            text: '各同値クラス（有効・無効とも）から少なくとも1つのテストケースを選択する',
            isCorrect: true,
            explanation: '同値分割の基本原則は、各同値クラス（有効・無効とも）から少なくとも1つのテストケースを選択することです。'
          },
          {
            id: 'q-001-4-d',
            text: '境界値のみをテストする',
            isCorrect: false,
            explanation: '境界値のテストは重要ですが、同値分割では各クラスの代表値をテストします。境界値分析は同値分割を補完する別の技法です。'
          }
        ],
        explanation: '同値分割テストでは、各同値クラス（有効クラスと無効クラスの両方）から少なくとも1つのテストケースを選択することが基本原則です。これにより、効率的にテストを行いながらも、有効な入力と無効な入力の両方に対するシステムの振る舞いを検証できます。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-001-5',
        questionText: 'パスワードの複雑さチェック機能があります。パスワードは英字と数字の両方を含み、最低8文字以上である必要があります。この機能を同値分割テストする場合、以下のテストケースのうち有効同値クラスに属するものはどれですか？',
        options: [
          {
            id: 'q-001-5-a',
            text: 'abc123xyz（英字と数字を含む9文字のパスワード）',
            isCorrect: true,
            explanation: 'このパスワードは英字と数字の両方を含み、8文字以上なので、有効同値クラスに属します。'
          },
          {
            id: 'q-001-5-b',
            text: 'abcdefgh（英字のみの8文字のパスワード）',
            isCorrect: false,
            explanation: 'このパスワードは英字のみで数字を含まないため、無効同値クラスに属します。'
          },
          {
            id: 'q-001-5-c',
            text: '12345678（数字のみの8文字のパスワード）',
            isCorrect: false,
            explanation: 'このパスワードは数字のみで英字を含まないため、無効同値クラスに属します。'
          },
          {
            id: 'q-001-5-d',
            text: 'abc123（英字と数字を含む6文字のパスワード）',
            isCorrect: false,
            explanation: 'このパスワードは英字と数字を含んでいますが、8文字未満なので、無効同値クラスに属します。'
          }
        ],
        explanation: '有効なパスワードは「英字と数字の両方を含み、8文字以上」という2つの条件を満たす必要があります。有効同値クラスに属するテストケースは、これらすべての条件を満たすものです。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-001-6',
        questionText: '以下の仕様を持つシステムの同値分割テストを行います。以下の選択肢のうち、別々の同値クラスに属する入力値の組み合わせはどれですか？\n\n仕様：ユーザーの年齢に基づくサービス提供\n・13歳未満：サービス利用不可\n・13歳〜17歳：保護者の同意が必要\n・18歳〜64歳：通常サービス利用可能\n・65歳以上：シニア割引適用',
        options: [
          {
            id: 'q-001-6-a',
            text: '15歳と16歳',
            isCorrect: false,
            explanation: '15歳と16歳は同じ同値クラス（13歳〜17歳の範囲）に属します。'
          },
          {
            id: 'q-001-6-b',
            text: '12歳と13歳',
            isCorrect: true,
            explanation: '12歳は13歳未満のクラス、13歳は13歳〜17歳のクラスに属しており、異なる同値クラスにあります。'
          },
          {
            id: 'q-001-6-c',
            text: '35歳と40歳',
            isCorrect: false,
            explanation: '35歳と40歳は同じ同値クラス（18歳〜64歳の範囲）に属します。'
          },
          {
            id: 'q-001-6-d',
            text: '70歳と80歳',
            isCorrect: false,
            explanation: '70歳と80歳は同じ同値クラス（65歳以上の範囲）に属します。'
          }
        ],
        explanation: '同値クラスとは、プログラムが同じように処理すると予想される入力値のグループです。この例では、年齢に基づいて4つの異なる同値クラスがあります。異なるクラスに属する値は、システムで異なる振る舞いをすることが予想されます。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-001-7',
        questionText: '文字列の長さをチェックする関数について同値分割テストを行います。関数の仕様は「文字列の長さが1〜10文字の場合は"OK"、それ以外の場合は"NG"を返す」です。この関数に対する適切な最小テストセットはどれですか？',
        options: [
          {
            id: 'q-001-7-a',
            text: '文字列長さ: 0文字、1文字、5文字、10文字、11文字',
            isCorrect: true,
            explanation: 'このテストセットは、空文字列（無効）、下限値（有効）、中間値（有効）、上限値（有効）、上限を超える値（無効）をカバーしており、すべての同値クラスをテストできます。'
          },
          {
            id: 'q-001-7-b',
            text: '文字列長さ: 1文字、10文字',
            isCorrect: false,
            explanation: 'このテストセットは有効同値クラスの境界値のみをテストしており、無効同値クラスのテストが不足しています。'
          },
          {
            id: 'q-001-7-c',
            text: '文字列長さ: 5文字、15文字',
            isCorrect: false,
            explanation: 'このテストセットでは有効同値クラスの中間値と無効同値クラスの値をテストしていますが、有効同値クラスの境界値（1文字と10文字）や無効同値クラスの下限（0文字）をテストしていません。'
          },
          {
            id: 'q-001-7-d',
            text: '文字列長さ: 1文字、5文字、10文字',
            isCorrect: false,
            explanation: 'このテストセットは有効同値クラスの値のみをテストしており、無効同値クラス（0文字や11文字以上）のテストが不足しています。'
          }
        ],
        explanation: '同値分割テストでは、各同値クラスから少なくとも1つの代表値をテストします。この例では、「1〜10文字」という有効同値クラスと、「0文字および11文字以上」という無効同値クラスがあります。各クラスの境界値と中間値を含む包括的なテストセットが最も適切です。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-001-8',
        questionText: 'Eコマースサイトの割引機能をテストしています。仕様は以下の通りです：\n・購入金額が5,000円未満：割引なし\n・購入金額が5,000円以上10,000円未満：5%割引\n・購入金額が10,000円以上：10%割引\n\nこの機能の同値分割テストに必要な最小テストケース数は？（各同値クラスから1つずつテストする場合）',
        options: [
          {
            id: 'q-001-8-a',
            text: '2つ',
            isCorrect: false,
            explanation: '仕様から3つの明確な同値クラスがあるため、2つのテストケースでは不十分です。'
          },
          {
            id: 'q-001-8-b',
            text: '3つ',
            isCorrect: true,
            explanation: '同値分割では各クラスから1つずつテストケースを選びます。この例では、5,000円未満、5,000円以上10,000円未満、10,000円以上の3つの同値クラスがあります。'
          },
          {
            id: 'q-001-8-c',
            text: '4つ',
            isCorrect: false,
            explanation: '3つの同値クラスをテストするのに4つのテストケースは必要ありません。ただし、境界値も含めてテストするなら4つ以上必要になります。'
          },
          {
            id: 'q-001-8-d',
            text: '6つ',
            isCorrect: false,
            explanation: '同値分割のみを考えると、3つのテストケースで十分です。6つのテストケースは、境界値分析も含めると必要になる可能性がありますが、この問題では同値分割のみを考えています。'
          }
        ],
        explanation: '同値分割テストでは、各同値クラスからテストケースを1つ選びます。この例では、「5,000円未満」、「5,000円以上10,000円未満」、「10,000円以上」の3つの同値クラスがあるため、最小テストケース数は3つです。例えば、4,000円、7,000円、12,000円などの値をテストケースとして選ぶことができます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-001-9',
        questionText: '以下の無効同値クラスのうち、同値分割テストで最も優先度が高いものはどれですか？',
        options: [
          {
            id: 'q-001-9-a',
            text: '極端に大きな値（例：整数の最大値を超える値）',
            isCorrect: false,
            explanation: '極端な値はエッジケースとして重要ですが、一般的にはシステムに特定の処理がある場合を除いて、境界に近い無効値の方が優先度が高いことが多いです。'
          },
          {
            id: 'q-001-9-b',
            text: '空の値や未入力の値',
            isCorrect: true,
            explanation: '空の値や未入力の値は、ユーザー入力では非常によく発生するケースであり、多くのバグの原因になります。そのため、優先度が高い無効同値クラスです。'
          },
          {
            id: 'q-001-9-c',
            text: '有効範囲からはるかに離れた値',
            isCorrect: false,
            explanation: '有効範囲から非常に離れた値は、通常は境界付近の値と同じ振る舞いをすることが期待されるため、優先度は低くなります。'
          },
          {
            id: 'q-001-9-d',
            text: '使用されていないコード値',
            isCorrect: false,
            explanation: '使用されていないコード値も重要ですが、一般的にはシステムが未使用値を正しく拒否できるかをテストする目的であり、通常は空の値や未入力の値ほど優先度は高くありません。'
          }
        ],
        explanation: '同値分割テストでは、無効同値クラスの中でも特に空の値や未入力の値は優先度が高いです。これらは実環境でよく発生するエラーケースであり、入力検証の欠陥が最も顕著に現れる部分でもあります。データベース操作やフォーム送信などでよく見られるバグの原因となります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-001-10',
        questionText: '列車の乗車券を購入するシステムについて同値分割テストを行います。以下の条件があります：\n・乗車距離：1km〜2000kmの整数\n・年齢：0歳〜120歳の整数\n・時間帯：朝（5時〜9時）、昼（9時〜17時）、夜（17時〜23時）、深夜（23時〜5時）\n\n同値分割テストで考慮すべき同値クラスの総数は最小で何個ありますか？',
        options: [
          {
            id: 'q-001-10-a',
            text: '3個',
            isCorrect: false,
            explanation: '3つのパラメータそれぞれに複数の同値クラスがあるため、3個では不十分です。'
          },
          {
            id: 'q-001-10-b',
            text: '6個',
            isCorrect: false,
            explanation: '各パラメータの同値クラスを合計すると6個を超えます。'
          },
          {
            id: 'q-001-10-c',
            text: '9個',
            isCorrect: true,
            explanation: '乗車距離に関して、有効クラス（1〜2000km）と無効クラス（負の値、0、2000超）の3つ、年齢に関して有効クラス（0〜120歳）と無効クラス（負の値、120超）の3つ、時間帯に関して朝、昼、夜、深夜の4つ、さらに無効な時間の1つで合計9個（単純化して考えると）が最小の同値クラス数です。'
          },
          {
            id: 'q-001-10-d',
            text: '12個',
            isCorrect: false,
            explanation: '最小の同値クラス数を考えると、いくつかのクラスは統合できるため、12個よりは少なくなります。'
          }
        ],
        explanation: '同値分割テストでは、入力条件ごとに有効・無効の同値クラスを識別します。乗車距離（有効1つ、無効2つ）、年齢（有効1つ、無効2つ）、時間帯（有効4つ、無効はここでは時間外の1つと考える）を合計すると最小で9個の同値クラスがあります。実際にはさらに細分化することも可能ですが、問題では最小数を尋ねています。',
        difficulty: 'hard',
        points: 15
      }
    ],
    techniqueName: '同値分割法',
    techniqueId: 'equivalence-partitioning',
    categoryId: 'blackbox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '25分'
  },
  {
    id: 'ex-002',
    title: '境界値分析の演習',
    description: '境界値分析（Boundary Value Analysis）テスト技法を使った実践演習です。',
    objective: 'この演習では、入力値の境界付近でのバグを効果的に検出するための境界値分析技法を学びます。',
    scenarioDescription: 
      'あなたはオンラインショッピングサイトのテスターです。商品の数量選択機能には以下の制約があります：\n\n' +
      '- 1回の注文につき最小1個から最大10個まで購入可能\n' +
      '- 数量は整数のみ\n\n' +
      'この機能に対して境界値分析を用いて効果的なテストケースを設計してください。',
    steps: [
      {
        stepNumber: 1,
        description: '機能の仕様から境界を特定する'
      },
      {
        stepNumber: 2,
        description: '各境界の内側と外側の値を識別する'
      },
      {
        stepNumber: 3,
        description: '特定した境界値を用いてテストケースを設計する'
      },
      {
        stepNumber: 4,
        description: '設計したテストケースの有効性を評価する'
      }
    ],
    quiz: [
      {
        id: 'q-002-1',
        questionText: '商品数量選択機能（1個から10個まで有効）に対する境界値分析テストで、最も重要なテストケースの組み合わせはどれですか？',
        options: [
          {
            id: 'q-002-1-a',
            text: '数量: 1個、5個、10個',
            isCorrect: false,
            explanation: '中間値（5個）のテストは境界値分析では優先度が低く、境界の外側の値（0個、11個）が含まれていません。'
          },
          {
            id: 'q-002-1-b',
            text: '数量: 0個、1個、10個、11個',
            isCorrect: true,
            explanation: 'これは境界の内側（1個、10個）と外側（0個、11個）の両方をテストしており、境界値分析の基本原則に従っています。'
          },
          {
            id: 'q-002-1-c',
            text: '数量: 1個、2個、9個、10個',
            isCorrect: false,
            explanation: '境界の内側の値は含まれていますが、境界の外側の値（0個、11個）が含まれていません。'
          },
          {
            id: 'q-002-1-d',
            text: '数量: 1個、9個、10個、100個',
            isCorrect: false,
            explanation: '下限の外側の値（0個）が含まれておらず、極端な値（100個）は境界値分析では優先度が低いです。'
          }
        ],
        explanation: '境界値分析では、境界の内側と外側の両方の値をテストすることが重要です。有効範囲が1〜10の場合、最も重要なテストケースは0、1、10、11の4つです。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-002-2',
        questionText: '境界値分析がバグ検出に特に効果的な理由は何ですか？',
        options: [
          {
            id: 'q-002-2-a',
            text: 'すべての入力可能性を網羅的にテストするため',
            isCorrect: false,
            explanation: '境界値分析はすべての入力をテストするわけではなく、境界付近の値に焦点を当てます。'
          },
          {
            id: 'q-002-2-b',
            text: 'プログラマーが境界条件を誤解することが多いため',
            isCorrect: true,
            explanation: '境界条件の処理はしばしば「off-by-one」エラーなどのバグが発生しやすく、プログラマーが条件を誤解したり、不正確に実装したりすることが多いためです。'
          },
          {
            id: 'q-002-2-c',
            text: 'テスト実行のコストが低いため',
            isCorrect: false,
            explanation: 'テストコストの低さは境界値分析の主な利点ではありません。'
          },
          {
            id: 'q-002-2-d',
            text: 'コードカバレッジを最大化するため',
            isCorrect: false,
            explanation: '境界値分析は特定の境界条件に焦点を当てるもので、コードカバレッジの最大化が主目的ではありません。'
          }
        ],
        explanation: '境界値分析がバグ検出に特に効果的なのは、プログラマーが境界条件（「以上」「より大きい」「以下」「未満」など）を正確に実装することが難しく、これらの条件で「off-by-one」エラーが発生しやすいためです。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-002-3',
        questionText: '次のパスワード要件の境界値分析で、最も重要なテストケースはどれですか？\n\n要件：パスワードは8文字以上16文字以下で、アルファベットと数字を含む必要がある',
        options: [
          {
            id: 'q-002-3-a',
            text: '7文字、8文字、16文字、17文字のパスワード',
            isCorrect: true,
            explanation: 'これは長さの境界（8文字と16文字）の内側と外側の両方をテストしており、最も重要なテストケースです。'
          },
          {
            id: 'q-002-3-b',
            text: '8文字、12文字、16文字のパスワード',
            isCorrect: false,
            explanation: '境界の内側の値のみがテストされており、境界の外側の値（7文字、17文字）が含まれていません。'
          },
          {
            id: 'q-002-3-c',
            text: '1文字、8文字、16文字、20文字のパスワード',
            isCorrect: false,
            explanation: '極端な値（1文字、20文字）は含まれていますが、下限境界の外側（7文字）が含まれていません。'
          },
          {
            id: 'q-002-3-d',
            text: '8文字、9文字、15文字、16文字のパスワード',
            isCorrect: false,
            explanation: '境界の内側の値のみがテストされており、境界の外側の値（7文字、17文字）が含まれていません。'
          }
        ],
        explanation: '境界値分析では、各境界の内側と外側の値をテストすることが重要です。パスワード長の境界が8文字と16文字なので、7文字（下限の外側）、8文字（下限）、16文字（上限）、17文字（上限の外側）が最も重要なテストケースとなります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-002-4',
        questionText: '以下のうち、境界値分析に関する記述として正しいものはどれですか？',
        options: [
          {
            id: 'q-002-4-a',
            text: '境界値分析は同値分割と対立する技法である',
            isCorrect: false,
            explanation: '境界値分析は同値分割と対立するのではなく、補完する技法です。'
          },
          {
            id: 'q-002-4-b',
            text: '境界値は常に同値クラスの中間点である',
            isCorrect: false,
            explanation: '境界値は同値クラスの中間点ではなく、同値クラスの境界にある値です。'
          },
          {
            id: 'q-002-4-c',
            text: '境界値分析は同値分割を補完するテスト技法である',
            isCorrect: true,
            explanation: '境界値分析は同値分割を補完する技法で、同値クラスの境界に焦点を当ててテストを行います。'
          },
          {
            id: 'q-002-4-d',
            text: '境界値分析はユーザビリティのテストに最適である',
            isCorrect: false,
            explanation: '境界値分析は主に機能的な境界条件のテストに適しており、ユーザビリティテストが主目的ではありません。'
          }
        ],
        explanation: '境界値分析は同値分割テスト技法を補完するもので、同値クラスの境界にある値（境界値）とその周辺の値をテストすることで、境界付近で発生しやすいバグを検出するための技法です。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-002-5',
        questionText: '以下の仕様に対する境界値分析で適切なテストケースはどれですか？\n\n仕様：年齢による映画の視聴制限\n- 12歳未満：視聴不可\n- 12歳以上18歳未満：保護者の同意が必要\n- 18歳以上：制限なし',
        options: [
          {
            id: 'q-002-5-a',
            text: '10歳、15歳、20歳',
            isCorrect: false,
            explanation: 'これらは各年齢層の代表値であり、境界値ではありません。'
          },
          {
            id: 'q-002-5-b',
            text: '11歳、12歳、17歳、18歳',
            isCorrect: true,
            explanation: 'これらの値は境界（12歳と18歳）の内側と外側の値であり、境界値分析の原則に従っています。'
          },
          {
            id: 'q-002-5-c',
            text: '12歳、18歳',
            isCorrect: false,
            explanation: 'これらは境界上の値ですが、境界の外側の値（11歳、17歳）が含まれていません。'
          },
          {
            id: 'q-002-5-d',
            text: '0歳、12歳、18歳、100歳',
            isCorrect: false,
            explanation: '極端な値（0歳、100歳）は含まれていますが、境界のすぐ外側の値（11歳、17歳）が含まれていません。'
          }
        ],
        explanation: '境界値分析では、境界値とその周辺（境界のすぐ内側と外側）の値をテストすることが重要です。この例では、12歳と18歳が境界なので、11歳、12歳、17歳、18歳が適切なテストケースです。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-002-6',
        questionText: '境界値分析を適用する際の一般的なガイドラインはどれですか？',
        options: [
          {
            id: 'q-002-6-a',
            text: '境界値の両側をテストするが、境界上の値はテストしない',
            isCorrect: false,
            explanation: '境界上の値もテストすることが重要です。'
          },
          {
            id: 'q-002-6-b',
            text: '境界値とその周辺（境界値-1、境界値、境界値+1）をテストする',
            isCorrect: true,
            explanation: '境界値とその周辺の値をテストすることで、「off-by-one」エラーなどの境界条件のバグを効果的に検出できます。'
          },
          {
            id: 'q-002-6-c',
            text: '常に値の範囲の中間点をテストする',
            isCorrect: false,
            explanation: '中間点のテストは境界値分析の焦点ではありません。'
          },
          {
            id: 'q-002-6-d',
            text: '可能な限り多くの無効な値をテストする',
            isCorrect: false,
            explanation: '境界値分析では、境界のすぐ外側の値に焦点を当て、多数の無効値をテストすることは必ずしも必要ではありません。'
          }
        ],
        explanation: '境界値分析の一般的なガイドラインは、境界値とその周辺の値（境界値-1、境界値、境界値+1）をテストすることです。例えば、有効範囲が1〜10の場合、0、1、10、11の値をテストします。この方法により、「等しい」「以上」「未満」などの条件の実装ミスを効果的に検出できます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-002-7',
        questionText: '以下の仕様に対する境界値分析で、必要最小限のテストケースはいくつですか？\n\n仕様：温度制御システム\n- 温度範囲：-10℃〜40℃\n- 精度：0.5℃単位で設定可能',
        options: [
          {
            id: 'q-002-7-a',
            text: '2つ（-10℃と40℃）',
            isCorrect: false,
            explanation: '境界上の値だけではなく、境界の内側と外側の値もテストする必要があります。'
          },
          {
            id: 'q-002-7-b',
            text: '4つ（-10.5℃、-10℃、40℃、40.5℃）',
            isCorrect: true,
            explanation: 'これらの値は下限と上限の境界値とそのすぐ外側の値をカバーしており、最小限必要なテストケースです。'
          },
          {
            id: 'q-002-7-c',
            text: '6つ（-11℃、-10℃、-9.5℃、39.5℃、40℃、41℃）',
            isCorrect: false,
            explanation: '境界のすぐ内側の値（-9.5℃、39.5℃）は重要ですが、必須ではありません。また、精度が0.5℃単位なので、-10.5℃と40.5℃が適切な外側の値です。'
          },
          {
            id: 'q-002-7-d',
            text: '3つ（-10℃、15℃、40℃）',
            isCorrect: false,
            explanation: '中間値（15℃）は境界値分析では重要ではなく、境界の外側の値が含まれていません。'
          }
        ],
        explanation: '境界値分析では、各境界の値とそのすぐ外側の値をテストします。この温度制御システムでは、下限が-10℃、上限が40℃で、精度が0.5℃単位なので、最小限必要なテストケースは-10.5℃（下限の外側）、-10℃（下限）、40℃（上限）、40.5℃（上限の外側）の4つです。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-002-8',
        questionText: '以下のうち、境界値分析が特に有効な状況はどれですか？',
        options: [
          {
            id: 'q-002-8-a',
            text: '入力値の組み合わせによる相互作用をテストする場合',
            isCorrect: false,
            explanation: '入力値の組み合わせはペアワイズテストなどの技法が適しています。'
          },
          {
            id: 'q-002-8-b',
            text: '数値範囲や日付範囲など、明確な境界がある入力をテストする場合',
            isCorrect: true,
            explanation: '境界値分析は、数値範囲や日付範囲など明確な境界がある入力に特に有効です。'
          },
          {
            id: 'q-002-8-c',
            text: 'システムの性能限界を評価する場合',
            isCorrect: false,
            explanation: '性能限界の評価には、負荷テストやストレステストが適しています。'
          },
          {
            id: 'q-002-8-d',
            text: 'ユーザーインターフェースの使いやすさを評価する場合',
            isCorrect: false,
            explanation: 'UIの使いやすさの評価には、ユーザビリティテストが適しています。'
          }
        ],
        explanation: '境界値分析は、数値範囲、日付範囲、文字列の長さなど、明確な境界がある入力をテストする場合に特に有効です。これらの境界付近でバグが発生しやすく、例えば「1以上10以下」を「1より大きく10より小さい」と誤って実装するなどのミスを検出できます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-002-9',
        questionText: 'ショッピングサイトの割引機能に関する以下の仕様に対する境界値分析で、最適なテストケースはどれですか？\n\n仕様：\n- 購入金額が5,000円未満：割引なし\n- 購入金額が5,000円以上10,000円未満：5%割引\n- 購入金額が10,000円以上：10%割引',
        options: [
          {
            id: 'q-002-9-a',
            text: '4,999円、5,000円、9,999円、10,000円',
            isCorrect: true,
            explanation: 'これらの値は境界（5,000円と10,000円）のすぐ内側と外側の値であり、境界値分析の原則に従っています。'
          },
          {
            id: 'q-002-9-b',
            text: '4,000円、5,000円、9,000円、10,000円',
            isCorrect: false,
            explanation: '下限境界のすぐ内側（4,999円）と上限境界のすぐ内側（9,999円）の値が含まれていません。'
          },
          {
            id: 'q-002-9-c',
            text: '0円、5,000円、10,000円、20,000円',
            isCorrect: false,
            explanation: '極端な値（0円、20,000円）は含まれていますが、境界のすぐ内側の値（4,999円、9,999円）が含まれていません。'
          },
          {
            id: 'q-002-9-d',
            text: '4,999円、5,001円、9,999円、10,001円',
            isCorrect: false,
            explanation: '境界上の値（5,000円、10,000円）が含まれていません。'
          }
        ],
        explanation: '境界値分析では、境界とその周辺の値をテストします。この例では、5,000円と10,000円が境界なので、4,999円、5,000円、9,999円、10,000円が最適なテストケースです。これらの値で、各割引レベルの境界でシステムが正しく動作するかを確認できます。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-002-10',
        questionText: '以下のうち、境界値分析に関する説明として正しいものはどれですか？',
        options: [
          {
            id: 'q-002-10-a',
            text: '境界値分析は、常にすべての入力パラメータの組み合わせをテストする必要がある',
            isCorrect: false,
            explanation: 'すべての組み合わせをテストするのは組み合わせテスト技法の特徴であり、境界値分析の主な焦点ではありません。'
          },
          {
            id: 'q-002-10-b',
            text: '境界値分析は、同値分割法の代わりに使用するテスト技法である',
            isCorrect: false,
            explanation: '境界値分析は同値分割法の代わりではなく、補完するものとして使用します。'
          },
          {
            id: 'q-002-10-c',
            text: '境界値分析は、プログラマーが「off-by-one」エラーを犯しやすい境界条件に焦点を当てる',
            isCorrect: true,
            explanation: '境界値分析は、プログラマーが条件の実装を誤りやすい境界付近の値に焦点を当て、「off-by-one」のようなエラーを検出します。'
          },
          {
            id: 'q-002-10-d',
            text: '境界値分析は、主にパフォーマンス問題を検出するために使用される',
            isCorrect: false,
            explanation: '境界値分析は機能的な正確性をテストするもので、パフォーマンス問題の検出が主目的ではありません。'
          }
        ],
        explanation: '境界値分析は、プログラマーが「以上」「より大きい」「以下」「未満」などの条件を誤って実装しやすい境界条件に焦点を当てるテスト技法です。特に「off-by-one」エラー（1つずれるエラー）のような、境界付近で発生しやすいバグを効果的に検出します。同値分割法と組み合わせて使用することで、テストの効率と効果を高めることができます。',
        difficulty: 'easy',
        points: 5
      }
    ],
    techniqueName: '境界値分析',
    techniqueId: 'boundary-value-analysis',
    categoryId: 'blackbox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '25分'
  },
  {
    id: 'ex-003',
    title: '決定表テストの演習',
    description: '決定表テスト（Decision Table Testing）技法を使った実践演習です。',
    objective: 'この演習では、複数の条件と結果の組み合わせを効率的にテストするための決定表テスト技法を学びます。',
    scenarioDescription: 
      'あなたはECサイトのテスターです。割引システムには以下のルールがあります：\n\n' +
      '- 会員ステータス：一般会員またはプレミアム会員\n' +
      '- 購入回数：10回未満または10回以上\n' +
      '- 購入金額：5,000円以上または5,000円未満\n\n' +
      'これらの条件に基づいて、以下の割引率が適用されます：\n' +
      '- プレミアム会員で購入回数10回以上：15%割引\n' +
      '- プレミアム会員で購入回数10回未満：10%割引\n' +
      '- 一般会員で購入回数10回以上かつ購入金額5,000円以上：8%割引\n' +
      '- 一般会員で購入回数10回以上かつ購入金額5,000円未満：5%割引\n' +
      '- 一般会員で購入回数10回未満かつ購入金額5,000円以上：5%割引\n' +
      '- 一般会員で購入回数10回未満かつ購入金額5,000円未満：割引なし\n\n' +
      'この機能に対して決定表テスト技法を用いて効果的なテストケースを設計してください。',
    steps: [
      {
        stepNumber: 1,
        description: '条件と結果を特定する'
      },
      {
        stepNumber: 2,
        description: '可能な条件の組み合わせを決定表にまとめる'
      },
      {
        stepNumber: 3,
        description: '決定表から必要なテストケースを設計する'
      },
      {
        stepNumber: 4,
        description: '冗長なテストケースを削減する'
      }
    ],
    quiz: [
      {
        id: 'q-003-1',
        questionText: '上記のECサイト割引システムに対する決定表で、必要最小限のテストケース数はいくつですか？',
        options: [
          {
            id: 'q-003-1-a',
            text: '2つ',
            isCorrect: false,
            explanation: '2つでは会員ステータス（2種類）のみをカバーすることしかできず、不十分です。'
          },
          {
            id: 'q-003-1-b',
            text: '4つ',
            isCorrect: false,
            explanation: '4つでは会員ステータス（2種類）と購入回数（2種類）の組み合わせはカバーできますが、購入金額の条件が考慮されていません。'
          },
          {
            id: 'q-003-1-c',
            text: '6つ',
            isCorrect: true,
            explanation: '会員ステータス（2種類）、購入回数（2種類）、購入金額（2種類）の組み合わせで、理論上は8通りですが、プレミアム会員の場合は購入金額に関わらず同じ結果になるため、実際には6つのテストケースが必要です。'
          },
          {
            id: 'q-003-1-d',
            text: '8つ',
            isCorrect: false,
            explanation: '理論上は2×2×2=8通りの組み合わせがありますが、プレミアム会員の場合は購入金額による結果の違いがないため、8つすべてをテストする必要はありません。'
          }
        ],
        explanation: '決定表テストでは、条件の組み合わせごとに異なる結果が得られるケースをテストします。この例では、プレミアム会員の場合、購入金額に関わらず購入回数だけで割引率が決まるため、プレミアム会員については2ケース、一般会員については購入回数と購入金額の組み合わせで4ケース、合計6つのテストケースが必要になります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-003-2',
        questionText: '決定表テスト技法が特に有効な状況はどれですか？',
        options: [
          {
            id: 'q-003-2-a',
            text: '単一の入力値の境界をテストする場合',
            isCorrect: false,
            explanation: '単一入力値の境界テストには境界値分析が適しています。'
          },
          {
            id: 'q-003-2-b',
            text: '複数の条件の組み合わせによって異なる結果が発生する場合',
            isCorrect: true,
            explanation: '複数の条件（入力）の組み合わせによって異なる結果（出力）が発生する場合、決定表テストが特に有効です。'
          },
          {
            id: 'q-003-2-c',
            text: '連続的なユーザーの動作をテストする場合',
            isCorrect: false,
            explanation: '連続的なユーザー動作のテストにはステートトランジションテストが適しています。'
          },
          {
            id: 'q-003-2-d',
            text: '大量の入力データからサンプルを選んでテストする場合',
            isCorrect: false,
            explanation: '大量の入力データからサンプルを選ぶには同値分割法が適しています。'
          }
        ],
        explanation: '決定表テスト技法は、複数の条件（入力）の組み合わせによって異なる結果（出力）が発生するロジックをテストする場合に特に有効です。例えば、割引の適用条件、ローンの承認条件、保険料の計算など、「IF-THEN-ELSE」が複雑に組み合わさったビジネスルールのテストに適しています。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-003-3',
        questionText: '以下の決定表の一部で、「?」の部分に入るべき値は何ですか？\n\n| 条件/テストケース | TC1 | TC2 | TC3 | TC4 |\n|-----------------|-----|-----|-----|-----|\n| 条件1 | Y | Y | N | N |\n| 条件2 | Y | N | Y | ? |',
        options: [
          {
            id: 'q-003-3-a',
            text: 'Y',
            isCorrect: false,
            explanation: 'TC3ですでに「条件1=N、条件2=Y」の組み合わせがあるため、TC4で同じ組み合わせを重複させる必要はありません。'
          },
          {
            id: 'q-003-3-b',
            text: 'N',
            isCorrect: true,
            explanation: '完全な決定表では、すべての条件の組み合わせをカバーする必要があります。TC1〜TC3で「Y-Y」「Y-N」「N-Y」を使っているので、TC4には「N-N」が必要です。'
          },
          {
            id: 'q-003-3-c',
            text: '-（どちらでもよい）',
            isCorrect: false,
            explanation: '完全な決定表を作成するためには、すべての条件の組み合わせを明示的にカバーする必要があります。'
          },
          {
            id: 'q-003-3-d',
            text: 'このテストケースは不要',
            isCorrect: false,
            explanation: '2つの条件がある場合、2^2=4通りの組み合わせが必要です。TC4は「条件1=N、条件2=N」の組み合わせをテストするために必要です。'
          }
        ],
        explanation: '決定表テストでは、N個の条件に対して2^N通りの組み合わせをすべてカバーします（条件が排他的でない場合）。この例では、2つの条件があるため、2^2=4通りの組み合わせが必要です。TC1〜TC3ですでに「Y-Y」「Y-N」「N-Y」の組み合わせをカバーしているので、TC4では残りの「N-N」の組み合わせをテストする必要があります。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-003-4',
        questionText: '決定表テストを実施する際の正しいステップはどれですか？',
        options: [
          {
            id: 'q-003-4-a',
            text: '1. 可能なすべての入力値を列挙する 2. 各入力値の同値クラスを識別する 3. 各同値クラスから代表値を選ぶ',
            isCorrect: false,
            explanation: 'これは同値分割法のステップであり、決定表テストのステップではありません。'
          },
          {
            id: 'q-003-4-b',
            text: '1. テスト対象の条件を特定する 2. 各条件のすべての組み合わせを決定表に記載する 3. 各組み合わせに対する期待結果を記載する 4. テストケースを設計する',
            isCorrect: true,
            explanation: 'これは決定表テストの基本的なステップです。条件を特定し、その組み合わせと期待結果を決定表にまとめ、テストケースを設計します。'
          },
          {
            id: 'q-003-4-c',
            text: '1. 境界値を特定する 2. 境界値の内側と外側の値をテストケースに含める',
            isCorrect: false,
            explanation: 'これは境界値分析のステップであり、決定表テストのステップではありません。'
          },
          {
            id: 'q-003-4-d',
            text: '1. システムの状態を特定する 2. 状態間の遷移を特定する 3. 状態遷移図を作成する',
            isCorrect: false,
            explanation: 'これはステートトランジションテストのステップであり、決定表テストのステップではありません。'
          }
        ],
        explanation: '決定表テストの基本的なステップは以下の通りです：\n1. テスト対象のシステムから関連する条件と結果を特定する\n2. 可能なすべての条件の組み合わせを決定表に記載する\n3. 各組み合わせに対する期待結果を決定表に記載する\n4. 決定表をテストケースに変換する\n5. 必要に応じて冗長なテストケースを削減する（ルール結合を行う）',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-003-5',
        questionText: '16個の条件の組み合わせがある複雑なビジネスルールをテストするとき、フルの決定表テストでは何個のテストケースが必要ですか？',
        options: [
          {
            id: 'q-003-5-a',
            text: '16個',
            isCorrect: false,
            explanation: '16個は条件の数であり、組み合わせの数ではありません。'
          },
          {
            id: 'q-003-5-b',
            text: '32個',
            isCorrect: false,
            explanation: '32個（2^5=32）は5つの条件がある場合の組み合わせ数です。'
          },
          {
            id: 'q-003-5-c',
            text: '256個',
            isCorrect: false,
            explanation: '256個（2^8=256）は8つの条件がある場合の組み合わせ数です。'
          },
          {
            id: 'q-003-5-d',
            text: '65,536個',
            isCorrect: true,
            explanation: '各条件には2つの値（TrueとFalse）があるため、16個の条件の組み合わせ数は2^16=65,536個になります。'
          }
        ],
        explanation: '決定表テストでは、N個の条件に対してテストケース数は2^N個になります（各条件が2値の場合）。16個の条件があれば、テストケース数は2^16=65,536個になります。これは非常に多いため、実際には条件を減らしたり、条件の依存関係を考慮したり、他のテスト技法と組み合わせたりして、効率的にテストします。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-003-6',
        questionText: '決定表テストの主な利点は何ですか？',
        options: [
          {
            id: 'q-003-6-a',
            text: 'テスト実行の自動化が容易になる',
            isCorrect: false,
            explanation: '決定表テストはテスト設計の技法であり、テスト実行の自動化とは直接関係ありません。'
          },
          {
            id: 'q-003-6-b',
            text: '複雑なビジネスルールを明確に可視化し、漏れなくテストできる',
            isCorrect: true,
            explanation: '決定表テストの主な利点は、複雑なビジネスルールを構造化し、条件の組み合わせを漏れなくテストできることです。'
          },
          {
            id: 'q-003-6-c',
            text: 'テストの実行時間を短縮できる',
            isCorrect: false,
            explanation: '決定表テストはテスト設計の技法であり、テスト実行時間の短縮とは直接関係ありません。'
          },
          {
            id: 'q-003-6-d',
            text: 'ユーザビリティの問題を発見できる',
            isCorrect: false,
            explanation: '決定表テストは機能的な正確性をテストするもので、ユーザビリティの問題発見が主目的ではありません。'
          }
        ],
        explanation: '決定表テストの主な利点は、複雑なビジネスルールやIF-THEN-ELSE構造を持つロジックを明確に構造化し、条件の組み合わせを漏れなくテストできることです。テスト設計者が条件の組み合わせを見落とすことを防ぎ、ロジックの不整合や欠陥を効果的に発見できます。また、ビジネスルールの可視化にも役立ちます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-003-7',
        questionText: '以下の決定表で、TC3のテストケースはどのような条件と結果になりますか？\n\n| 条件/テストケース | TC1 | TC2 | TC3 | TC4 |\n|-----------------|-----|-----|-----|-----|\n| 会員ステータス | 一般 | 一般 | プレミアム | プレミアム |\n| 購入回数10回以上 | N | Y | N | Y |\n| 結果：割引率 | 0% | 5% | 10% | 15% |',
        options: [
          {
            id: 'q-003-7-a',
            text: '一般会員で購入回数10回以上の場合、5%割引',
            isCorrect: false,
            explanation: 'これはTC2の条件と結果です。'
          },
          {
            id: 'q-003-7-b',
            text: 'プレミアム会員で購入回数10回未満の場合、10%割引',
            isCorrect: true,
            explanation: 'TC3は「会員ステータス=プレミアム、購入回数10回以上=N（つまり10回未満）」という条件で、結果は10%割引です。'
          },
          {
            id: 'q-003-7-c',
            text: 'プレミアム会員で購入回数10回以上の場合、15%割引',
            isCorrect: false,
            explanation: 'これはTC4の条件と結果です。'
          },
          {
            id: 'q-003-7-d',
            text: '一般会員で購入回数10回未満の場合、割引なし',
            isCorrect: false,
            explanation: 'これはTC1の条件と結果です。'
          }
        ],
        explanation: '決定表では、各列（TCx）がテストケースを表し、各行が条件と結果を表します。TC3の列を見ると、「会員ステータス=プレミアム、購入回数10回以上=N（つまり10回未満）」という条件で、結果は10%割引になっています。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-003-8',
        questionText: '決定表テストで「ルール結合」とは何ですか？',
        options: [
          {
            id: 'q-003-8-a',
            text: '複数のテストケースを1つにまとめる技法',
            isCorrect: true,
            explanation: 'ルール結合は、特定の条件が結果に影響しない場合に、複数のテストケースをまとめる技法です。'
          },
          {
            id: 'q-003-8-b',
            text: '複数のアプリケーションのルールを比較する技法',
            isCorrect: false,
            explanation: 'これは決定表テストにおけるルール結合の意味ではありません。'
          },
          {
            id: 'q-003-8-c',
            text: '条件同士を組み合わせて新しい条件を作る技法',
            isCorrect: false,
            explanation: 'これは条件の結合であり、ルール結合ではありません。'
          },
          {
            id: 'q-003-8-d',
            text: 'テスト実行の順序を決定する技法',
            isCorrect: false,
            explanation: 'ルール結合はテスト実行の順序とは関係ありません。'
          }
        ],
        explanation: '決定表テストにおける「ルール結合」とは、特定の条件の値が結果に影響しない場合に、複数のテストケース（ルール）を1つにまとめる技法です。例えば、「条件A=Y、条件B=Y」と「条件A=Y、条件B=N」の両方で同じ結果が得られる場合、これらを「条件A=Y、条件B=どちらでも」という1つのテストケースにまとめることができます。これにより、テストケースの数を削減できます。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-003-9',
        questionText: '決定表テストを適用する際の課題と対策として正しいものはどれですか？',
        options: [
          {
            id: 'q-003-9-a',
            text: '課題：条件が多いと組み合わせ爆発が起きる、対策：条件の依存関係を考慮して不可能な組み合わせを除外する',
            isCorrect: true,
            explanation: '条件が多いと組み合わせの数が指数関数的に増加する問題があり、条件の依存関係を考慮して不可能な組み合わせを除外するのは有効な対策です。'
          },
          {
            id: 'q-003-9-b',
            text: '課題：テスト実行に時間がかかる、対策：並列実行を導入する',
            isCorrect: false,
            explanation: 'テスト実行の時間は決定表テストの主な課題ではなく、テスト設計の段階での組み合わせ爆発が主な課題です。'
          },
          {
            id: 'q-003-9-c',
            text: '課題：境界値を特定するのが難しい、対策：同値分割法を先に適用する',
            isCorrect: false,
            explanation: '境界値の特定は境界値分析の課題であり、決定表テストの主な課題ではありません。'
          },
          {
            id: 'q-003-9-d',
            text: '課題：ユーザーの行動パターンを予測できない、対策：探索的テストを併用する',
            isCorrect: false,
            explanation: 'ユーザー行動パターンの予測は決定表テストの主な課題ではなく、決定表テストはビジネスルールなどの条件と結果の関係をテストする技法です。'
          }
        ],
        explanation: '決定表テストの主な課題は、条件が多くなると組み合わせの数が指数関数的に増加する「組み合わせ爆発」です。例えば、10個の条件があると、2^10=1,024個のテストケースが必要になります。この課題に対する効果的な対策としては、条件の依存関係を考慮して不可能な組み合わせを除外する、条件をグループ化する、ペアワイズテストのような組み合わせテスト技法を使用して効率的にカバレッジを確保するなどがあります。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-003-10',
        questionText: '以下のうち、決定表テストに関する説明として正しいものはどれですか？',
        options: [
          {
            id: 'q-003-10-a',
            text: '決定表テストは、主にパフォーマンス問題を検出するために使用される',
            isCorrect: false,
            explanation: '決定表テストはビジネスルールの正確性をテストするもので、パフォーマンス問題の検出が主目的ではありません。'
          },
          {
            id: 'q-003-10-b',
            text: '決定表テストは、複数の条件の組み合わせに基づくロジックをテストするための系統的なアプローチを提供する',
            isCorrect: true,
            explanation: '決定表テストは、複数の条件とその組み合わせによって異なる結果が発生するロジックを、系統的にテストするためのアプローチを提供します。'
          },
          {
            id: 'q-003-10-c',
            text: '決定表テストは、ユーザーインターフェースの使いやすさを評価するのに最適である',
            isCorrect: false,
            explanation: '決定表テストはUIの使いやすさを評価するものではなく、ビジネスルールなどの条件と結果の関係をテストする技法です。'
          },
          {
            id: 'q-003-10-d',
            text: '決定表テストは、コードの網羅率を高めるために使用される',
            isCorrect: false,
            explanation: '決定表テストの主な目的はコードの網羅率を高めることではなく、ビジネスルールの条件と結果の組み合わせを漏れなくテストすることです。'
          }
        ],
        explanation: '決定表テストは、複数の条件の組み合わせに基づくロジック（特にビジネスルールやIF-THEN-ELSE構造を持つロジック）をテストするための系統的なアプローチを提供します。条件の組み合わせと、それに対応する結果をテーブル形式で表現し、漏れなくテストすることを目的としています。特に、複雑な条件分岐がある場合や、条件の組み合わせによって異なる結果が得られる場合に効果的です。',
        difficulty: 'easy',
        points: 5
      }
    ],
    techniqueName: '決定表テスト',
    techniqueId: 'decision-table',
    categoryId: 'blackbox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '25分'
  },
  {
    id: 'ex-004',
    title: '状態遷移テストの演習',
    description: '状態遷移テスト（State Transition Testing）技法を使った実践演習です。',
    objective: 'この演習では、システムの状態変化と遷移を効果的にテストするための状態遷移テスト技法を学びます。',
    scenarioDescription: 
      'あなたはECサイトの注文システムのテスターです。このシステムは以下の状態と遷移を持っています：\n\n' +
      '状態：\n' +
      '- カート（初期状態）\n' +
      '- 配送情報入力\n' +
      '- 支払い情報入力\n' +
      '- 注文確認\n' +
      '- 注文完了\n' +
      '- エラー\n\n' +
      '主な遷移：\n' +
      '- カート → 配送情報入力：「次へ」ボタンをクリック（商品がカートにある場合）\n' +
      '- 配送情報入力 → 支払い情報入力：「次へ」ボタンをクリック（有効な配送情報が入力されている場合）\n' +
      '- 配送情報入力 → カート：「戻る」ボタンをクリック\n' +
      '- 支払い情報入力 → 注文確認：「次へ」ボタンをクリック（有効な支払い情報が入力されている場合）\n' +
      '- 支払い情報入力 → 配送情報入力：「戻る」ボタンをクリック\n' +
      '- 注文確認 → 注文完了：「注文確定」ボタンをクリック（すべての情報が正しい場合）\n' +
      '- 注文確認 → 支払い情報入力：「戻る」ボタンをクリック\n' +
      '- 任意の状態 → エラー：システムエラーが発生した場合\n' +
      '- エラー → カート：「カートに戻る」ボタンをクリック\n\n' +
      'この注文システムに対して状態遷移テスト技法を用いて効果的なテストケースを設計してください。',
    steps: [
      {
        stepNumber: 1,
        description: 'システムの状態と遷移を特定する'
      },
      {
        stepNumber: 2,
        description: '状態遷移図（または表）を作成する'
      },
      {
        stepNumber: 3,
        description: '状態遷移カバレッジを考慮してテストケースを設計する'
      },
      {
        stepNumber: 4,
        description: '異常なシナリオも考慮する'
      }
    ],
    quiz: [
      {
        id: 'q-004-1',
        questionText: '状態遷移テストで「状態」とは何ですか？',
        options: [
          {
            id: 'q-004-1-a',
            text: 'テスト実行中の実行ステータス（成功/失敗/進行中など）',
            isCorrect: false,
            explanation: 'これはテスト自体の状態であり、テスト対象システムの状態ではありません。'
          },
          {
            id: 'q-004-1-b',
            text: 'テスターの心理状態（集中/疲労/満足など）',
            isCorrect: false,
            explanation: 'テスターの心理状態はテストとは関係ありません。'
          },
          {
            id: 'q-004-1-c',
            text: 'システムが取りうる安定した条件や形態',
            isCorrect: true,
            explanation: '状態遷移テストにおける「状態」とは、システムがある一定の時点で取りうる安定した条件や形態を指します。'
          },
          {
            id: 'q-004-1-d',
            text: 'テスト対象コードの行数やカバレッジの割合',
            isCorrect: false,
            explanation: 'コードの行数やカバレッジの割合は状態ではなく、テスト品質の指標です。'
          }
        ],
        explanation: '状態遷移テストにおける「状態」とは、システムが特定の時点で取りうる安定した条件や形態を指します。例えば、ECサイトの注文システムでは「カート」「配送情報入力」「支払い情報入力」などが状態となります。各状態では、システムは特定の動作や振る舞いをし、ユーザーやシステムのアクションによって別の状態に遷移します。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-004-2',
        questionText: '状態遷移テストにおける「遷移」とは何ですか？',
        options: [
          {
            id: 'q-004-2-a',
            text: 'あるテストケースから別のテストケースへの移行',
            isCorrect: false,
            explanation: 'これはテストケース間の移行であり、システムの状態遷移ではありません。'
          },
          {
            id: 'q-004-2-b',
            text: 'ある状態から別の状態へのシステムの変化',
            isCorrect: true,
            explanation: '遷移とは、ある状態から別の状態へのシステムの変化を指します。これは通常、何らかのイベントやアクション（入力）によって引き起こされます。'
          },
          {
            id: 'q-004-2-c',
            text: 'テスト環境から本番環境へのリリース',
            isCorrect: false,
            explanation: 'これはソフトウェアのデプロイメントに関する概念であり、状態遷移テストにおける遷移ではありません。'
          },
          {
            id: 'q-004-2-d',
            text: '異なるテスト技法間の切り替え',
            isCorrect: false,
            explanation: 'これはテスト戦略に関する概念であり、状態遷移テストにおける遷移ではありません。'
          }
        ],
        explanation: '状態遷移テストにおける「遷移」とは、あるシステム状態から別のシステム状態への変化を指します。遷移はイベントやアクション（例：ボタンのクリック、データの入力、タイマーの満了など）によって引き起こされます。例えば、ECサイトの注文システムでは、「次へ」ボタンのクリックにより「カート」状態から「配送情報入力」状態への遷移が発生します。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-004-3',
        questionText: '状態遷移テストが特に適している状況はどれですか？',
        options: [
          {
            id: 'q-004-3-a',
            text: '単一の入力フィールドの境界値をテストする場合',
            isCorrect: false,
            explanation: '単一入力フィールドの境界値テストには境界値分析が適しています。'
          },
          {
            id: 'q-004-3-b',
            text: '複数の条件の組み合わせによる結果をテストする場合',
            isCorrect: false,
            explanation: '複数条件の組み合わせには決定表テストが適しています。'
          },
          {
            id: 'q-004-3-c',
            text: 'システムの動作が現在の状態と入力に依存する場合',
            isCorrect: true,
            explanation: 'システムの動作が現在の状態と入力に依存する場合、状態遷移テストが特に適しています。'
          },
          {
            id: 'q-004-3-d',
            text: '大量の入力データのパターンを効率的にテストする場合',
            isCorrect: false,
            explanation: '大量の入力データパターンには同値分割法やペアワイズテストが適しています。'
          }
        ],
        explanation: '状態遷移テストは、システムの動作が現在の状態と入力によって決まるような状況で特に有効です。例えば、ワークフロー管理システム、ウィザード形式のインターフェース、ステータスを持つアプリケーション（注文処理、予約システムなど）、有限状態機械に基づくシステムなどです。これらのシステムでは、同じ入力でも現在の状態によって異なる結果が生じる可能性があります。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-004-4',
        questionText: '注文システムの状態遷移テストで、以下のテストシナリオのうち最も重要なものはどれですか？',
        options: [
          {
            id: 'q-004-4-a',
            text: 'カート → 配送情報入力 → 支払い情報入力 → 注文確認 → 注文完了（正常フロー）',
            isCorrect: true,
            explanation: '正常フローは最も基本的なシナリオであり、システムの主要機能が正しく動作することを確認するために最も重要です。'
          },
          {
            id: 'q-004-4-b',
            text: 'カート → 配送情報入力 → カート → 配送情報入力（繰り返しフロー）',
            isCorrect: false,
            explanation: '繰り返しフローも重要ですが、主要機能の動作を確認する正常フローほど優先度は高くありません。'
          },
          {
            id: 'q-004-4-c',
            text: 'カート → 配送情報入力 → 支払い情報入力 → 注文確認 → 支払い情報入力（戻るフロー）',
            isCorrect: false,
            explanation: '戻るフローも重要ですが、主要機能の動作を確認する正常フローほど優先度は高くありません。'
          },
          {
            id: 'q-004-4-d',
            text: 'カート（空の状態） → エラー → カート（異常フロー）',
            isCorrect: false,
            explanation: '異常フローも重要ですが、主要機能の動作を確認する正常フローほど優先度は高くありません。'
          }
        ],
        explanation: '状態遷移テストでは、まず正常フロー（ハッピーパス）をテストすることが最も重要です。これはシステムの主要機能が意図した通りに動作することを確認します。例えば、注文システムでは「カート → 配送情報入力 → 支払い情報入力 → 注文確認 → 注文完了」という一連の流れが正常に機能することをまず確認します。その後、戻る操作、繰り返し操作、エラー状態からの回復など、他のシナリオもテストします。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-004-5',
        questionText: '状態遷移テストで「N-1スイッチカバレッジ」とは何ですか？',
        options: [
          {
            id: 'q-004-5-a',
            text: 'すべての状態を少なくとも1回訪問するテストカバレッジ',
            isCorrect: false,
            explanation: 'これは「状態カバレッジ」であり、N-1スイッチカバレッジではありません。'
          },
          {
            id: 'q-004-5-b',
            text: 'すべての遷移（状態の変化）を少なくとも1回実行するテストカバレッジ',
            isCorrect: true,
            explanation: 'N-1スイッチカバレッジ（簡単に言えば「0-スイッチカバレッジ」）は、すべての遷移を少なくとも1回テストするカバレッジです。'
          },
          {
            id: 'q-004-5-c',
            text: 'すべての状態の組み合わせをテストするカバレッジ',
            isCorrect: false,
            explanation: 'すべての状態の組み合わせというカバレッジの概念はありません。'
          },
          {
            id: 'q-004-5-d',
            text: 'N回の遷移から1回を除外するテストカバレッジ',
            isCorrect: false,
            explanation: 'これはN-1スイッチカバレッジの誤った解釈です。'
          }
        ],
        explanation: '状態遷移テストにおける「N-1スイッチカバレッジ」（Nは0から始まるため、0スイッチカバレッジとも呼ばれる）は、すべての個別の遷移（あるいは「エッジ」）を少なくとも1回テストするカバレッジレベルを指します。つまり、状態遷移図のすべての矢印が少なくとも1回テストされることを確認します。例えば、「カート → 配送情報入力」、「配送情報入力 → 支払い情報入力」などの各遷移を少なくとも1回テストします。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-004-6',
        questionText: '状態遷移テストで「状態遷移表」と「状態遷移図」の主な違いは何ですか？',
        options: [
          {
            id: 'q-004-6-a',
            text: '状態遷移表は数学的に正確だが、状態遷移図はそうではない',
            isCorrect: false,
            explanation: '両方とも数学的に同じ情報を表現でき、正確さに違いはありません。'
          },
          {
            id: 'q-004-6-b',
            text: '状態遷移表はテキスト形式だが、状態遷移図はグラフィカル表現である',
            isCorrect: true,
            explanation: '状態遷移表はテキストや表形式で情報を整理し、状態遷移図は同じ情報をグラフィカルに視覚化します。'
          },
          {
            id: 'q-004-6-c',
            text: '状態遷移表はプログラムで実行できるが、状態遷移図はそうではない',
            isCorrect: false,
            explanation: '両方ともモデル化のための表現であり、そのままプログラムとして実行できるわけではありません。'
          },
          {
            id: 'q-004-6-d',
            text: '状態遷移表は初心者向け、状態遷移図は専門家向けである',
            isCorrect: false,
            explanation: '両方とも専門性には関係なく、表現方法の違いであり、状況や好みによって使い分けます。'
          }
        ],
        explanation: '状態遷移表と状態遷移図の主な違いは表現形式です。状態遷移表は行と列を使ったマトリックス形式で情報を整理します（行が現在の状態、列が入力/イベント、セルが次の状態を表す）。一方、状態遷移図はノード（状態）と矢印（遷移）を使ったグラフィカルな表現です。両方とも同じ情報を表現しますが、状態遷移図は視覚的に理解しやすく、状態遷移表は特に状態や遷移が多い場合に詳細情報を整理しやすいという特徴があります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-004-7',
        questionText: '以下の状態遷移図から、有効な状態遷移パスはどれですか？\n\n初期状態→状態A→状態B→状態C→最終状態\n初期状態→状態D→状態B→状態C→最終状態\n状態A↔状態B\n状態B→状態D（エラー時）',
        options: [
          {
            id: 'q-004-7-a',
            text: '初期状態→状態D→状態A→状態B→状態C→最終状態',
            isCorrect: false,
            explanation: '状態Dから状態Aへの遷移は図に定義されていません。'
          },
          {
            id: 'q-004-7-b',
            text: '初期状態→状態A→状態B→状態A→状態B→状態C→最終状態',
            isCorrect: true,
            explanation: 'この経路は図に定義されたすべての遷移に従っています。状態A↔状態Bの双方向の遷移を使用しています。'
          },
          {
            id: 'q-004-7-c',
            text: '初期状態→状態A→状態C→最終状態',
            isCorrect: false,
            explanation: '状態Aから状態Cへの直接の遷移は図に定義されていません。'
          },
          {
            id: 'q-004-7-d',
            text: '初期状態→状態D→状態B→状態D→状態C→最終状態',
            isCorrect: false,
            explanation: '状態Dから状態Cへの直接の遷移は図に定義されていません。'
          }
        ],
        explanation: '有効な状態遷移パスは、状態遷移図で定義された遷移のみを使用するパスです。この場合、「初期状態→状態A→状態B→状態A→状態B→状態C→最終状態」は有効なパスです。初期状態から状態Aに移動し、状態Aと状態Bの間を行き来した後（状態A↔状態Bの双方向遷移を利用）、状態Bから状態Cを経て最終状態に到達しています。すべての遷移は図に定義されています。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-004-8',
        questionText: '状態遷移テストでよく考慮すべき「不正な遷移」とは何ですか？',
        options: [
          {
            id: 'q-004-8-a',
            text: '定義されていない状態への遷移',
            isCorrect: false,
            explanation: '定義されていない状態は存在しないため、そこへの遷移は考慮できません。'
          },
          {
            id: 'q-004-8-b',
            text: '現在の状態から遷移が定義されていない状態への移動を試みること',
            isCorrect: true,
            explanation: '不正な遷移とは、現在の状態からは許可されていない（遷移が定義されていない）状態への移動を試みることです。'
          },
          {
            id: 'q-004-8-c',
            text: '状態遷移図に記載されていない新しい状態の追加',
            isCorrect: false,
            explanation: 'テスト中に新しい状態を追加することはテストの範囲外です。'
          },
          {
            id: 'q-004-8-d',
            text: 'テスト実行中にシステムを再起動すること',
            isCorrect: false,
            explanation: 'システムの再起動自体は不正な遷移ではなく、テスト環境の操作です。'
          }
        ],
        explanation: '状態遷移テストにおける「不正な遷移」とは、現在の状態から遷移が定義されていない（許可されていない）状態への移動を試みることです。例えば、注文システムで「配送情報入力」状態から「注文完了」状態へ直接移動しようとする（「支払い情報入力」と「注文確認」をスキップする）などが不正な遷移になります。不正な遷移をテストすることで、システムが適切にエラーを処理し、不正な状態遷移を防止できることを確認します。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-004-9',
        questionText: '注文システムの状態遷移テストで、以下のテストケースのうち「異常系」をテストするものはどれですか？',
        options: [
          {
            id: 'q-004-9-a',
            text: 'カート → 配送情報入力 → 支払い情報入力 → 注文確認 → 注文完了',
            isCorrect: false,
            explanation: 'これは正常系のフローであり、異常系ではありません。'
          },
          {
            id: 'q-004-9-b',
            text: '配送情報入力画面で不正な郵便番号を入力し、エラーメッセージが表示されることを確認する',
            isCorrect: true,
            explanation: 'これは不正な入力に対するシステムの反応をテストする異常系のテストケースです。'
          },
          {
            id: 'q-004-9-c',
            text: 'カート → 配送情報入力 → カート → 配送情報入力 → 支払い情報入力',
            isCorrect: false,
            explanation: 'これは「戻る」機能をテストする通常の操作フローであり、異常系ではありません。'
          },
          {
            id: 'q-004-9-d',
            text: '支払い情報入力 → 注文確認 → 支払い情報入力 → 注文確認 → 注文完了',
            isCorrect: false,
            explanation: 'これは「戻る」と「次へ」の機能をテストする通常の操作フローであり、異常系ではありません。'
          }
        ],
        explanation: '状態遷移テストにおける「異常系」のテストケースとは、システムが例外的な状況や不正な入力に対して適切に対応するかをテストするケースです。例えば、必須フィールドを空のままにする、不正なデータ形式を入力する、存在しない値を入力するなどが異常系のテストになります。選択肢の中では、「配送情報入力画面で不正な郵便番号を入力し、エラーメッセージが表示されることを確認する」が異常系のテストケースです。これにより、システムが不正な入力を適切に検出し、ユーザーに通知できることを確認します。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-004-10',
        questionText: '状態遷移テストを実施する際の効果的なアプローチはどれですか？',
        options: [
          {
            id: 'q-004-10-a',
            text: 'すべての可能な状態遷移の組み合わせを網羅的にテストする',
            isCorrect: false,
            explanation: '状態と遷移が多い場合、すべての組み合わせをテストすることは現実的ではなく、効率的なテスト戦略が必要です。'
          },
          {
            id: 'q-004-10-b',
            text: 'ランダムに状態遷移を選んでテストする',
            isCorrect: false,
            explanation: 'ランダムなテストでは重要な遷移が漏れる可能性があります。'
          },
          {
            id: 'q-004-10-c',
            text: '最も使用頻度の高い遷移パスと重要な異常系シナリオを優先してテストする',
            isCorrect: true,
            explanation: '効率的なテスト戦略では、使用頻度の高いパスと重要な異常系シナリオを優先します。'
          },
          {
            id: 'q-004-10-d',
            text: '最も実装が複雑な状態のみをテストする',
            isCorrect: false,
            explanation: '特定の状態のみをテストするのでは、状態間の遷移に関する問題を見逃す可能性があります。'
          }
        ],
        explanation: '状態遷移テストを効果的に実施するためには、以下のようなアプローチが有効です：\n1. 最も使用頻度の高い遷移パス（正常系のフロー）を優先的にテストする\n2. 重要な異常系シナリオ（エラー処理、不正入力など）をテストする\n3. すべての状態とすべての遷移が少なくとも1回はテストされるようにする（0-スイッチカバレッジ）\n4. リスクの高い遷移（例：支払い処理など）を重点的にテストする\n5. 「戻る」操作や「キャンセル」操作など、通常と異なるフローもテストする\n\nこのバランスの取れたアプローチにより、テスト工数を効率的に使いながら重要な問題を検出することができます。',
        difficulty: 'easy',
        points: 5
      }
    ],
    techniqueName: '状態遷移テスト',
    techniqueId: 'state-transition',
    categoryId: 'blackbox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '25分'
  },
  {
    id: 'ex-005',
    title: '命令網羅テストの演習',
    description: '命令網羅（Statement Coverage）テスト技法を使った実践演習です。',
    objective: 'この演習では、ソースコード内のすべての命令が少なくとも1回実行されるようなテストケースを設計する方法を学びます。',
    scenarioDescription: 
      'あなたはチームの品質保証エンジニアとして、以下の関数をテストする任務を与えられました：\n\n' +
      '```javascript\n' +
      'function calculateDiscount(amount, customerType, loyaltyYears) {\n' +
      '  let discount = 0;\n' +
      '  \n' +
      '  if (amount >= 1000) {\n' +
      '    discount = amount * 0.05; // 5%割引\n' +
      '  }\n' +
      '  \n' +
      '  if (customerType === "premium") {\n' +
      '    discount += amount * 0.1; // さらに10%割引\n' +
      '  } else if (customerType === "standard" && loyaltyYears > 2) {\n' +
      '    discount += amount * 0.05; // さらに5%割引\n' +
      '  }\n' +
      '  \n' +
      '  if (discount > amount * 0.2) {\n' +
      '    discount = amount * 0.2; // 最大割引は20%まで\n' +
      '  }\n' +
      '  \n' +
      '  return discount;\n' +
      '}\n' +
      '```\n\n' +
      'この関数に対して命令網羅（すべての命令を少なくとも1回実行する）を達成するテストケースを設計してください。',
    steps: [
      {
        stepNumber: 1,
        description: 'コードを分析し、実行可能なすべての命令（ステートメント）を特定する'
      },
      {
        stepNumber: 2,
        description: '各命令を少なくとも1回実行するテストケースを設計する'
      },
      {
        stepNumber: 3,
        description: 'テストケースが命令網羅を達成できているか確認する'
      },
      {
        stepNumber: 4,
        description: '必要に応じてテストケースを追加または最適化する'
      }
    ],
    quiz: [
      {
        id: 'q-005-1',
        questionText: '命令網羅（Statement Coverage）とは何ですか？',
        options: [
          {
            id: 'q-005-1-a',
            text: 'すべての条件分岐（true/false）を少なくとも1回テストすること',
            isCorrect: false,
            explanation: 'これは分岐網羅（Branch Coverage）の説明であり、命令網羅ではありません。'
          },
          {
            id: 'q-005-1-b',
            text: 'すべての命令（ステートメント）が少なくとも1回実行されるようにテストすること',
            isCorrect: true,
            explanation: '命令網羅とは、プログラム内のすべての命令（ステートメント）が少なくとも1回実行されるようにテストすることです。'
          },
          {
            id: 'q-005-1-c',
            text: 'すべての関数やメソッドが少なくとも1回呼び出されるようにテストすること',
            isCorrect: false,
            explanation: 'これは関数網羅（Function Coverage）の説明であり、命令網羅ではありません。'
          },
          {
            id: 'q-005-1-d',
            text: 'コード内のすべての可能なパスを少なくとも1回テストすること',
            isCorrect: false,
            explanation: 'これはパス網羅（Path Coverage）の説明であり、命令網羅ではありません。'
          }
        ],
        explanation: '命令網羅（Statement Coverage）とは、プログラム内のすべての命令（ステートメント）が少なくとも1回実行されるようにテストすることです。これはホワイトボックステストの最も基本的なカバレッジ基準の1つで、コードの各行が少なくとも1回実行されることを確認します。命令網羅は100%達成しても、すべてのバグが検出されるわけではありませんが、明らかに実行されない「デッドコード」を検出するのに役立ちます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-005-2',
        questionText: '上記のcalculateDiscount関数に対する命令網羅を達成するために最低限必要なテストケースの数はいくつですか？',
        options: [
          {
            id: 'q-005-2-a',
            text: '1つ',
            isCorrect: false,
            explanation: '1つのテストケースでは、すべての分岐を通ることができず、すべての命令を網羅できません。'
          },
          {
            id: 'q-005-2-b',
            text: '2つ',
            isCorrect: true,
            explanation: '適切に設計された2つのテストケースで、この関数のすべての命令を網羅することができます。'
          },
          {
            id: 'q-005-2-c',
            text: '3つ',
            isCorrect: false,
            explanation: '3つのテストケースも可能ですが、最低限必要なのは2つです。'
          },
          {
            id: 'q-005-2-d',
            text: '4つ',
            isCorrect: false,
            explanation: '4つのテストケースは必要以上であり、最低限必要なのは2つです。'
          }
        ],
        explanation: 'calculateDiscount関数の命令網羅を達成するには、最低限2つのテストケースが必要です。例えば：\n1. amount=2000, customerType="premium", loyaltyYears=0 → 最初のif文（amount >= 1000）と2番目のif文のpremiumの分岐、最後のif文（割引上限）の命令を実行\n2. amount=500, customerType="standard", loyaltyYears=3 → 最初のif文をスキップし、2番目のif文のstandard && loyaltyYears > 2の分岐、最後のif文をスキップする命令を実行\nこの2つのテストケースで、関数内のすべての命令が少なくとも1回実行されます。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-005-3',
        questionText: '以下のコードの命令網羅率を100%にするために必要なテストケースを選択してください：\n\n```javascript\nfunction processAge(age) {\n  if (age < 0) {\n    return "無効な年齢";\n  }\n  if (age < 20) {\n    return "未成年";\n  }\n  return "成人";\n}\n```',
        options: [
          {
            id: 'q-005-3-a',
            text: 'age = 30 のみをテスト',
            isCorrect: false,
            explanation: 'このテストケースでは「age < 0」と「age < 20」の条件がどちらもfalseになるため、2つのif文の中の命令は実行されません。'
          },
          {
            id: 'q-005-3-b',
            text: 'age = -5 と age = 30 をテスト',
            isCorrect: false,
            explanation: 'これらのテストケースでは「age < 20」の条件がtrueになる場合が含まれていないため、2番目のif文の中の命令が実行されません。'
          },
          {
            id: 'q-005-3-c',
            text: 'age = 15 と age = 30 をテスト',
            isCorrect: false,
            explanation: 'これらのテストケースでは「age < 0」の条件がtrueになる場合が含まれていないため、最初のif文の中の命令が実行されません。'
          },
          {
            id: 'q-005-3-d',
            text: 'age = -5, age = 15, age = 30 をテスト',
            isCorrect: true,
            explanation: 'これらのテストケースでは、すべての条件分岐と命令が少なくとも1回実行されます。'
          }
        ],
        explanation: 'processAge関数の命令網羅率を100%にするには、以下の3つのパスをすべてテストする必要があります：\n1. age < 0 の場合（例：age = -5）→ "無効な年齢"を返す\n2. age >= 0 かつ age < 20 の場合（例：age = 15）→ "未成年"を返す\n3. age >= 20 の場合（例：age = 30）→ "成人"を返す\nこれら3つのテストケースで、関数内のすべての命令が少なくとも1回実行されます。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-005-4',
        questionText: '命令網羅テストの限界は何ですか？',
        options: [
          {
            id: 'q-005-4-a',
            text: '実行速度が非常に遅く、大規模なアプリケーションでは使用できない',
            isCorrect: false,
            explanation: '命令網羅テスト自体が特別に遅いわけではなく、テストの実行速度はテスト対象のコードとテスト方法によります。'
          },
          {
            id: 'q-005-4-b',
            text: '特殊なツールが必要で、一般的なテスト環境では実施できない',
            isCorrect: false,
            explanation: '命令網羅テストは一般的なテスト環境でも実施でき、多くのテストカバレッジツールでサポートされています。'
          },
          {
            id: 'q-005-4-c',
            text: '条件の組み合わせによるバグを検出できない場合がある',
            isCorrect: true,
            explanation: '命令網羅テストは各命令が実行されることを確認するだけで、条件の組み合わせによるバグを検出できない場合があります。'
          },
          {
            id: 'q-005-4-d',
            text: 'レガシーコードには適用できない',
            isCorrect: false,
            explanation: '命令網羅テストはレガシーコードを含む任意のコードに適用できます。'
          }
        ],
        explanation: '命令網羅テストの主な限界は、すべての命令が実行されていることを確認するだけで、条件の組み合わせや実行パスによるバグを検出できない場合があることです。例えば、以下のようなコードでは：\n```javascript\nif (a && b) {\n  doSomething();\n}\n```\na=true, b=falseのテストケースでdoSomething()が実行されなくても、命令網羅率は高くなります。しかし、a=true, b=trueのケースでバグが発生する可能性があります。このような条件の組み合わせによるバグを検出するには、分岐網羅や条件網羅などのより高度なカバレッジ基準が必要です。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-005-5',
        questionText: '以下のコードで命令網羅を達成するテストケースはどれですか？\n\n```javascript\nfunction getGrade(score) {\n  if (score < 0 || score > 100) {\n    return "無効な点数";\n  }\n  \n  if (score >= 90) {\n    return "A";\n  } else if (score >= 80) {\n    return "B";\n  } else if (score >= 70) {\n    return "C";\n  } else if (score >= 60) {\n    return "D";\n  } else {\n    return "F";\n  }\n}\n```',
        options: [
          {
            id: 'q-005-5-a',
            text: 'score = -10, score = 95, score = 85, score = 75, score = 65, score = 55',
            isCorrect: true,
            explanation: 'これらのテストケースでは、無効な点数、A、B、C、D、Fのすべての分岐が実行され、すべての命令が網羅されます。'
          },
          {
            id: 'q-005-5-b',
            text: 'score = 95, score = 85, score = 75, score = 65, score = 55',
            isCorrect: false,
            explanation: 'これらのテストケースでは、無効な点数の分岐が実行されないため、すべての命令が網羅されません。'
          },
          {
            id: 'q-005-5-c',
            text: 'score = -10, score = 110, score = 90, score = 80, score = 70, score = 60',
            isCorrect: false,
            explanation: 'これらのテストケースでは、score = 60のケースでは「D」を返す分岐が実行されますが、「F」を返す分岐が実行されないため、すべての命令が網羅されません。'
          },
          {
            id: 'q-005-5-d',
            text: 'score = 0, score = 100',
            isCorrect: false,
            explanation: 'これらのテストケースでは、score = 0は「F」を返し、score = 100は「A」を返しますが、「B」「C」「D」を返す分岐や無効な点数の分岐が実行されないため、すべての命令が網羅されません。'
          }
        ],
        explanation: 'getGrade関数の命令網羅を達成するには、以下のすべての分岐を実行する必要があります：\n1. 無効な点数のケース（例：score = -10）\n2. A評価のケース（例：score = 95）\n3. B評価のケース（例：score = 85）\n4. C評価のケース（例：score = 75）\n5. D評価のケース（例：score = 65）\n6. F評価のケース（例：score = 55）\nこれらの6つのテストケースで、関数内のすべての命令が少なくとも1回実行されます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-005-6',
        questionText: '命令網羅テストの計測方法として正しいのはどれですか？',
        options: [
          {
            id: 'q-005-6-a',
            text: '実行された命令数 ÷ ソースコードの総行数 × 100',
            isCorrect: false,
            explanation: 'ソースコードの総行数にはコメントや空行も含まれるため、これは正確な命令網羅率の計算方法ではありません。'
          },
          {
            id: 'q-005-6-b',
            text: '実行された命令数 ÷ 実行可能な命令の総数 × 100',
            isCorrect: true,
            explanation: 'これが命令網羅率の正確な計算方法です。実行された命令数を実行可能な命令の総数で割り、100を掛けて百分率で表します。'
          },
          {
            id: 'q-005-6-c',
            text: 'テストケースの数 ÷ プログラム内の条件分岐の数 × 100',
            isCorrect: false,
            explanation: 'これは命令網羅率の計算方法ではなく、テストケースと条件分岐の比率を表しています。'
          },
          {
            id: 'q-005-6-d',
            text: '発見されたバグの数 ÷ テストケースの数 × 100',
            isCorrect: false,
            explanation: 'これはバグ検出効率を表す指標であり、命令網羅率の計算方法ではありません。'
          }
        ],
        explanation: '命令網羅率（Statement Coverage）は、以下の式で計算されます：\n\n命令網羅率(%) = (実行された命令数 ÷ 実行可能な命令の総数) × 100\n\n例えば、プログラムに100の実行可能な命令があり、テスト実行中に80の命令が実行された場合、命令網羅率は80%です。この測定にはカバレッジツール（JaCoCoやIstanbulなど）が使用されます。これらのツールは、実行されたコードを追跡し、どの命令が実行されたかを報告します。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-005-7',
        questionText: '命令網羅を100%達成した場合、以下のうち正しい説明はどれですか？',
        options: [
          {
            id: 'q-005-7-a',
            text: 'プログラム内のすべてのバグが検出される',
            isCorrect: false,
            explanation: '命令網羅が100%でも、条件の組み合わせや特定の実行パスに関連するバグは検出されない可能性があります。'
          },
          {
            id: 'q-005-7-b',
            text: 'コード内の各命令が少なくとも1回実行されている',
            isCorrect: true,
            explanation: '命令網羅が100%とは、まさにコード内の各命令が少なくとも1回実行されていることを意味します。'
          },
          {
            id: 'q-005-7-c',
            text: 'すべての条件分岐（true/false）が網羅されている',
            isCorrect: false,
            explanation: '命令網羅が100%でも、すべての条件分岐が網羅されているとは限りません。これは分岐網羅に関する説明です。'
          },
          {
            id: 'q-005-7-d',
            text: 'プログラムの品質が完璧であることが保証される',
            isCorrect: false,
            explanation: '命令網羅は基本的なコードカバレッジ指標の1つにすぎず、プログラムの品質を完全に保証するものではありません。'
          }
        ],
        explanation: '命令網羅を100%達成したということは、プログラム内のすべての実行可能な命令が少なくとも1回実行されたことを意味します。これはコードの基本的な実行可能性を確認する重要な指標ですが、以下の理由から、すべてのバグが検出されるわけではありません：\n\n1. 複雑な条件の組み合わせによるバグは検出されない可能性がある\n2. 並行処理の問題（競合状態など）は検出されない\n3. 特定のデータ値や境界条件に関連するバグは見逃される可能性がある\n4. 命令が実行されても、その結果が正しいかどうかは命令網羅テストでは検証されない\n\n命令網羅は基本的なテスト網羅基準であり、他のテスト技法と組み合わせて使用することが重要です。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-005-8',
        questionText: '以下のコードに対する命令網羅テストで見逃す可能性が高いバグはどれですか？\n\n```javascript\nfunction divideNumbers(a, b) {\n  if (b !== 0) {\n    return a / b;\n  } else {\n    return "エラー: ゼロでの除算";\n  }\n}\n```',
        options: [
          {
            id: 'q-005-8-a',
            text: 'b = 0の場合のゼロ除算エラー',
            isCorrect: false,
            explanation: 'このコードではb = 0の場合は明示的に処理されており、命令網羅テストでカバーされます。'
          },
          {
            id: 'q-005-8-b',
            text: 'a = 0の場合の戻り値が0になるケース',
            isCorrect: false,
            explanation: 'a = 0の場合は数学的に正しく0を返すはずであり、これはバグではありません。'
          },
          {
            id: 'q-005-8-c',
            text: 'b = null または undefined の場合の不適切な結果',
            isCorrect: true,
            explanation: 'b = null または undefined の場合、「b !== 0」は true になりますが、その後の除算でエラーが発生する可能性があります。命令網羅テストでは通常このようなケースはテストされません。'
          },
          {
            id: 'q-005-8-d',
            text: 'a と b が両方とも0の場合のエラー',
            isCorrect: false,
            explanation: 'a = 0, b = 0の場合は「b !== 0」の条件で false となり、"エラー: ゼロでの除算"が返されます。これは適切な処理であり、命令網羅テストでカバーされます。'
          }
        ],
        explanation: '命令網羅テストは、各命令が少なくとも1回実行されることを確認するだけで、すべての入力値や特殊なケースをテストするわけではありません。この例では、以下の2つのテストケースで命令網羅を達成できます：\n1. a = 10, b = 2 → 「b !== 0」が true で、a / b = 5 を返す\n2. a = 10, b = 0 → 「b !== 0」が false で、"エラー: ゼロでの除算" を返す\n\nしかし、b = null または undefined などの特殊なケースはテストされない可能性があります。JavaScript では「null !== 0」と「undefined !== 0」は true になるため、条件分岐は通過しますが、その後の「a / null」や「a / undefined」は「NaN」を返します。これはバグとなる可能性がありますが、命令網羅テストだけでは見逃される可能性が高いです。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-005-9',
        questionText: '命令網羅と分岐網羅の違いを最もよく説明しているのはどれですか？',
        options: [
          {
            id: 'q-005-9-a',
            text: '命令網羅はすべての命令が実行されることを確認し、分岐網羅はすべての条件分岐（true/false）が実行されることを確認する',
            isCorrect: true,
            explanation: 'これが命令網羅と分岐網羅の主な違いです。分岐網羅は条件式のすべての結果（trueとfalse）を網羅するのに対し、命令網羅は各命令が少なくとも1回実行されることを確認します。'
          },
          {
            id: 'q-005-9-b',
            text: '命令網羅はホワイトボックステスト技法で、分岐網羅はブラックボックステスト技法である',
            isCorrect: false,
            explanation: '両方ともホワイトボックステスト技法であり、コードの内部構造に基づいています。'
          },
          {
            id: 'q-005-9-c',
            text: '命令網羅はユニットテストで使用され、分岐網羅は統合テストで使用される',
            isCorrect: false,
            explanation: '両方ともさまざまなレベルのテスト（ユニットテスト、統合テストなど）で使用できます。'
          },
          {
            id: 'q-005-9-d',
            text: '命令網羅は自動テストで使用され、分岐網羅は手動テストで使用される',
            isCorrect: false,
            explanation: '両方とも自動テストと手動テストの両方で使用できます。'
          }
        ],
        explanation: '命令網羅と分岐網羅の主な違いは以下の通りです：\n\n- 命令網羅（Statement Coverage）：プログラム内のすべての命令（ステートメント）が少なくとも1回実行されることを確認します。\n\n- 分岐網羅（Branch Coverage）：すべての条件分岐（if、switch、for文などの制御構造の各分岐）が少なくとも1回実行されることを確認します。これは条件式の結果がtrue/falseの両方のケースを含みます。\n\n例えば、以下のコードでは：\n```javascript\nif (a > b) {\n  return a;\n} else {\n  return b;\n}\n```\n\n命令網羅を100%達成するには、if文が実行され、どちらかの分岐が実行されれば十分です。しかし、分岐網羅を100%達成するには、a > b が true と false の両方のケースをテストする必要があります。分岐網羅は通常、命令網羅よりも厳格なカバレッジ基準です。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-005-10',
        questionText: 'テストで命令網羅を考慮すべき主な理由は何ですか？',
        options: [
          {
            id: 'q-005-10-a',
            text: 'テストケースを削減し、テスト工数を最小化するため',
            isCorrect: false,
            explanation: '命令網羅は通常テストケースを増やす効果があり、工数を最小化するためのものではありません。'
          },
          {
            id: 'q-005-10-b',
            text: 'バグを100%検出するため',
            isCorrect: false,
            explanation: '命令網羅はバグを100%検出することを保証するものではありません。'
          },
          {
            id: 'q-005-10-c',
            text: '使用されていないコード（デッドコード）を検出するため',
            isCorrect: true,
            explanation: '命令網羅を測定することで、テストによって実行されていないコード（デッドコードや到達不能コード）を特定できます。'
          },
          {
            id: 'q-005-10-d',
            text: 'コードの実行時間を測定するため',
            isCorrect: false,
            explanation: '命令網羅はコードの実行時間を測定するためのものではありません。'
          }
        ],
        explanation: '命令網羅を考慮する主な理由の1つは、使用されていないコード（デッドコード）や到達不能なコードを検出するためです。命令網羅率が低い場合、それはテストによって実行されていないコードが存在することを示します。これは以下のような理由で問題となる可能性があります：\n\n1. テストされていないコードにバグが潜んでいる可能性がある\n2. 実際には必要のないコードがプログラムに含まれている（コード肥大化）\n3. 条件分岐に論理エラーがあり、特定のコードに到達できない\n\n命令網羅は基本的なコードカバレッジ指標であり、他のテスト技法と組み合わせることで、より包括的なテスト戦略を構築できます。',
        difficulty: 'easy',
        points: 5
      }
    ],
    techniqueName: '命令網羅',
    techniqueId: 'statement-coverage',
    categoryId: 'whitebox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '25分'
  }
];

// バッジ定義
export const badges: BadgeDefinition[] = [
  {
    id: 'badge-technique-001',
    name: '同値分割マスター',
    description: '同値分割法の演習を高得点で完了しました。効率的なテストケース設計のスキルを証明します。',
    imageUrl: '/badges/equivalence-partitioning.svg',
    type: 'technique',
    relatedId: 'equivalence-partitioning',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-001']
    }
  },
  {
    id: 'badge-technique-002',
    name: '境界値の守護者',
    description: '境界値分析の演習を高得点で完了しました。エッジケースを見つける鋭い目を持っています。',
    imageUrl: '/badges/boundary-value.svg',
    type: 'technique',
    relatedId: 'boundary-value-analysis',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-002']
    }
  },
  {
    id: 'badge-technique-003',
    name: '決定表マスター',
    description: '決定表テストの演習を高得点で完了しました。複雑な条件のロジックを正確に分析できます。',
    imageUrl: '/badges/black-box.svg',
    type: 'technique',
    relatedId: 'decision-table',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-003']
    }
  },
  {
    id: 'badge-technique-004',
    name: '状態遷移の達人',
    description: '状態遷移テストの演習を高得点で完了しました。システムの状態と遷移を理解し、効果的にテストできます。',
    imageUrl: '/badges/black-box.svg',
    type: 'technique',
    relatedId: 'state-transition',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-004']
    }
  },
  {
    id: 'badge-technique-005',
    name: '命令網羅マスター',
    description: '命令網羅テストの演習を高得点で完了しました。ソースコードの実行網羅性を効果的に検証できます。',
    imageUrl: '/badges/black-box.svg',
    type: 'technique',
    relatedId: 'statement-coverage',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-005']
    }
  },
  {
    id: 'badge-category-001',
    name: 'ブラックボックステストの達人',
    description: 'ブラックボックステストカテゴリのすべての演習を完了しました。入力と出力の関係を分析する専門家です。',
    imageUrl: '/badges/black-box.svg',
    type: 'category',
    relatedId: 'blackbox',
    requirement: {
      type: 'category_mastery',
      threshold: 0.7 // 70%以上の平均スコア
    }
  },
  {
    id: 'badge-category-002',
    name: 'ホワイトボックステストの達人',
    description: 'ホワイトボックステストカテゴリのすべての演習を完了しました。コードの内部構造を解析する専門家です。',
    imageUrl: '/badges/black-box.svg', // 後で適切なアイコンに変更予定
    type: 'category',
    relatedId: 'whitebox',
    requirement: {
      type: 'category_mastery',
      threshold: 0.7 // 70%以上の平均スコア
    }
  },
  {
    id: 'badge-achievement-all',
    name: 'テストマエストロ',
    description: 'すべてのテスト技法を習得しました。あなたはソフトウェアテストの真のマエストロです！',
    imageUrl: '/badges/test-maestro.svg',
    type: 'achievement',
    requirement: {
      type: 'all_techniques'
    }
  }
];