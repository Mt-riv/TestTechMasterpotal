import { PracticalExercise, BadgeDefinition } from '../types/exercise';

// サンプル演習データ
export const exercises: PracticalExercise[] = [
  {
    id: 'ex-003',
    title: 'クラシフィケーションツリーの演習',
    description: 'クラシフィケーションツリー（Classification Tree）テスト技法を使った実践演習です。',
    objective: 'この演習では、テスト対象の特性を階層的なツリー構造で分類し、その組み合わせからテストケースを効率的に生成する方法を学びます。',
    scenarioDescription: 
      'あなたはオンラインショッピングサイトの開発チームに所属しています。顧客の属性や注文内容に応じて割引率が変わるシステムをテストする必要があります。\n\n' +
      'クラシフィケーションツリー法を用いて、効率的かつ体系的にテストケースを設計しましょう。',
    steps: [
      {
        stepNumber: 1,
        description: 'テスト対象の主要な特性（会員種別、購入金額、商品カテゴリー、クーポン利用など）を特定する'
      },
      {
        stepNumber: 2,
        description: '各特性のサブクラスを識別し、ツリー構造を設計する'
      },
      {
        stepNumber: 3,
        description: 'ツリーの各レベルからサブクラスを1つずつ選択し、テストケースを生成する'
      },
      {
        stepNumber: 4,
        description: '生成したテストケースの有効性と網羅性を評価する'
      }
    ],
    quiz: [
      {
        id: 'q-003-1',
        questionText: 'クラシフィケーションツリー法の最初のステップとして最も適切なものはどれですか？',
        options: [
          {
            id: 'q-003-1-a',
            text: '境界値を特定する',
            isCorrect: false,
            explanation: '境界値の特定は境界値分析の手法であり、クラシフィケーションツリー法の最初のステップではありません。'
          },
          {
            id: 'q-003-1-b',
            text: 'テスト対象の特性を特定する',
            isCorrect: true,
            explanation: 'クラシフィケーションツリー法では、まずテスト対象システムの主要な特性（入力パラメータ、条件、環境変数など）を特定することが最初のステップです。'
          },
          {
            id: 'q-003-1-c',
            text: 'テストケースを実行する',
            isCorrect: false,
            explanation: 'テストケースの実行はクラシフィケーションツリーの作成とテストケース設計の後のステップです。'
          },
          {
            id: 'q-003-1-d',
            text: '同値パーティションを特定する',
            isCorrect: false,
            explanation: '同値パーティションの特定は同値分割法のステップであり、クラシフィケーションツリー法とは異なります。クラシフィケーションツリー法では特性とそのサブクラスを特定します。'
          }
        ],
        explanation: 'クラシフィケーションツリー法の最初のステップは、テスト対象の主要な特性を特定することです。特性とは、システムの動作に影響を与える入力パラメータ、条件、環境変数などを指します。特性を特定した後、各特性のサブクラスを識別し、階層的なツリー構造を設計します。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-003-2',
        questionText: 'クラシフィケーションツリー法を使用する主な利点は何ですか？',
        options: [
          {
            id: 'q-003-2-a',
            text: 'すべての入力値の組み合わせを網羅的にテストできる',
            isCorrect: false,
            explanation: 'クラシフィケーションツリー法でもすべての組み合わせをテストするのは現実的ではなく、効率的な選択が必要です。'
          },
          {
            id: 'q-003-2-b',
            text: 'テスト条件を視覚的に表現し、体系的なテストケース設計ができる',
            isCorrect: true,
            explanation: 'クラシフィケーションツリー法の主な利点は、テスト条件を視覚的なツリー構造で表現でき、それに基づいて体系的にテストケースを設計できることです。'
          },
          {
            id: 'q-003-2-c',
            text: 'コードの複雑度を自動的に分析できる',
            isCorrect: false,
            explanation: 'クラシフィケーションツリー法はブラックボックステスト技法であり、コードの複雑度を分析するものではありません。'
          },
          {
            id: 'q-003-2-d',
            text: '境界値のみに焦点を当てたテストができる',
            isCorrect: false,
            explanation: '境界値に焦点を当てるのは境界値分析の特徴であり、クラシフィケーションツリー法の主な特徴ではありません。'
          }
        ],
        explanation: 'クラシフィケーションツリー法の主な利点は、テスト条件を階層的なツリー構造で視覚的に表現でき、それに基づいて体系的にテストケースを設計できることです。これにより、テスト条件の整理がしやすくなり、テストの網羅性や効率性が向上します。また、視覚的な表現によりステークホルダー間のコミュニケーションも円滑になります。',
        difficulty: 'easy',
        points: 5
      },
  
      {
        id: 'q-003-3',
        questionText: 'オンラインショッピングシステムにおいて、以下の特性のうちクラシフィケーションツリーのルートノードとして最も適切なものはどれですか？',
        options: [
          {
            id: 'q-003-3-a',
            text: '「特別会員」というサブクラス',
            isCorrect: false,
            explanation: '「特別会員」はサブクラスであり、「会員種別」などの特性の下に位置するべきものです。ルートノードにはもっと広い概念が必要です。'
          },
          {
            id: 'q-003-3-b',
            text: '「オンラインショッピングシステム」自体',
            isCorrect: true,
            explanation: 'クラシフィケーションツリーでは、テスト対象システム全体がルートノードとなり、その下に主要な特性がぶら下がる形になります。'
          },
          {
            id: 'q-003-3-c',
            text: '「割引計算」というテスト対象の一部機能',
            isCorrect: false,
            explanation: '「割引計算」はシステムの一機能であり、テスト対象を限定する場合はルートノードになり得ますが、システム全体のテストを考える場合はより広い概念がルートノードとなります。'
          },
          {
            id: 'q-003-3-d',
            text: '「5%割引」という具体的な値',
            isCorrect: false,
            explanation: '「5%割引」は具体的な値であり、特性のサブクラスの結果として生じるものです。ルートノードには含めません。'
          }
        ],
        explanation: 'クラシフィケーションツリーでは、ルートノードにはテスト対象システム全体または主要な機能を配置します。その下に、テストに影響を与える主要な特性（会員種別、購入金額など）を配置し、さらにその下に各特性のサブクラスを配置していく階層構造になります。',
        difficulty: 'medium',
        points: 10
      },
      
      {
        id: 'q-003-4',
        questionText: 'クラシフィケーションツリー法でテストケースを生成する際、正しいアプローチはどれですか？',
        options: [
          {
            id: 'q-003-4-a',
            text: 'ツリーの各レベルからサブクラスを1つずつ選択し、組み合わせる',
            isCorrect: true,
            explanation: 'クラシフィケーションツリー法では、ツリーの各レベル（各特性）からサブクラスを1つずつ選択し、その組み合わせでテストケースを生成します。'
          },
          {
            id: 'q-003-4-b',
            text: 'ツリーの最上位レベルのサブクラスのみをテストする',
            isCorrect: false,
            explanation: '最上位レベルのサブクラスのみをテストするのでは不十分です。各レベルからサブクラスを組み合わせてテストケースを生成する必要があります。'
          },
          {
            id: 'q-003-4-c',
            text: 'ツリーの最下位レベルのサブクラスのみをテストする',
            isCorrect: false,
            explanation: '最下位レベルのサブクラスのみをテストするのでは不十分です。各レベルからサブクラスを組み合わせる必要があります。'
          },
          {
            id: 'q-003-4-d',
            text: '無作為にサブクラスを選択してテストする',
            isCorrect: false,
            explanation: '無作為な選択では体系的なテストにはなりません。各特性からサブクラスを計画的に選択し、組み合わせる必要があります。'
          }
        ],
        explanation: 'クラシフィケーションツリー法でテストケースを生成する際は、ツリーの各レベル（各特性）からサブクラスを1つずつ選択し、その組み合わせでテストケースを生成します。例えば、「会員種別」から「一般会員」、「購入金額」から「5,000円未満」、「商品カテゴリー」から「通常商品」といった具合に選択していきます。',
        difficulty: 'medium',
        points: 10
      },
      
      {
        id: 'q-003-5',
        questionText: 'ユーザー登録システムのクラシフィケーションツリーを設計しています。以下の特性とサブクラスの組み合わせとして最も適切なものはどれですか？',
        options: [
          {
            id: 'q-003-5-a',
            text: '特性「年齢」：サブクラス「若い」「普通」「高い」',
            isCorrect: false,
            explanation: 'サブクラスが曖昧で定量的でないため、テストに適していません。年齢の場合は明確な範囲で区切るべきです。'
          },
          {
            id: 'q-003-5-b',
            text: '特性「性別」：サブクラス「男性」「女性」「その他・無回答」',
            isCorrect: true,
            explanation: 'この分類は明確で漏れがなく、重複もありません。ユーザー登録システムでよく使われる分類方法です。'
          },
          {
            id: 'q-003-5-c',
            text: '特性「住所」：サブクラス「東京」「大阪」「その他」',
            isCorrect: false,
            explanation: 'この分類は不完全です。「その他」が大多数を占め、不均衡な分類になっています。地域別にもっと均等に分けるか、別の分類方法を検討すべきです。'
          },
          {
            id: 'q-003-5-d',
            text: '特性「利用頻度」：サブクラス「よく使う」「たまに使う」',
            isCorrect: false,
            explanation: 'サブクラスが曖昧で定量的でなく、網羅的でもありません。利用頻度は具体的な回数や期間で分類すべきです。'
          }
        ],
        explanation: 'クラシフィケーションツリーのサブクラスは、明確で定量的、かつ漏れなく重複なく分類されることが理想的です。「性別」の分類は明確で網羅的であり、ユーザー登録システムでよく使われる分類方法です。他の選択肢は曖昧さがあったり、不均衡だったりするため、適切なテスト設計には向いていません。',
        difficulty: 'medium',
        points: 10
      },
      
      {
        id: 'q-003-6',
        questionText: 'クラシフィケーションツリー法を使用する際の課題として最も当てはまるものはどれですか？',
        options: [
          {
            id: 'q-003-6-a',
            text: 'サブクラスの組み合わせが多すぎると、全ての組み合わせをテストするのが困難になる',
            isCorrect: true,
            explanation: 'これはクラシフィケーションツリー法の主な課題です。特性やサブクラスの数が増えると、組み合わせの数は指数関数的に増加するため、全ての組み合わせをテストするのは現実的でなくなります。'
          },
          {
            id: 'q-003-6-b',
            text: 'ツリー構造の作成に専門的なツールが必須である',
            isCorrect: false,
            explanation: 'ツリー構造は手書きやオフィスソフトでも作成可能で、専門的なツールは必須ではありません。ただし、複雑なツリーの場合は専用ツールがあると便利です。'
          },
          {
            id: 'q-003-6-c',
            text: 'ホワイトボックステストには適用できない',
            isCorrect: false,
            explanation: 'クラシフィケーションツリー法は主にブラックボックステストで使用されますが、コードの構造に関する特性を考慮することで、ホワイトボックステストにも応用できます。'
          },
          {
            id: 'q-003-6-d',
            text: '自動テストには使用できない',
            isCorrect: false,
            explanation: 'クラシフィケーションツリー法で設計したテストケースは自動テストにも使用できます。むしろ、構造化されているため自動テストとの親和性が高いと言えます。'
          }
        ],
        explanation: 'クラシフィケーションツリー法の主な課題は、特性やサブクラスの数が増えると組み合わせの数が爆発的に増加し、全ての組み合わせをテストするのが現実的でなくなることです。例えば、3つの特性があり、各特性に3つのサブクラスがある場合、可能な組み合わせは3×3×3=27通りになります。この問題に対処するために、ペアワイズテストなどの組み合わせテスト技法を併用して、テストケース数を削減することがあります。',
        difficulty: 'hard',
        points: 15
      },
      
      {
        id: 'q-003-7',
        questionText: 'モバイルアプリのクラシフィケーションツリーを設計しています。以下の中で、最も適切な特性の組み合わせはどれですか？',
        options: [
          {
            id: 'q-003-7-a',
            text: '「OSタイプ」「画面サイズ」「ネットワーク接続」「バッテリー残量」',
            isCorrect: true,
            explanation: 'これらはモバイルアプリのテストに重要な特性であり、各特性は互いに独立しています。OSタイプ、画面サイズ、ネットワーク状態、バッテリー残量はそれぞれアプリの動作に影響を与える重要な要素です。'
          },
          {
            id: 'q-003-7-b',
            text: '「OSタイプ」「OS名」「OSバージョン」「アプリバージョン」',
            isCorrect: false,
            explanation: 'OSタイプ、OS名、OSバージョンは互いに依存関係がある特性です。クラシフィケーションツリーでは、特性は可能な限り独立している方が望ましいです。'
          },
          {
            id: 'q-003-7-c',
            text: '「画面サイズ」「画面解像度」「画面の明るさ」「画面の向き」',
            isCorrect: false,
            explanation: 'これらの特性は互いに関連が強く、かつモバイルアプリのテストとしては画面に関する特性に偏りすぎています。より多様な観点からテストすべきです。'
          },
          {
            id: 'q-003-7-d',
            text: '「ユーザーの年齢」「ユーザーの性別」「ユーザーの職業」「使用場所」',
            isCorrect: false,
            explanation: 'これらはユーザー属性に関する特性であり、技術的な特性が含まれていません。モバイルアプリのテストには技術的な特性も含めるべきです。'
          }
        ],
        explanation: 'クラシフィケーションツリーを設計する際は、テスト対象に影響を与える重要な特性を選び、それらが可能な限り互いに独立していることが望ましいです。モバイルアプリのテストでは、OSタイプ、画面サイズ、ネットワーク接続、バッテリー残量など、技術的に異なる観点から影響を与える特性を選ぶのが適切です。これにより、アプリのさまざまな側面を効果的にテストできます。',
        difficulty: 'hard',
        points: 15
      },
      
      {
        id: 'q-003-8',
        questionText: 'クラシフィケーションツリー法とペアワイズテスト法を組み合わせる主な目的は何ですか？',
        options: [
          {
            id: 'q-003-8-a',
            text: 'テストケースの数を増やして網羅性を高めるため',
            isCorrect: false,
            explanation: '組み合わせるとテストケース数はむしろ削減されます。目的は効率性の向上です。'
          },
          {
            id: 'q-003-8-b',
            text: 'ツリー構造を簡略化するため',
            isCorrect: false,
            explanation: 'ペアワイズテスト法はツリー構造自体を簡略化するものではなく、生成するテストケースの数を効率化するものです。'
          },
          {
            id: 'q-003-8-c',
            text: 'テストケース数を効率的に削減しながら、2因子の組み合わせをカバーするため',
            isCorrect: true,
            explanation: 'これが正解です。ペアワイズテスト法を組み合わせることで、全ての組み合わせをテストする代わりに、すべての2因子の組み合わせをカバーするように効率的にテストケースを削減できます。'
          },
          {
            id: 'q-003-8-d',
            text: 'サブクラスを自動的に生成するため',
            isCorrect: false,
            explanation: 'ペアワイズテスト法はサブクラスを生成するものではなく、既存のサブクラスの組み合わせからテストケースを効率的に選択するものです。'
          }
        ],
        explanation: 'クラシフィケーションツリー法では、特性やサブクラスの数が多いと、可能な組み合わせが膨大になり、全てをテストするのは現実的ではありません。ペアワイズテスト法を組み合わせることで、全ての可能な組み合わせをテストする代わりに、すべての2つの因子（特性のサブクラス）の組み合わせを少なくとも一度はカバーするようにテストケースを効率的に削減できます。これにより、テスト工数を大幅に削減しながらも、高い不具合検出効率を維持できます。',
        difficulty: 'hard',
        points: 15
      },
      
      {
        id: 'q-003-9',
        questionText: '以下のクラシフィケーションツリーがあります：\n特性A（サブクラス：A1, A2）\n特性B（サブクラス：B1, B2, B3）\n特性C（サブクラス：C1, C2）\n\n全ての組み合わせをテストする場合、必要なテストケース数は何個ですか？',
        options: [
          {
            id: 'q-003-9-a',
            text: '7個',
            isCorrect: false,
            explanation: '7は特性の数（3）とサブクラスの数（2+3+2）の合計ですが、これはテストケース数ではありません。'
          },
          {
            id: 'q-003-9-b',
            text: '12個',
            isCorrect: true,
            explanation: '全ての組み合わせをテストするには、各特性のサブクラス数を掛け合わせた数のテストケースが必要です。2(A) × 3(B) × 2(C) = 12個のテストケースが必要です。'
          },
          {
            id: 'q-003-9-c',
            text: '6個',
            isCorrect: false,
            explanation: '6はペアワイズテストなど、効率化手法を用いた場合の概算値かもしれませんが、全ての組み合わせをテストする場合の正確な数ではありません。'
          },
          {
            id: 'q-003-9-d',
            text: '3個',
            isCorrect: false,
            explanation: '3は特性の数に過ぎず、テストケース数ではありません。'
          }
        ],
        explanation: 'クラシフィケーションツリー法で全ての組み合わせをテストする場合、各特性のサブクラス数を掛け合わせた数のテストケースが必要になります。この例では、特性Aに2つのサブクラス、特性Bに3つのサブクラス、特性Cに2つのサブクラスがあるため、2 × 3 × 2 = 12個のテストケースが必要です。特性やサブクラスの数が増えると、テストケース数は指数関数的に増加するため、実際のプロジェクトでは効率化手法を用いることが多いです。',
        difficulty: 'medium',
        points: 10
      },
      
      {
        id: 'q-003-10',
        questionText: 'あるWebサイトのログイン機能のクラシフィケーションツリーを設計しています。以下の設計のうち、最も効果的なものはどれですか？',
        options: [
          {
            id: 'q-003-10-a',
            text: 'ルートノード「ログイン機能」の下に特性「ユーザータイプ」「入力方法」「ブラウザ」を配置',
            isCorrect: true,
            explanation: 'この設計は、ログイン機能に影響を与える主要な特性を適切に識別しています。ユーザータイプ、入力方法、ブラウザは互いに独立した特性であり、ログイン機能のテストに重要な観点を提供します。'
          },
          {
            id: 'q-003-10-b',
            text: 'ルートノード「ログイン機能」の下に特性「成功」「失敗」を配置',
            isCorrect: false,
            explanation: '「成功」「失敗」は特性ではなく、テスト結果や期待値に相当します。クラシフィケーションツリーの特性には、入力条件や環境条件などを設定すべきです。'
          },
          {
            id: 'q-003-10-c',
            text: 'ルートノード「ログイン機能」の下に特性「ユーザー名」「パスワード」を配置',
            isCorrect: false,
            explanation: 'ユーザー名とパスワードは入力項目ですが、特性としては抽象度が低すぎます。より高い抽象度の特性（例：「認証方法」「ユーザータイプ」など）を設定した方が効果的です。'
          },
          {
            id: 'q-003-10-d',
            text: 'ルートノード「ログイン機能」の下に特性「ログイン成功率」「平均ログイン時間」を配置',
            isCorrect: false,
            explanation: 'これらは測定指標であり、クラシフィケーションツリーの特性としては適切ではありません。特性には、テストの入力条件や環境条件を設定します。'
          }
        ],
        explanation: 'クラシフィケーションツリーを効果的に設計するには、テスト対象（この場合はログイン機能）に影響を与える重要な特性を適切に識別することが重要です。理想的な特性は、互いに独立しており、テストの観点を広げるものであるべきです。「ユーザータイプ」（例：一般ユーザー、管理者）、「入力方法」（例：手動入力、自動入力）、「ブラウザ」（例：Chrome、Firefox）は、ログイン機能のテストに重要な独立した観点を提供します。これらの特性のサブクラスを組み合わせることで、効果的なテストケースを生成できます。',
        difficulty: 'medium',
        points: 10
      }
    ],
    techniqueName: 'クラシフィケーションツリー法',
    techniqueId: 'classification-tree',
    categoryId: 'blackbox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '25分'
  },
  {
    id: 'ex-001',
    title: '同値分割テストの演習',
    description: '同値分割（Equivalence Partitioning）テスト技法を使った実践演習です。',
    objective: 'この演習では、入力範囲を有効なクラスと無効なクラスに分割し、効率的なテストケースを設計する方法を学びます。',
    scenarioDescription: 
      'あなたは銀行の口座管理システムの開発チームに所属しています。システムには入金機能があり、1回の入金額は1円から100万円までという制約があります。\n\n' +
      'この機能に対して同値分割テスト技法を用いて効率的なテストケースを設計する必要があります。',
    steps: [
      {
        stepNumber: 1,
        description: '入金機能の仕様を確認し、入力の有効範囲と無効範囲を特定する'
      },
      {
        stepNumber: 2,
        description: '有効同値パーティションと無効同値パーティションを識別する'
      },
      {
        stepNumber: 3,
        description: '各同値パーティションから代表値を選んでテストケースを設計する'
      },
      {
        stepNumber: 4,
        description: '設計したテストケースの有効性を評価する'
      }
    ],
    quiz: [
      {
        id: 'q-001-1',
        questionText: '銀行の入金機能（1円〜100万円まで有効）に対する同値分割テストで、以下のテストケースのうち冗長なものはどれですか？',
        options: [
          {
            id: 'q-001-1-a',
            text: '入金額: -10円',
            isCorrect: false,
            explanation: 'これは無効同値パーティション（負の値）の代表値であり、重要なテストケースです。'
          },
          {
            id: 'q-001-1-b',
            text: '入金額: 0円',
            isCorrect: false,
            explanation: 'これは境界値（下限の外側）であり、重要なテストケースです。'
          },
          {
            id: 'q-001-1-c',
            text: '入金額: 500円と入金額: 50,000円',
            isCorrect: true,
            explanation: '両方とも有効同値パーティション内の値であり、同じパーティションから複数のケースをテストすることは冗長です。同値分割の考え方では、各同値パーティションから1つのテストケースを選ぶことが効率的です。'
          },
          {
            id: 'q-001-1-d',
            text: '入金額: 1,000,001円',
            isCorrect: false,
            explanation: 'これは上限を超える値で、無効同値パーティションの代表値として重要なテストケースです。'
          }
        ],
        explanation: '同値分割テスト技法では、各同値パーティションから代表的な1つの値をテストすれば、そのパーティション内の他の値も同じ振る舞いをすると仮定します。そのため、同じ同値パーティション内から複数の値をテストすることは冗長になります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-001-2',
        questionText: '同値分割テストの主な利点は何ですか？',
        options: [
          {
            id: 'q-001-2-a',
            text: 'すべての可能な入力値を網羅的にテストできる',
            isCorrect: false,
            explanation: '同値分割は網羅的テストではなく、入力ドメインを効率的に削減するための技法です。'
          },
          {
            id: 'q-001-2-b',
            text: 'テストケース数を削減しながら効果的なカバレッジを実現できる',
            isCorrect: true,
            explanation: '同値分割の主な利点は、テストケース数を大幅に削減しながらも、効果的なテストカバレッジを実現できることです。'
          },
          {
            id: 'q-001-2-c',
            text: 'コードの複雑度を下げることができる',
            isCorrect: false,
            explanation: '同値分割はテスト設計技法であり、コードの複雑度を直接下げるものではありません。'
          },
          {
            id: 'q-001-2-d',
            text: '特定の境界値のみをテストすればよい',
            isCorrect: false,
            explanation: '境界値のテストは境界値分析の技法であり、同値分割とは異なります（ただし、相補的に使われることが多い）。'
          }
        ],
        explanation: '同値分割テスト技法の主な利点は、入力ドメインを同値パーティションに分割し、各パーティションから代表値を選ぶことで、テストケース数を削減しながらも効果的なテストを実現できる点にあります。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-001-3',
        questionText: '以下の例で、同値分割によって識別される有効同値パーティションの数はいくつですか？\n\n例：ウェブフォームの年齢入力欄。有効な入力は13歳から120歳までの整数。',
        options: [
          {
            id: 'q-001-3-a',
            text: '1つ',
            isCorrect: true,
            explanation: '有効同値パーティションは13〜120の範囲内の整数値のみの1つです。'
          },
          {
            id: 'q-001-3-b',
            text: '2つ',
            isCorrect: false,
            explanation: '有効範囲は1つの連続した範囲なので、有効同値パーティションは1つです。'
          },
          {
            id: 'q-001-3-c',
            text: '3つ',
            isCorrect: false,
            explanation: '有効範囲が分割されていないため、有効同値パーティションは1つです。'
          },
          {
            id: 'q-001-3-d',
            text: '4つ',
            isCorrect: false,
            explanation: '有効範囲が分割されていないため、有効同値パーティションは1つです。'
          }
        ],
        explanation: '有効同値パーティションは13〜120までの整数の範囲で1つです。無効同値パーティションとしては、13未満の値、120を超える値、非整数値などが考えられます。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-001-4',
        questionText: '同値分割テストを実施する際、次のうち最も適切なアプローチはどれですか？',
        options: [
          {
            id: 'q-001-4-a',
            text: '全ての同値パーティションから複数の値をテストする',
            isCorrect: false,
            explanation: '同値分割の考え方では、各パーティションから1つの代表値をテストすれば十分です。'
          },
          {
            id: 'q-001-4-b',
            text: '有効同値パーティションからのみテストケースを選択する',
            isCorrect: false,
            explanation: '無効同値パーティションのテストも重要です。無効な入力に対するシステムの動作も検証する必要があります。'
          },
          {
            id: 'q-001-4-c',
            text: '各同値パーティション（有効・無効とも）から少なくとも1つのテストケースを選択する',
            isCorrect: true,
            explanation: '同値分割の基本原則は、各同値パーティション（有効・無効とも）から少なくとも1つのテストケースを選択することです。'
          },
          {
            id: 'q-001-4-d',
            text: '境界値のみをテストする',
            isCorrect: false,
            explanation: '境界値のテストは重要ですが、同値分割では各パーティションの代表値をテストします。境界値分析は同値分割を補完する別の技法です。'
          }
        ],
        explanation: '同値分割テストでは、各同値パーティション（有効パーティションと無効パーティションの両方）から少なくとも1つのテストケースを選択することが基本原則です。これにより、効率的にテストを行いながらも、有効な入力と無効な入力の両方に対するシステムの振る舞いを検証できます。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-001-5',
        questionText: 'パスワードの複雑さチェック機能があります。パスワードは英字と数字の両方を含み、最低8文字以上である必要があります。この機能を同値分割テストする場合、以下のテストケースのうち有効同値パーティションに属するものはどれですか？',
        options: [
          {
            id: 'q-001-5-a',
            text: 'abc123xyz（英字と数字を含む9文字のパスワード）',
            isCorrect: true,
            explanation: 'このパスワードは英字と数字の両方を含み、8文字以上なので、有効同値パーティションに属します。'
          },
          {
            id: 'q-001-5-b',
            text: 'abcdefgh（英字のみの8文字のパスワード）',
            isCorrect: false,
            explanation: 'このパスワードは英字のみで数字を含まないため、無効同値パーティションに属します。'
          },
          {
            id: 'q-001-5-c',
            text: '12345678（数字のみの8文字のパスワード）',
            isCorrect: false,
            explanation: 'このパスワードは数字のみで英字を含まないため、無効同値パーティションに属します。'
          },
          {
            id: 'q-001-5-d',
            text: 'abc123（英字と数字を含む6文字のパスワード）',
            isCorrect: false,
            explanation: 'このパスワードは英字と数字を含んでいますが、8文字未満なので、無効同値パーティションに属します。'
          }
        ],
        explanation: '有効なパスワードは「英字と数字の両方を含み、8文字以上」という2つの条件を満たす必要があります。有効同値パーティションに属するテストケースは、これらすべての条件を満たすものです。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-001-6',
        questionText: '以下の仕様を持つシステムの同値分割テストを行います。以下の選択肢のうち、別々の同値パーティションに属する入力値の組み合わせはどれですか？\n\n仕様：ユーザーの年齢に基づくサービス提供\n・13歳未満：サービス利用不可\n・13歳〜17歳：保護者の同意が必要\n・18歳〜64歳：通常サービス利用可能\n・65歳以上：シニア割引適用',
        options: [
          {
            id: 'q-001-6-a',
            text: '15歳と16歳',
            isCorrect: false,
            explanation: '15歳と16歳は同じ同値パーティション（13歳〜17歳の範囲）に属します。'
          },
          {
            id: 'q-001-6-b',
            text: '12歳と13歳',
            isCorrect: true,
            explanation: '12歳は13歳未満のパーティション、13歳は13歳〜17歳のパーティションに属しており、異なる同値パーティションにあります。'
          },
          {
            id: 'q-001-6-c',
            text: '35歳と40歳',
            isCorrect: false,
            explanation: '35歳と40歳は同じ同値パーティション（18歳〜64歳の範囲）に属します。'
          },
          {
            id: 'q-001-6-d',
            text: '70歳と80歳',
            isCorrect: false,
            explanation: '70歳と80歳は同じ同値パーティション（65歳以上の範囲）に属します。'
          }
        ],
        explanation: '同値パーティションとは、プログラムが同じように処理すると予想される入力値のグループです。この例では、年齢に基づいて4つの異なる同値パーティションがあります。異なるパーティションに属する値は、システムで異なる振る舞いをすることが予想されます。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-001-7',
        questionText: '文字列の長さをチェックする関数について同値分割テストを行います。関数の仕様は「文字列の長さが1〜10文字の場合は"OK"、それ以外の場合は"NG"を返す」です。この関数に対する適切な最小テストセットはどれですか？',
        options: [
          {
            id: 'q-001-7-a',
            text: '文字列長さ: 0文字、1文字、5文字、10文字、11文字',
            isCorrect: true,
            explanation: 'このテストセットは、空文字列（無効）、下限値（有効）、中間値（有効）、上限値（有効）、上限を超える値（無効）をカバーしており、すべての同値パーティションをテストできます。'
          },
          {
            id: 'q-001-7-b',
            text: '文字列長さ: 1文字、10文字',
            isCorrect: false,
            explanation: 'このテストセットは有効同値パーティションの境界値のみをテストしており、無効同値パーティションのテストが不足しています。'
          },
          {
            id: 'q-001-7-c',
            text: '文字列長さ: 5文字、15文字',
            isCorrect: false,
            explanation: 'このテストセットでは有効同値パーティションの中間値と無効同値パーティションの値をテストしていますが、有効同値パーティションの境界値（1文字と10文字）や無効同値パーティションの下限（0文字）をテストしていません。'
          },
          {
            id: 'q-001-7-d',
            text: '文字列長さ: 1文字、5文字、10文字',
            isCorrect: false,
            explanation: 'このテストセットは有効同値パーティションの値のみをテストしており、無効同値パーティション（0文字や11文字以上）のテストが不足しています。'
          }
        ],
        explanation: '同値分割テストでは、各同値パーティションから少なくとも1つの代表値をテストします。この例では、「1〜10文字」という有効同値パーティションと、「0文字および11文字以上」という無効同値パーティションがあります。各パーティションの境界値と中間値を含む包括的なテストセットが最も適切です。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-001-8',
        questionText: 'Eコマースサイトの割引機能をテストしています。仕様は以下の通りです：\n・購入金額が5,000円未満：割引なし\n・購入金額が5,000円以上10,000円未満：5%割引\n・購入金額が10,000円以上：10%割引\n\nこの機能の同値分割テストに必要な最小テストケース数は？（各同値パーティションから1つずつテストする場合）',
        options: [
          {
            id: 'q-001-8-a',
            text: '2つ',
            isCorrect: false,
            explanation: '仕様から3つの明確な同値パーティションがあるため、2つのテストケースでは不十分です。'
          },
          {
            id: 'q-001-8-b',
            text: '3つ',
            isCorrect: true,
            explanation: '同値分割では各パーティションから1つずつテストケースを選びます。この例では、5,000円未満、5,000円以上10,000円未満、10,000円以上の3つの同値パーティションがあります。'
          },
          {
            id: 'q-001-8-c',
            text: '4つ',
            isCorrect: false,
            explanation: '3つの同値パーティションをテストするのに4つのテストケースは必要ありません。ただし、境界値も含めてテストするなら4つ以上必要になります。'
          },
          {
            id: 'q-001-8-d',
            text: '6つ',
            isCorrect: false,
            explanation: '同値分割のみを考えると、3つのテストケースで十分です。6つのテストケースは、境界値分析も含めると必要になる可能性がありますが、この問題では同値分割のみを考えています。'
          }
        ],
        explanation: '同値分割テストでは、各同値パーティションからテストケースを1つ選びます。この例では、「5,000円未満」、「5,000円以上10,000円未満」、「10,000円以上」の3つの同値パーティションがあるため、最小テストケース数は3つです。例えば、4,000円、7,000円、12,000円などの値をテストケースとして選ぶことができます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-001-9',
        questionText: '以下の無効同値パーティションのうち、同値分割テストで最も優先度が高いものはどれですか？',
        options: [
          {
            id: 'q-001-9-a',
            text: '極端に大きな値（例：整数の最大値を超える値）',
            isCorrect: false,
            explanation: '極端な値はエッジケースとして重要ですが、一般的にはシステムに特定の処理がある場合を除いて、境界に近い無効値の方が優先度が高いことが多いです。'
          },
          {
            id: 'q-001-9-b',
            text: '空の値や未入力の値',
            isCorrect: true,
            explanation: '空の値や未入力の値は、ユーザー入力では非常によく発生するケースであり、多くのバグの原因になります。そのため、優先度が高い無効同値パーティションです。'
          },
          {
            id: 'q-001-9-c',
            text: '有効範囲からはるかに離れた値',
            isCorrect: false,
            explanation: '有効範囲から非常に離れた値は、通常は境界付近の値と同じ振る舞いをすることが期待されるため、優先度は低くなります。'
          },
          {
            id: 'q-001-9-d',
            text: '使用されていないコード値',
            isCorrect: false,
            explanation: '使用されていないコード値も重要ですが、一般的にはシステムが未使用値を正しく拒否できるかをテストする目的であり、通常は空の値や未入力の値ほど優先度は高くありません。'
          }
        ],
        explanation: '同値分割テストでは、無効同値パーティションの中でも特に空の値や未入力の値は優先度が高いです。これらは実環境でよく発生するエラーケースであり、入力検証の欠陥が最も顕著に現れる部分でもあります。データベース操作やフォーム送信などでよく見られるバグの原因となります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-001-10',
        questionText: '列車の乗車券を購入するシステムについて同値分割テストを行います。以下の条件があります：\n・乗車距離：1km〜2000kmの整数\n・年齢：0歳〜120歳の整数\n・時間帯：朝（5時〜9時）、昼（9時〜17時）、夜（17時〜23時）、深夜（23時〜5時）\n\n同値分割テストで考慮すべき同値パーティションの総数は最小で何個ありますか？',
        options: [
          {
            id: 'q-001-10-a',
            text: '3個',
            isCorrect: false,
            explanation: '3つのパラメータそれぞれに複数の同値クラスがあるため、3個では不十分です。'
          },
          {
            id: 'q-001-10-b',
            text: '6個',
            isCorrect: false,
            explanation: '各パラメータの同値クラスを合計すると6個を超えます。'
          },
          {
            id: 'q-001-10-c',
            text: '9個',
            isCorrect: true,
            explanation: '乗車距離に関して、有効パーティション（1〜2000km）と無効パーティション（負の値、0、2000超）の3つ、年齢に関して有効パーティション（0〜120歳）と無効パーティション（負の値、120超）の3つ、時間帯に関して朝、昼、夜、深夜の4つ、さらに無効な時間の1つで合計9個（単純化して考えると）が最小の同値パーティション数です。'
          },
          {
            id: 'q-001-10-d',
            text: '12個',
            isCorrect: false,
            explanation: '最小の同値パーティション数を考えると、いくつかのパーティションは統合できるため、12個よりは少なくなります。'
          }
        ],
        explanation: '同値分割テストでは、入力条件ごとに有効・無効の同値パーティションを識別します。乗車距離（有効1つ、無効2つ）、年齢（有効1つ、無効2つ）、時間帯（有効4つ、無効はここでは時間外の1つと考える）を合計すると最小で9個の同値パーティションがあります。実際にはさらに細分化することも可能ですが、問題では最小数を尋ねています。',
        difficulty: 'hard',
        points: 15
      }
    ],
    techniqueName: '同値分割法',
    techniqueId: 'equivalence-partitioning',
    categoryId: 'blackbox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '25分'
  },
  {
    id: 'ex-002',
    title: '境界値分析の演習',
    description: '境界値分析（Boundary Value Analysis）テスト技法を使った実践演習です。',
    objective: 'この演習では、入力値の境界付近でのバグを効果的に検出するための境界値分析技法を学びます。',
    scenarioDescription: 
      'あなたはオンラインショッピングサイトのテスターです。商品の数量選択機能には以下の制約があります：\n\n' +
      '- 1回の注文につき最小1個から最大10個まで購入可能\n' +
      '- 数量は整数のみ\n\n' +
      'この機能に対して境界値分析を用いて効果的なテストケースを設計してください。',
    steps: [
      {
        stepNumber: 1,
        description: '機能の仕様から境界を特定する'
      },
      {
        stepNumber: 2,
        description: '各境界の内側と外側の値を識別する'
      },
      {
        stepNumber: 3,
        description: '特定した境界値を用いてテストケースを設計する'
      },
      {
        stepNumber: 4,
        description: '設計したテストケースの有効性を評価する'
      }
    ],
    quiz: [
      {
        id: 'q-002-1',
        questionText: '商品数量選択機能（1個から10個まで有効）に対する境界値分析テストで、最も重要なテストケースの組み合わせはどれですか？',
        options: [
          {
            id: 'q-002-1-a',
            text: '数量: 1個、5個、10個',
            isCorrect: false,
            explanation: '中間値（5個）のテストは境界値分析では優先度が低く、境界の外側の値（0個、11個）が含まれていません。'
          },
          {
            id: 'q-002-1-b',
            text: '数量: 0個、1個、10個、11個',
            isCorrect: true,
            explanation: 'これは境界の内側（1個、10個）と外側（0個、11個）の両方をテストしており、境界値分析の基本原則に従っています。'
          },
          {
            id: 'q-002-1-c',
            text: '数量: 1個、2個、9個、10個',
            isCorrect: false,
            explanation: '境界の内側の値は含まれていますが、境界の外側の値（0個、11個）が含まれていません。'
          },
          {
            id: 'q-002-1-d',
            text: '数量: 1個、9個、10個、100個',
            isCorrect: false,
            explanation: '下限の外側の値（0個）が含まれておらず、極端な値（100個）は境界値分析では優先度が低いです。'
          }
        ],
        explanation: '境界値分析では、境界の内側と外側の両方の値をテストすることが重要です。有効範囲が1〜10の場合、最も重要なテストケースは0、1、10、11の4つです。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-002-2',
        questionText: '境界値分析がバグ検出に特に効果的な理由は何ですか？',
        options: [
          {
            id: 'q-002-2-a',
            text: 'すべての入力可能性を網羅的にテストするため',
            isCorrect: false,
            explanation: '境界値分析はすべての入力をテストするわけではなく、境界付近の値に焦点を当てます。'
          },
          {
            id: 'q-002-2-b',
            text: 'プログラマーが境界条件を誤解することが多いため',
            isCorrect: true,
            explanation: '境界条件の処理はしばしば「off-by-one」エラーなどのバグが発生しやすく、プログラマーが条件を誤解したり、不正確に実装したりすることが多いためです。'
          },
          {
            id: 'q-002-2-c',
            text: 'テスト実行のコストが低いため',
            isCorrect: false,
            explanation: 'テストコストの低さは境界値分析の主な利点ではありません。'
          },
          {
            id: 'q-002-2-d',
            text: 'コードカバレッジを最大化するため',
            isCorrect: false,
            explanation: '境界値分析は特定の境界条件に焦点を当てるもので、コードカバレッジの最大化が主目的ではありません。'
          }
        ],
        explanation: '境界値分析がバグ検出に特に効果的なのは、プログラマーが境界条件（「以上」「より大きい」「以下」「未満」など）を正確に実装することが難しく、これらの条件で「off-by-one」エラーが発生しやすいためです。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-002-3',
        questionText: '次のパスワード要件の境界値分析で、最も重要なテストケースはどれですか？\n\n要件：パスワードは8文字以上16文字以下で、アルファベットと数字を含む必要がある',
        options: [
          {
            id: 'q-002-3-a',
            text: '7文字、8文字、16文字、17文字のパスワード',
            isCorrect: true,
            explanation: 'これは長さの境界（8文字と16文字）の内側と外側の両方をテストしており、最も重要なテストケースです。'
          },
          {
            id: 'q-002-3-b',
            text: '8文字、12文字、16文字のパスワード',
            isCorrect: false,
            explanation: '境界の内側の値のみがテストされており、境界の外側の値（7文字、17文字）が含まれていません。'
          },
          {
            id: 'q-002-3-c',
            text: '1文字、8文字、16文字、20文字のパスワード',
            isCorrect: false,
            explanation: '極端な値（1文字、20文字）は含まれていますが、下限境界の外側（7文字）が含まれていません。'
          },
          {
            id: 'q-002-3-d',
            text: '8文字、9文字、15文字、16文字のパスワード',
            isCorrect: false,
            explanation: '境界の内側の値のみがテストされており、境界の外側の値（7文字、17文字）が含まれていません。'
          }
        ],
        explanation: '境界値分析では、各境界の内側と外側の値をテストすることが重要です。パスワード長の境界が8文字と16文字なので、7文字（下限の外側）、8文字（下限）、16文字（上限）、17文字（上限の外側）が最も重要なテストケースとなります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-002-4',
        questionText: '以下のうち、境界値分析に関する記述として正しいものはどれですか？',
        options: [
          {
            id: 'q-002-4-a',
            text: '境界値分析は同値分割と対立する技法である',
            isCorrect: false,
            explanation: '境界値分析は同値分割と対立するのではなく、補完する技法です。'
          },
          {
            id: 'q-002-4-b',
            text: '境界値は常に同値クラスの中間点である',
            isCorrect: false,
            explanation: '境界値は同値パーティションの中間点ではなく、同値パーティションの境界にある値です。'
          },
          {
            id: 'q-002-4-c',
            text: '境界値分析は同値分割を補完するテスト技法である',
            isCorrect: true,
            explanation: '境界値分析は同値分割を補完する技法で、同値クラスの境界に焦点を当ててテストを行います。'
          },
          {
            id: 'q-002-4-d',
            text: '境界値分析はユーザビリティのテストに最適である',
            isCorrect: false,
            explanation: '境界値分析は主に機能的な境界条件のテストに適しており、ユーザビリティテストが主目的ではありません。'
          }
        ],
        explanation: '境界値分析は同値分割テスト技法を補完するもので、同値パーティションの境界にある値（境界値）とその周辺の値をテストすることで、境界付近で発生しやすいバグを検出するための技法です。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-002-5',
        questionText: '以下の仕様に対する境界値分析で適切なテストケースはどれですか？\n\n仕様：年齢による映画の視聴制限\n- 12歳未満：視聴不可\n- 12歳以上18歳未満：保護者の同意が必要\n- 18歳以上：制限なし',
        options: [
          {
            id: 'q-002-5-a',
            text: '10歳、15歳、20歳',
            isCorrect: false,
            explanation: 'これらは各年齢層の代表値であり、境界値ではありません。'
          },
          {
            id: 'q-002-5-b',
            text: '11歳、12歳、17歳、18歳',
            isCorrect: true,
            explanation: 'これらの値は境界（12歳と18歳）の内側と外側の値であり、境界値分析の原則に従っています。'
          },
          {
            id: 'q-002-5-c',
            text: '12歳、18歳',
            isCorrect: false,
            explanation: 'これらは境界上の値ですが、境界の外側の値（11歳、17歳）が含まれていません。'
          },
          {
            id: 'q-002-5-d',
            text: '0歳、12歳、18歳、100歳',
            isCorrect: false,
            explanation: '極端な値（0歳、100歳）は含まれていますが、境界のすぐ外側の値（11歳、17歳）が含まれていません。'
          }
        ],
        explanation: '境界値分析では、境界値とその周辺（境界のすぐ内側と外側）の値をテストすることが重要です。この例では、12歳と18歳が境界なので、11歳、12歳、17歳、18歳が適切なテストケースです。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-002-6',
        questionText: '境界値分析を適用する際の一般的なガイドラインはどれですか？',
        options: [
          {
            id: 'q-002-6-a',
            text: '境界値の両側をテストするが、境界上の値はテストしない',
            isCorrect: false,
            explanation: '境界上の値もテストすることが重要です。'
          },
          {
            id: 'q-002-6-b',
            text: '境界値とその周辺（境界値-1、境界値、境界値+1）をテストする',
            isCorrect: true,
            explanation: '境界値とその周辺の値をテストすることで、「off-by-one」エラーなどの境界条件のバグを効果的に検出できます。'
          },
          {
            id: 'q-002-6-c',
            text: '常に値の範囲の中間点をテストする',
            isCorrect: false,
            explanation: '中間点のテストは境界値分析の焦点ではありません。'
          },
          {
            id: 'q-002-6-d',
            text: '可能な限り多くの無効な値をテストする',
            isCorrect: false,
            explanation: '境界値分析では、境界のすぐ外側の値に焦点を当て、多数の無効値をテストすることは必ずしも必要ではありません。'
          }
        ],
        explanation: '境界値分析の一般的なガイドラインは、境界値とその周辺の値（境界値-1、境界値、境界値+1）をテストすることです。例えば、有効範囲が1〜10の場合、0、1、10、11の値をテストします。この方法により、「等しい」「以上」「未満」などの条件の実装ミスを効果的に検出できます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-002-7',
        questionText: '以下の仕様に対する境界値分析で、必要最小限のテストケースはいくつですか？\n\n仕様：温度制御システム\n- 温度範囲：-10℃〜40℃\n- 精度：0.5℃単位で設定可能',
        options: [
          {
            id: 'q-002-7-a',
            text: '2つ（-10℃と40℃）',
            isCorrect: false,
            explanation: '境界上の値だけではなく、境界の内側と外側の値もテストする必要があります。'
          },
          {
            id: 'q-002-7-b',
            text: '4つ（-10.5℃、-10℃、40℃、40.5℃）',
            isCorrect: true,
            explanation: 'これらの値は下限と上限の境界値とそのすぐ外側の値をカバーしており、最小限必要なテストケースです。'
          },
          {
            id: 'q-002-7-c',
            text: '6つ（-11℃、-10℃、-9.5℃、39.5℃、40℃、41℃）',
            isCorrect: false,
            explanation: '境界のすぐ内側の値（-9.5℃、39.5℃）は重要ですが、必須ではありません。また、精度が0.5℃単位なので、-10.5℃と40.5℃が適切な外側の値です。'
          },
          {
            id: 'q-002-7-d',
            text: '3つ（-10℃、15℃、40℃）',
            isCorrect: false,
            explanation: '中間値（15℃）は境界値分析では重要ではなく、境界の外側の値が含まれていません。'
          }
        ],
        explanation: '境界値分析では、各境界の値とそのすぐ外側の値をテストします。この温度制御システムでは、下限が-10℃、上限が40℃で、精度が0.5℃単位なので、最小限必要なテストケースは-10.5℃（下限の外側）、-10℃（下限）、40℃（上限）、40.5℃（上限の外側）の4つです。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-002-8',
        questionText: '以下のうち、境界値分析が特に有効な状況はどれですか？',
        options: [
          {
            id: 'q-002-8-a',
            text: '入力値の組み合わせによる相互作用をテストする場合',
            isCorrect: false,
            explanation: '入力値の組み合わせはペアワイズテストなどの技法が適しています。'
          },
          {
            id: 'q-002-8-b',
            text: '数値範囲や日付範囲など、明確な境界がある入力をテストする場合',
            isCorrect: true,
            explanation: '境界値分析は、数値範囲や日付範囲など明確な境界がある入力に特に有効です。'
          },
          {
            id: 'q-002-8-c',
            text: 'システムの性能限界を評価する場合',
            isCorrect: false,
            explanation: '性能限界の評価には、負荷テストやストレステストが適しています。'
          },
          {
            id: 'q-002-8-d',
            text: 'ユーザーインターフェースの使いやすさを評価する場合',
            isCorrect: false,
            explanation: 'UIの使いやすさの評価には、ユーザビリティテストが適しています。'
          }
        ],
        explanation: '境界値分析は、数値範囲、日付範囲、文字列の長さなど、明確な境界がある入力をテストする場合に特に有効です。これらの境界付近でバグが発生しやすく、例えば「1以上10以下」を「1より大きく10より小さい」と誤って実装するなどのミスを検出できます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-002-9',
        questionText: 'ショッピングサイトの割引機能に関する以下の仕様に対する境界値分析で、最適なテストケースはどれですか？\n\n仕様：\n- 購入金額が5,000円未満：割引なし\n- 購入金額が5,000円以上10,000円未満：5%割引\n- 購入金額が10,000円以上：10%割引',
        options: [
          {
            id: 'q-002-9-a',
            text: '4,999円、5,000円、9,999円、10,000円',
            isCorrect: true,
            explanation: 'これらの値は境界（5,000円と10,000円）のすぐ内側と外側の値であり、境界値分析の原則に従っています。'
          },
          {
            id: 'q-002-9-b',
            text: '4,000円、5,000円、9,000円、10,000円',
            isCorrect: false,
            explanation: '下限境界のすぐ内側（4,999円）と上限境界のすぐ内側（9,999円）の値が含まれていません。'
          },
          {
            id: 'q-002-9-c',
            text: '0円、5,000円、10,000円、20,000円',
            isCorrect: false,
            explanation: '極端な値（0円、20,000円）は含まれていますが、境界のすぐ内側の値（4,999円、9,999円）が含まれていません。'
          },
          {
            id: 'q-002-9-d',
            text: '4,999円、5,001円、9,999円、10,001円',
            isCorrect: false,
            explanation: '境界上の値（5,000円、10,000円）が含まれていません。'
          }
        ],
        explanation: '境界値分析では、境界とその周辺の値をテストします。この例では、5,000円と10,000円が境界なので、4,999円、5,000円、9,999円、10,000円が最適なテストケースです。これらの値で、各割引レベルの境界でシステムが正しく動作するかを確認できます。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-002-10',
        questionText: '以下のうち、境界値分析に関する説明として正しいものはどれですか？',
        options: [
          {
            id: 'q-002-10-a',
            text: '境界値分析は、常にすべての入力パラメータの組み合わせをテストする必要がある',
            isCorrect: false,
            explanation: 'すべての組み合わせをテストするのは組み合わせテスト技法の特徴であり、境界値分析の主な焦点ではありません。'
          },
          {
            id: 'q-002-10-b',
            text: '境界値分析は、同値分割法の代わりに使用するテスト技法である',
            isCorrect: false,
            explanation: '境界値分析は同値分割法の代わりではなく、補完するものとして使用します。'
          },
          {
            id: 'q-002-10-c',
            text: '境界値分析は、プログラマーが「off-by-one」エラーを犯しやすい境界条件に焦点を当てる',
            isCorrect: true,
            explanation: '境界値分析は、プログラマーが条件の実装を誤りやすい境界付近の値に焦点を当て、「off-by-one」のようなエラーを検出します。'
          },
          {
            id: 'q-002-10-d',
            text: '境界値分析は、主にパフォーマンス問題を検出するために使用される',
            isCorrect: false,
            explanation: '境界値分析は機能的な正確性をテストするもので、パフォーマンス問題の検出が主目的ではありません。'
          }
        ],
        explanation: '境界値分析は、プログラマーが「以上」「より大きい」「以下」「未満」などの条件を誤って実装しやすい境界条件に焦点を当てるテスト技法です。特に「off-by-one」エラー（1つずれるエラー）のような、境界付近で発生しやすいバグを効果的に検出します。同値分割法と組み合わせて使用することで、テストの効率と効果を高めることができます。',
        difficulty: 'easy',
        points: 5
      }
    ],
    techniqueName: '境界値分析',
    techniqueId: 'boundary-value-analysis',
    categoryId: 'blackbox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '25分'
  },
  {
    id: 'ex-003',
    title: '決定表テストの演習',
    description: '決定表テスト（Decision Table Testing）技法を使った実践演習です。',
    objective: 'この演習では、複数の条件と結果の組み合わせを効率的にテストするための決定表テスト技法を学びます。',
    scenarioDescription: 
      'あなたはECサイトのテスターです。割引システムには以下のルールがあります：\n\n' +
      '- 会員ステータス：一般会員またはプレミアム会員\n' +
      '- 購入回数：10回未満または10回以上\n' +
      '- 購入金額：5,000円以上または5,000円未満\n\n' +
      'これらの条件に基づいて、以下の割引率が適用されます：\n' +
      '- プレミアム会員で購入回数10回以上：15%割引\n' +
      '- プレミアム会員で購入回数10回未満：10%割引\n' +
      '- 一般会員で購入回数10回以上かつ購入金額5,000円以上：8%割引\n' +
      '- 一般会員で購入回数10回以上かつ購入金額5,000円未満：5%割引\n' +
      '- 一般会員で購入回数10回未満かつ購入金額5,000円以上：5%割引\n' +
      '- 一般会員で購入回数10回未満かつ購入金額5,000円未満：割引なし\n\n' +
      'この機能に対して決定表テスト技法を用いて効果的なテストケースを設計してください。',
    steps: [
      {
        stepNumber: 1,
        description: '条件と結果を特定する'
      },
      {
        stepNumber: 2,
        description: '可能な条件の組み合わせを決定表にまとめる'
      },
      {
        stepNumber: 3,
        description: '決定表から必要なテストケースを設計する'
      },
      {
        stepNumber: 4,
        description: '冗長なテストケースを削減する'
      }
    ],
    quiz: [
      {
        id: 'q-003-1',
        questionText: '上記のECサイト割引システムに対する決定表で、必要最小限のテストケース数はいくつですか？',
        options: [
          {
            id: 'q-003-1-a',
            text: '2つ',
            isCorrect: false,
            explanation: '2つでは会員ステータス（2種類）のみをカバーすることしかできず、不十分です。'
          },
          {
            id: 'q-003-1-b',
            text: '4つ',
            isCorrect: false,
            explanation: '4つでは会員ステータス（2種類）と購入回数（2種類）の組み合わせはカバーできますが、購入金額の条件が考慮されていません。'
          },
          {
            id: 'q-003-1-c',
            text: '6つ',
            isCorrect: true,
            explanation: '会員ステータス（2種類）、購入回数（2種類）、購入金額（2種類）の組み合わせで、理論上は8通りですが、プレミアム会員の場合は購入金額に関わらず同じ結果になるため、実際には6つのテストケースが必要です。'
          },
          {
            id: 'q-003-1-d',
            text: '8つ',
            isCorrect: false,
            explanation: '理論上は2×2×2=8通りの組み合わせがありますが、プレミアム会員の場合は購入金額による結果の違いがないため、8つすべてをテストする必要はありません。'
          }
        ],
        explanation: '決定表テストでは、条件の組み合わせごとに異なる結果が得られるケースをテストします。この例では、プレミアム会員の場合、購入金額に関わらず購入回数だけで割引率が決まるため、プレミアム会員については2ケース、一般会員については購入回数と購入金額の組み合わせで4ケース、合計6つのテストケースが必要になります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-003-2',
        questionText: '決定表テスト技法が特に有効な状況はどれですか？',
        options: [
          {
            id: 'q-003-2-a',
            text: '単一の入力値の境界をテストする場合',
            isCorrect: false,
            explanation: '単一入力値の境界テストには境界値分析が適しています。'
          },
          {
            id: 'q-003-2-b',
            text: '複数の条件の組み合わせによって異なる結果が発生する場合',
            isCorrect: true,
            explanation: '複数の条件（入力）の組み合わせによって異なる結果（出力）が発生する場合、決定表テストが特に有効です。'
          },
          {
            id: 'q-003-2-c',
            text: '連続的なユーザーの動作をテストする場合',
            isCorrect: false,
            explanation: '連続的なユーザー動作のテストにはステートトランジションテストが適しています。'
          },
          {
            id: 'q-003-2-d',
            text: '大量の入力データからサンプルを選んでテストする場合',
            isCorrect: false,
            explanation: '大量の入力データからサンプルを選ぶには同値分割法が適しています。'
          }
        ],
        explanation: '決定表テスト技法は、複数の条件（入力）の組み合わせによって異なる結果（出力）が発生するロジックをテストする場合に特に有効です。例えば、割引の適用条件、ローンの承認条件、保険料の計算など、「IF-THEN-ELSE」が複雑に組み合わさったビジネスルールのテストに適しています。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-003-3',
        questionText: '以下の決定表の一部で、「?」の部分に入るべき値は何ですか？\n\n| 条件/テストケース | TC1 | TC2 | TC3 | TC4 |\n|-----------------|-----|-----|-----|-----|\n| 条件1 | Y | Y | N | N |\n| 条件2 | Y | N | Y | ? |',
        options: [
          {
            id: 'q-003-3-a',
            text: 'Y',
            isCorrect: false,
            explanation: 'TC3ですでに「条件1=N、条件2=Y」の組み合わせがあるため、TC4で同じ組み合わせを重複させる必要はありません。'
          },
          {
            id: 'q-003-3-b',
            text: 'N',
            isCorrect: true,
            explanation: '完全な決定表では、すべての条件の組み合わせをカバーする必要があります。TC1〜TC3で「Y-Y」「Y-N」「N-Y」を使っているので、TC4には「N-N」が必要です。'
          },
          {
            id: 'q-003-3-c',
            text: '-（どちらでもよい）',
            isCorrect: false,
            explanation: '完全な決定表を作成するためには、すべての条件の組み合わせを明示的にカバーする必要があります。'
          },
          {
            id: 'q-003-3-d',
            text: 'このテストケースは不要',
            isCorrect: false,
            explanation: '2つの条件がある場合、2^2=4通りの組み合わせが必要です。TC4は「条件1=N、条件2=N」の組み合わせをテストするために必要です。'
          }
        ],
        explanation: '決定表テストでは、N個の条件に対して2^N通りの組み合わせをすべてカバーします（条件が排他的でない場合）。この例では、2つの条件があるため、2^2=4通りの組み合わせが必要です。TC1〜TC3ですでに「Y-Y」「Y-N」「N-Y」の組み合わせをカバーしているので、TC4では残りの「N-N」の組み合わせをテストする必要があります。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-003-4',
        questionText: '決定表テストを実施する際の正しいステップはどれですか？',
        options: [
          {
            id: 'q-003-4-a',
            text: '1. 可能なすべての入力値を列挙する 2. 各入力値の同値クラスを識別する 3. 各同値クラスから代表値を選ぶ',
            isCorrect: false,
            explanation: 'これは同値分割法のステップであり、決定表テストのステップではありません。'
          },
          {
            id: 'q-003-4-b',
            text: '1. テスト対象の条件を特定する 2. 各条件のすべての組み合わせを決定表に記載する 3. 各組み合わせに対する期待結果を記載する 4. テストケースを設計する',
            isCorrect: true,
            explanation: 'これは決定表テストの基本的なステップです。条件を特定し、その組み合わせと期待結果を決定表にまとめ、テストケースを設計します。'
          },
          {
            id: 'q-003-4-c',
            text: '1. 境界値を特定する 2. 境界値の内側と外側の値をテストケースに含める',
            isCorrect: false,
            explanation: 'これは境界値分析のステップであり、決定表テストのステップではありません。'
          },
          {
            id: 'q-003-4-d',
            text: '1. システムの状態を特定する 2. 状態間の遷移を特定する 3. 状態遷移図を作成する',
            isCorrect: false,
            explanation: 'これはステートトランジションテストのステップであり、決定表テストのステップではありません。'
          }
        ],
        explanation: '決定表テストの基本的なステップは以下の通りです：\n1. テスト対象のシステムから関連する条件と結果を特定する\n2. 可能なすべての条件の組み合わせを決定表に記載する\n3. 各組み合わせに対する期待結果を決定表に記載する\n4. 決定表をテストケースに変換する\n5. 必要に応じて冗長なテストケースを削減する（ルール結合を行う）',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-003-5',
        questionText: '16個の条件の組み合わせがある複雑なビジネスルールをテストするとき、フルの決定表テストでは何個のテストケースが必要ですか？',
        options: [
          {
            id: 'q-003-5-a',
            text: '16個',
            isCorrect: false,
            explanation: '16個は条件の数であり、組み合わせの数ではありません。'
          },
          {
            id: 'q-003-5-b',
            text: '32個',
            isCorrect: false,
            explanation: '32個（2^5=32）は5つの条件がある場合の組み合わせ数です。'
          },
          {
            id: 'q-003-5-c',
            text: '256個',
            isCorrect: false,
            explanation: '256個（2^8=256）は8つの条件がある場合の組み合わせ数です。'
          },
          {
            id: 'q-003-5-d',
            text: '65,536個',
            isCorrect: true,
            explanation: '各条件には2つの値（TrueとFalse）があるため、16個の条件の組み合わせ数は2^16=65,536個になります。'
          }
        ],
        explanation: '決定表テストでは、N個の条件に対してテストケース数は2^N個になります（各条件が2値の場合）。16個の条件があれば、テストケース数は2^16=65,536個になります。これは非常に多いため、実際には条件を減らしたり、条件の依存関係を考慮したり、他のテスト技法と組み合わせたりして、効率的にテストします。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-003-6',
        questionText: '決定表テストの主な利点は何ですか？',
        options: [
          {
            id: 'q-003-6-a',
            text: 'テスト実行の自動化が容易になる',
            isCorrect: false,
            explanation: '決定表テストはテスト設計の技法であり、テスト実行の自動化とは直接関係ありません。'
          },
          {
            id: 'q-003-6-b',
            text: '複雑なビジネスルールを明確に可視化し、漏れなくテストできる',
            isCorrect: true,
            explanation: '決定表テストの主な利点は、複雑なビジネスルールを構造化し、条件の組み合わせを漏れなくテストできることです。'
          },
          {
            id: 'q-003-6-c',
            text: 'テストの実行時間を短縮できる',
            isCorrect: false,
            explanation: '決定表テストはテスト設計の技法であり、テスト実行時間の短縮とは直接関係ありません。'
          },
          {
            id: 'q-003-6-d',
            text: 'ユーザビリティの問題を発見できる',
            isCorrect: false,
            explanation: '決定表テストは機能的な正確性をテストするもので、ユーザビリティの問題発見が主目的ではありません。'
          }
        ],
        explanation: '決定表テストの主な利点は、複雑なビジネスルールやIF-THEN-ELSE構造を持つロジックを明確に構造化し、条件の組み合わせを漏れなくテストできることです。テスト設計者が条件の組み合わせを見落とすことを防ぎ、ロジックの不整合や欠陥を効果的に発見できます。また、ビジネスルールの可視化にも役立ちます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-003-7',
        questionText: '以下の決定表で、TC3のテストケースはどのような条件と結果になりますか？\n\n| 条件/テストケース | TC1 | TC2 | TC3 | TC4 |\n|-----------------|-----|-----|-----|-----|\n| 会員ステータス | 一般 | 一般 | プレミアム | プレミアム |\n| 購入回数10回以上 | N | Y | N | Y |\n| 結果：割引率 | 0% | 5% | 10% | 15% |',
        options: [
          {
            id: 'q-003-7-a',
            text: '一般会員で購入回数10回以上の場合、5%割引',
            isCorrect: false,
            explanation: 'これはTC2の条件と結果です。'
          },
          {
            id: 'q-003-7-b',
            text: 'プレミアム会員で購入回数10回未満の場合、10%割引',
            isCorrect: true,
            explanation: 'TC3は「会員ステータス=プレミアム、購入回数10回以上=N（つまり10回未満）」という条件で、結果は10%割引です。'
          },
          {
            id: 'q-003-7-c',
            text: 'プレミアム会員で購入回数10回以上の場合、15%割引',
            isCorrect: false,
            explanation: 'これはTC4の条件と結果です。'
          },
          {
            id: 'q-003-7-d',
            text: '一般会員で購入回数10回未満の場合、割引なし',
            isCorrect: false,
            explanation: 'これはTC1の条件と結果です。'
          }
        ],
        explanation: '決定表では、各列（TCx）がテストケースを表し、各行が条件と結果を表します。TC3の列を見ると、「会員ステータス=プレミアム、購入回数10回以上=N（つまり10回未満）」という条件で、結果は10%割引になっています。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-003-8',
        questionText: '決定表テストで「ルール結合」とは何ですか？',
        options: [
          {
            id: 'q-003-8-a',
            text: '複数のテストケースを1つにまとめる技法',
            isCorrect: true,
            explanation: 'ルール結合は、特定の条件が結果に影響しない場合に、複数のテストケースをまとめる技法です。'
          },
          {
            id: 'q-003-8-b',
            text: '複数のアプリケーションのルールを比較する技法',
            isCorrect: false,
            explanation: 'これは決定表テストにおけるルール結合の意味ではありません。'
          },
          {
            id: 'q-003-8-c',
            text: '条件同士を組み合わせて新しい条件を作る技法',
            isCorrect: false,
            explanation: 'これは条件の結合であり、ルール結合ではありません。'
          },
          {
            id: 'q-003-8-d',
            text: 'テスト実行の順序を決定する技法',
            isCorrect: false,
            explanation: 'ルール結合はテスト実行の順序とは関係ありません。'
          }
        ],
        explanation: '決定表テストにおける「ルール結合」とは、特定の条件の値が結果に影響しない場合に、複数のテストケース（ルール）を1つにまとめる技法です。例えば、「条件A=Y、条件B=Y」と「条件A=Y、条件B=N」の両方で同じ結果が得られる場合、これらを「条件A=Y、条件B=どちらでも」という1つのテストケースにまとめることができます。これにより、テストケースの数を削減できます。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-003-9',
        questionText: '決定表テストを適用する際の課題と対策として正しいものはどれですか？',
        options: [
          {
            id: 'q-003-9-a',
            text: '課題：条件が多いと組み合わせ爆発が起きる、対策：条件の依存関係を考慮して不可能な組み合わせを除外する',
            isCorrect: true,
            explanation: '条件が多いと組み合わせの数が指数関数的に増加する問題があり、条件の依存関係を考慮して不可能な組み合わせを除外するのは有効な対策です。'
          },
          {
            id: 'q-003-9-b',
            text: '課題：テスト実行に時間がかかる、対策：並列実行を導入する',
            isCorrect: false,
            explanation: 'テスト実行の時間は決定表テストの主な課題ではなく、テスト設計の段階での組み合わせ爆発が主な課題です。'
          },
          {
            id: 'q-003-9-c',
            text: '課題：境界値を特定するのが難しい、対策：同値分割法を先に適用する',
            isCorrect: false,
            explanation: '境界値の特定は境界値分析の課題であり、決定表テストの主な課題ではありません。'
          },
          {
            id: 'q-003-9-d',
            text: '課題：ユーザーの行動パターンを予測できない、対策：探索的テストを併用する',
            isCorrect: false,
            explanation: 'ユーザー行動パターンの予測は決定表テストの主な課題ではなく、決定表テストはビジネスルールなどの条件と結果の関係をテストする技法です。'
          }
        ],
        explanation: '決定表テストの主な課題は、条件が多くなると組み合わせの数が指数関数的に増加する「組み合わせ爆発」です。例えば、10個の条件があると、2^10=1,024個のテストケースが必要になります。この課題に対する効果的な対策としては、条件の依存関係を考慮して不可能な組み合わせを除外する、条件をグループ化する、ペアワイズテストのような組み合わせテスト技法を使用して効率的にカバレッジを確保するなどがあります。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-003-10',
        questionText: '以下のうち、決定表テストに関する説明として正しいものはどれですか？',
        options: [
          {
            id: 'q-003-10-a',
            text: '決定表テストは、主にパフォーマンス問題を検出するために使用される',
            isCorrect: false,
            explanation: '決定表テストはビジネスルールの正確性をテストするもので、パフォーマンス問題の検出が主目的ではありません。'
          },
          {
            id: 'q-003-10-b',
            text: '決定表テストは、複数の条件の組み合わせに基づくロジックをテストするための系統的なアプローチを提供する',
            isCorrect: true,
            explanation: '決定表テストは、複数の条件とその組み合わせによって異なる結果が発生するロジックを、系統的にテストするためのアプローチを提供します。'
          },
          {
            id: 'q-003-10-c',
            text: '決定表テストは、ユーザーインターフェースの使いやすさを評価するのに最適である',
            isCorrect: false,
            explanation: '決定表テストはUIの使いやすさを評価するものではなく、ビジネスルールなどの条件と結果の関係をテストする技法です。'
          },
          {
            id: 'q-003-10-d',
            text: '決定表テストは、コードの網羅率を高めるために使用される',
            isCorrect: false,
            explanation: '決定表テストの主な目的はコードの網羅率を高めることではなく、ビジネスルールの条件と結果の組み合わせを漏れなくテストすることです。'
          }
        ],
        explanation: '決定表テストは、複数の条件の組み合わせに基づくロジック（特にビジネスルールやIF-THEN-ELSE構造を持つロジック）をテストするための系統的なアプローチを提供します。条件の組み合わせと、それに対応する結果をテーブル形式で表現し、漏れなくテストすることを目的としています。特に、複雑な条件分岐がある場合や、条件の組み合わせによって異なる結果が得られる場合に効果的です。',
        difficulty: 'easy',
        points: 5
      }
    ],
    techniqueName: '決定表テスト',
    techniqueId: 'decision-table',
    categoryId: 'blackbox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '25分'
  },
  {
    id: 'ex-004',
    title: '状態遷移テストの演習',
    description: '状態遷移テスト（State Transition Testing）技法を使った実践演習です。',
    objective: 'この演習では、システムの状態変化と遷移を効果的にテストするための状態遷移テスト技法を学びます。',
    scenarioDescription: 
      'あなたはECサイトの注文システムのテスターです。このシステムは以下の状態と遷移を持っています：\n\n' +
      '状態：\n' +
      '- カート（初期状態）\n' +
      '- 配送情報入力\n' +
      '- 支払い情報入力\n' +
      '- 注文確認\n' +
      '- 注文完了\n' +
      '- エラー\n\n' +
      '主な遷移：\n' +
      '- カート → 配送情報入力：「次へ」ボタンをクリック（商品がカートにある場合）\n' +
      '- 配送情報入力 → 支払い情報入力：「次へ」ボタンをクリック（有効な配送情報が入力されている場合）\n' +
      '- 配送情報入力 → カート：「戻る」ボタンをクリック\n' +
      '- 支払い情報入力 → 注文確認：「次へ」ボタンをクリック（有効な支払い情報が入力されている場合）\n' +
      '- 支払い情報入力 → 配送情報入力：「戻る」ボタンをクリック\n' +
      '- 注文確認 → 注文完了：「注文確定」ボタンをクリック（すべての情報が正しい場合）\n' +
      '- 注文確認 → 支払い情報入力：「戻る」ボタンをクリック\n' +
      '- 任意の状態 → エラー：システムエラーが発生した場合\n' +
      '- エラー → カート：「カートに戻る」ボタンをクリック\n\n' +
      'この注文システムに対して状態遷移テスト技法を用いて効果的なテストケースを設計してください。',
    steps: [
      {
        stepNumber: 1,
        description: 'システムの状態と遷移を特定する'
      },
      {
        stepNumber: 2,
        description: '状態遷移図（または表）を作成する'
      },
      {
        stepNumber: 3,
        description: '状態遷移カバレッジを考慮してテストケースを設計する'
      },
      {
        stepNumber: 4,
        description: '異常なシナリオも考慮する'
      }
    ],
    quiz: [
      {
        id: 'q-004-1',
        questionText: '状態遷移テストで「状態」とは何ですか？',
        options: [
          {
            id: 'q-004-1-a',
            text: 'テスト実行中の実行ステータス（成功/失敗/進行中など）',
            isCorrect: false,
            explanation: 'これはテスト自体の状態であり、テスト対象システムの状態ではありません。'
          },
          {
            id: 'q-004-1-b',
            text: 'テスターの心理状態（集中/疲労/満足など）',
            isCorrect: false,
            explanation: 'テスターの心理状態はテストとは関係ありません。'
          },
          {
            id: 'q-004-1-c',
            text: 'システムが取りうる安定した条件や形態',
            isCorrect: true,
            explanation: '状態遷移テストにおける「状態」とは、システムがある一定の時点で取りうる安定した条件や形態を指します。'
          },
          {
            id: 'q-004-1-d',
            text: 'テスト対象コードの行数やカバレッジの割合',
            isCorrect: false,
            explanation: 'コードの行数やカバレッジの割合は状態ではなく、テスト品質の指標です。'
          }
        ],
        explanation: '状態遷移テストにおける「状態」とは、システムが特定の時点で取りうる安定した条件や形態を指します。例えば、ECサイトの注文システムでは「カート」「配送情報入力」「支払い情報入力」などが状態となります。各状態では、システムは特定の動作や振る舞いをし、ユーザーやシステムのアクションによって別の状態に遷移します。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-004-2',
        questionText: '状態遷移テストにおける「遷移」とは何ですか？',
        options: [
          {
            id: 'q-004-2-a',
            text: 'あるテストケースから別のテストケースへの移行',
            isCorrect: false,
            explanation: 'これはテストケース間の移行であり、システムの状態遷移ではありません。'
          },
          {
            id: 'q-004-2-b',
            text: 'ある状態から別の状態へのシステムの変化',
            isCorrect: true,
            explanation: '遷移とは、ある状態から別の状態へのシステムの変化を指します。これは通常、何らかのイベントやアクション（入力）によって引き起こされます。'
          },
          {
            id: 'q-004-2-c',
            text: 'テスト環境から本番環境へのリリース',
            isCorrect: false,
            explanation: 'これはソフトウェアのデプロイメントに関する概念であり、状態遷移テストにおける遷移ではありません。'
          },
          {
            id: 'q-004-2-d',
            text: '異なるテスト技法間の切り替え',
            isCorrect: false,
            explanation: 'これはテスト戦略に関する概念であり、状態遷移テストにおける遷移ではありません。'
          }
        ],
        explanation: '状態遷移テストにおける「遷移」とは、あるシステム状態から別のシステム状態への変化を指します。遷移はイベントやアクション（例：ボタンのクリック、データの入力、タイマーの満了など）によって引き起こされます。例えば、ECサイトの注文システムでは、「次へ」ボタンのクリックにより「カート」状態から「配送情報入力」状態への遷移が発生します。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-004-3',
        questionText: '状態遷移テストが特に適している状況はどれですか？',
        options: [
          {
            id: 'q-004-3-a',
            text: '単一の入力フィールドの境界値をテストする場合',
            isCorrect: false,
            explanation: '単一入力フィールドの境界値テストには境界値分析が適しています。'
          },
          {
            id: 'q-004-3-b',
            text: '複数の条件の組み合わせによる結果をテストする場合',
            isCorrect: false,
            explanation: '複数条件の組み合わせには決定表テストが適しています。'
          },
          {
            id: 'q-004-3-c',
            text: 'システムの動作が現在の状態と入力に依存する場合',
            isCorrect: true,
            explanation: 'システムの動作が現在の状態と入力に依存する場合、状態遷移テストが特に適しています。'
          },
          {
            id: 'q-004-3-d',
            text: '大量の入力データのパターンを効率的にテストする場合',
            isCorrect: false,
            explanation: '大量の入力データパターンには同値分割法やペアワイズテストが適しています。'
          }
        ],
        explanation: '状態遷移テストは、システムの動作が現在の状態と入力によって決まるような状況で特に有効です。例えば、ワークフロー管理システム、ウィザード形式のインターフェース、ステータスを持つアプリケーション（注文処理、予約システムなど）、有限状態機械に基づくシステムなどです。これらのシステムでは、同じ入力でも現在の状態によって異なる結果が生じる可能性があります。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-004-4',
        questionText: '注文システムの状態遷移テストで、以下のテストシナリオのうち最も重要なものはどれですか？',
        options: [
          {
            id: 'q-004-4-a',
            text: 'カート → 配送情報入力 → 支払い情報入力 → 注文確認 → 注文完了（正常フロー）',
            isCorrect: true,
            explanation: '正常フローは最も基本的なシナリオであり、システムの主要機能が正しく動作することを確認するために最も重要です。'
          },
          {
            id: 'q-004-4-b',
            text: 'カート → 配送情報入力 → カート → 配送情報入力（繰り返しフロー）',
            isCorrect: false,
            explanation: '繰り返しフローも重要ですが、主要機能の動作を確認する正常フローほど優先度は高くありません。'
          },
          {
            id: 'q-004-4-c',
            text: 'カート → 配送情報入力 → 支払い情報入力 → 注文確認 → 支払い情報入力（戻るフロー）',
            isCorrect: false,
            explanation: '戻るフローも重要ですが、主要機能の動作を確認する正常フローほど優先度は高くありません。'
          },
          {
            id: 'q-004-4-d',
            text: 'カート（空の状態） → エラー → カート（異常フロー）',
            isCorrect: false,
            explanation: '異常フローも重要ですが、主要機能の動作を確認する正常フローほど優先度は高くありません。'
          }
        ],
        explanation: '状態遷移テストでは、まず正常フロー（ハッピーパス）をテストすることが最も重要です。これはシステムの主要機能が意図した通りに動作することを確認します。例えば、注文システムでは「カート → 配送情報入力 → 支払い情報入力 → 注文確認 → 注文完了」という一連の流れが正常に機能することをまず確認します。その後、戻る操作、繰り返し操作、エラー状態からの回復など、他のシナリオもテストします。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-004-5',
        questionText: '状態遷移テストで「N-1スイッチカバレッジ」とは何ですか？',
        options: [
          {
            id: 'q-004-5-a',
            text: 'すべての状態を少なくとも1回訪問するテストカバレッジ',
            isCorrect: false,
            explanation: 'これは「状態カバレッジ」であり、N-1スイッチカバレッジではありません。'
          },
          {
            id: 'q-004-5-b',
            text: 'すべての遷移（状態の変化）を少なくとも1回実行するテストカバレッジ',
            isCorrect: true,
            explanation: 'N-1スイッチカバレッジ（簡単に言えば「0-スイッチカバレッジ」）は、すべての遷移を少なくとも1回テストするカバレッジです。'
          },
          {
            id: 'q-004-5-c',
            text: 'すべての状態の組み合わせをテストするカバレッジ',
            isCorrect: false,
            explanation: 'すべての状態の組み合わせというカバレッジの概念はありません。'
          },
          {
            id: 'q-004-5-d',
            text: 'N回の遷移から1回を除外するテストカバレッジ',
            isCorrect: false,
            explanation: 'これはN-1スイッチカバレッジの誤った解釈です。'
          }
        ],
        explanation: '状態遷移テストにおける「N-1スイッチカバレッジ」（Nは0から始まるため、0スイッチカバレッジとも呼ばれる）は、すべての個別の遷移（あるいは「エッジ」）を少なくとも1回テストするカバレッジレベルを指します。つまり、状態遷移図のすべての矢印が少なくとも1回テストされることを確認します。例えば、「カート → 配送情報入力」、「配送情報入力 → 支払い情報入力」などの各遷移を少なくとも1回テストします。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-004-6',
        questionText: '状態遷移テストで「状態遷移表」と「状態遷移図」の主な違いは何ですか？',
        options: [
          {
            id: 'q-004-6-a',
            text: '状態遷移表は数学的に正確だが、状態遷移図はそうではない',
            isCorrect: false,
            explanation: '両方とも数学的に同じ情報を表現でき、正確さに違いはありません。'
          },
          {
            id: 'q-004-6-b',
            text: '状態遷移表はテキスト形式だが、状態遷移図はグラフィカル表現である',
            isCorrect: true,
            explanation: '状態遷移表はテキストや表形式で情報を整理し、状態遷移図は同じ情報をグラフィカルに視覚化します。'
          },
          {
            id: 'q-004-6-c',
            text: '状態遷移表はプログラムで実行できるが、状態遷移図はそうではない',
            isCorrect: false,
            explanation: '両方ともモデル化のための表現であり、そのままプログラムとして実行できるわけではありません。'
          },
          {
            id: 'q-004-6-d',
            text: '状態遷移表は初心者向け、状態遷移図は専門家向けである',
            isCorrect: false,
            explanation: '両方とも専門性には関係なく、表現方法の違いであり、状況や好みによって使い分けます。'
          }
        ],
        explanation: '状態遷移表と状態遷移図の主な違いは表現形式です。状態遷移表は行と列を使ったマトリックス形式で情報を整理します（行が現在の状態、列が入力/イベント、セルが次の状態を表す）。一方、状態遷移図はノード（状態）と矢印（遷移）を使ったグラフィカルな表現です。両方とも同じ情報を表現しますが、状態遷移図は視覚的に理解しやすく、状態遷移表は特に状態や遷移が多い場合に詳細情報を整理しやすいという特徴があります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-004-7',
        questionText: '以下の状態遷移図から、有効な状態遷移パスはどれですか？\n\n初期状態→状態A→状態B→状態C→最終状態\n初期状態→状態D→状態B→状態C→最終状態\n状態A↔状態B\n状態B→状態D（エラー時）',
        options: [
          {
            id: 'q-004-7-a',
            text: '初期状態→状態D→状態A→状態B→状態C→最終状態',
            isCorrect: false,
            explanation: '状態Dから状態Aへの遷移は図に定義されていません。'
          },
          {
            id: 'q-004-7-b',
            text: '初期状態→状態A→状態B→状態A→状態B→状態C→最終状態',
            isCorrect: true,
            explanation: 'この経路は図に定義されたすべての遷移に従っています。状態A↔状態Bの双方向の遷移を使用しています。'
          },
          {
            id: 'q-004-7-c',
            text: '初期状態→状態A→状態C→最終状態',
            isCorrect: false,
            explanation: '状態Aから状態Cへの直接の遷移は図に定義されていません。'
          },
          {
            id: 'q-004-7-d',
            text: '初期状態→状態D→状態B→状態D→状態C→最終状態',
            isCorrect: false,
            explanation: '状態Dから状態Cへの直接の遷移は図に定義されていません。'
          }
        ],
        explanation: '有効な状態遷移パスは、状態遷移図で定義された遷移のみを使用するパスです。この場合、「初期状態→状態A→状態B→状態A→状態B→状態C→最終状態」は有効なパスです。初期状態から状態Aに移動し、状態Aと状態Bの間を行き来した後（状態A↔状態Bの双方向遷移を利用）、状態Bから状態Cを経て最終状態に到達しています。すべての遷移は図に定義されています。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-004-8',
        questionText: '状態遷移テストでよく考慮すべき「不正な遷移」とは何ですか？',
        options: [
          {
            id: 'q-004-8-a',
            text: '定義されていない状態への遷移',
            isCorrect: false,
            explanation: '定義されていない状態は存在しないため、そこへの遷移は考慮できません。'
          },
          {
            id: 'q-004-8-b',
            text: '現在の状態から遷移が定義されていない状態への移動を試みること',
            isCorrect: true,
            explanation: '不正な遷移とは、現在の状態からは許可されていない（遷移が定義されていない）状態への移動を試みることです。'
          },
          {
            id: 'q-004-8-c',
            text: '状態遷移図に記載されていない新しい状態の追加',
            isCorrect: false,
            explanation: 'テスト中に新しい状態を追加することはテストの範囲外です。'
          },
          {
            id: 'q-004-8-d',
            text: 'テスト実行中にシステムを再起動すること',
            isCorrect: false,
            explanation: 'システムの再起動自体は不正な遷移ではなく、テスト環境の操作です。'
          }
        ],
        explanation: '状態遷移テストにおける「不正な遷移」とは、現在の状態から遷移が定義されていない（許可されていない）状態への移動を試みることです。例えば、注文システムで「配送情報入力」状態から「注文完了」状態へ直接移動しようとする（「支払い情報入力」と「注文確認」をスキップする）などが不正な遷移になります。不正な遷移をテストすることで、システムが適切にエラーを処理し、不正な状態遷移を防止できることを確認します。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-004-9',
        questionText: '注文システムの状態遷移テストで、以下のテストケースのうち「異常系」をテストするものはどれですか？',
        options: [
          {
            id: 'q-004-9-a',
            text: 'カート → 配送情報入力 → 支払い情報入力 → 注文確認 → 注文完了',
            isCorrect: false,
            explanation: 'これは正常系のフローであり、異常系ではありません。'
          },
          {
            id: 'q-004-9-b',
            text: '配送情報入力画面で不正な郵便番号を入力し、エラーメッセージが表示されることを確認する',
            isCorrect: true,
            explanation: 'これは不正な入力に対するシステムの反応をテストする異常系のテストケースです。'
          },
          {
            id: 'q-004-9-c',
            text: 'カート → 配送情報入力 → カート → 配送情報入力 → 支払い情報入力',
            isCorrect: false,
            explanation: 'これは「戻る」機能をテストする通常の操作フローであり、異常系ではありません。'
          },
          {
            id: 'q-004-9-d',
            text: '支払い情報入力 → 注文確認 → 支払い情報入力 → 注文確認 → 注文完了',
            isCorrect: false,
            explanation: 'これは「戻る」と「次へ」の機能をテストする通常の操作フローであり、異常系ではありません。'
          }
        ],
        explanation: '状態遷移テストにおける「異常系」のテストケースとは、システムが例外的な状況や不正な入力に対して適切に対応するかをテストするケースです。例えば、必須フィールドを空のままにする、不正なデータ形式を入力する、存在しない値を入力するなどが異常系のテストになります。選択肢の中では、「配送情報入力画面で不正な郵便番号を入力し、エラーメッセージが表示されることを確認する」が異常系のテストケースです。これにより、システムが不正な入力を適切に検出し、ユーザーに通知できることを確認します。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-004-10',
        questionText: '状態遷移テストを実施する際の効果的なアプローチはどれですか？',
        options: [
          {
            id: 'q-004-10-a',
            text: 'すべての可能な状態遷移の組み合わせを網羅的にテストする',
            isCorrect: false,
            explanation: '状態と遷移が多い場合、すべての組み合わせをテストすることは現実的ではなく、効率的なテスト戦略が必要です。'
          },
          {
            id: 'q-004-10-b',
            text: 'ランダムに状態遷移を選んでテストする',
            isCorrect: false,
            explanation: 'ランダムなテストでは重要な遷移が漏れる可能性があります。'
          },
          {
            id: 'q-004-10-c',
            text: '最も使用頻度の高い遷移パスと重要な異常系シナリオを優先してテストする',
            isCorrect: true,
            explanation: '効率的なテスト戦略では、使用頻度の高いパスと重要な異常系シナリオを優先します。'
          },
          {
            id: 'q-004-10-d',
            text: '最も実装が複雑な状態のみをテストする',
            isCorrect: false,
            explanation: '特定の状態のみをテストするのでは、状態間の遷移に関する問題を見逃す可能性があります。'
          }
        ],
        explanation: '状態遷移テストを効果的に実施するためには、以下のようなアプローチが有効です：\n1. 最も使用頻度の高い遷移パス（正常系のフロー）を優先的にテストする\n2. 重要な異常系シナリオ（エラー処理、不正入力など）をテストする\n3. すべての状態とすべての遷移が少なくとも1回はテストされるようにする（0-スイッチカバレッジ）\n4. リスクの高い遷移（例：支払い処理など）を重点的にテストする\n5. 「戻る」操作や「キャンセル」操作など、通常と異なるフローもテストする\n\nこのバランスの取れたアプローチにより、テスト工数を効率的に使いながら重要な問題を検出することができます。',
        difficulty: 'easy',
        points: 5
      }
    ],
    techniqueName: '状態遷移テスト',
    techniqueId: 'state-transition',
    categoryId: 'blackbox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '25分'
  },
  {
    id: 'ex-005',
    title: '命令網羅テストの演習',
    description: '命令網羅（Statement Coverage）テスト技法を使った実践演習です。',
    objective: 'この演習では、ソースコード内のすべての命令が少なくとも1回実行されるようなテストケースを設計する方法を学びます。',
    scenarioDescription: 
      'あなたはチームの品質保証エンジニアとして、以下の関数をテストする任務を与えられました：\n\n' +
      '```javascript\n' +
      'function calculateDiscount(amount, customerType, loyaltyYears) {\n' +
      '  let discount = 0;\n' +
      '  \n' +
      '  if (amount >= 1000) {\n' +
      '    discount = amount * 0.05; // 5%割引\n' +
      '  }\n' +
      '  \n' +
      '  if (customerType === "premium") {\n' +
      '    discount += amount * 0.1; // さらに10%割引\n' +
      '  } else if (customerType === "standard" && loyaltyYears > 2) {\n' +
      '    discount += amount * 0.05; // さらに5%割引\n' +
      '  }\n' +
      '  \n' +
      '  if (discount > amount * 0.2) {\n' +
      '    discount = amount * 0.2; // 最大割引は20%まで\n' +
      '  }\n' +
      '  \n' +
      '  return discount;\n' +
      '}\n' +
      '```\n\n' +
      'この関数に対して命令網羅（すべての命令を少なくとも1回実行する）を達成するテストケースを設計してください。',
    steps: [
      {
        stepNumber: 1,
        description: 'コードを分析し、実行可能なすべての命令（ステートメント）を特定する'
      },
      {
        stepNumber: 2,
        description: '各命令を少なくとも1回実行するテストケースを設計する'
      },
      {
        stepNumber: 3,
        description: 'テストケースが命令網羅を達成できているか確認する'
      },
      {
        stepNumber: 4,
        description: '必要に応じてテストケースを追加または最適化する'
      }
    ],
    quiz: [
      {
        id: 'q-005-1',
        questionText: '命令網羅（Statement Coverage）とは何ですか？',
        options: [
          {
            id: 'q-005-1-a',
            text: 'すべての条件分岐（true/false）を少なくとも1回テストすること',
            isCorrect: false,
            explanation: 'これは分岐網羅（Branch Coverage）の説明であり、命令網羅ではありません。'
          },
          {
            id: 'q-005-1-b',
            text: 'すべての命令（ステートメント）が少なくとも1回実行されるようにテストすること',
            isCorrect: true,
            explanation: '命令網羅とは、プログラム内のすべての命令（ステートメント）が少なくとも1回実行されるようにテストすることです。'
          },
          {
            id: 'q-005-1-c',
            text: 'すべての関数やメソッドが少なくとも1回呼び出されるようにテストすること',
            isCorrect: false,
            explanation: 'これは関数網羅（Function Coverage）の説明であり、命令網羅ではありません。'
          },
          {
            id: 'q-005-1-d',
            text: 'コード内のすべての可能なパスを少なくとも1回テストすること',
            isCorrect: false,
            explanation: 'これはパス網羅（Path Coverage）の説明であり、命令網羅ではありません。'
          }
        ],
        explanation: '命令網羅（Statement Coverage）とは、プログラム内のすべての命令（ステートメント）が少なくとも1回実行されるようにテストすることです。これはホワイトボックステストの最も基本的なカバレッジ基準の1つで、コードの各行が少なくとも1回実行されることを確認します。命令網羅は100%達成しても、すべてのバグが検出されるわけではありませんが、明らかに実行されない「デッドコード」を検出するのに役立ちます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-005-2',
        questionText: '上記のcalculateDiscount関数に対する命令網羅を達成するために最低限必要なテストケースの数はいくつですか？',
        options: [
          {
            id: 'q-005-2-a',
            text: '1つ',
            isCorrect: false,
            explanation: '1つのテストケースでは、すべての分岐を通ることができず、すべての命令を網羅できません。'
          },
          {
            id: 'q-005-2-b',
            text: '2つ',
            isCorrect: true,
            explanation: '適切に設計された2つのテストケースで、この関数のすべての命令を網羅することができます。'
          },
          {
            id: 'q-005-2-c',
            text: '3つ',
            isCorrect: false,
            explanation: '3つのテストケースも可能ですが、最低限必要なのは2つです。'
          },
          {
            id: 'q-005-2-d',
            text: '4つ',
            isCorrect: false,
            explanation: '4つのテストケースは必要以上であり、最低限必要なのは2つです。'
          }
        ],
        explanation: 'calculateDiscount関数の命令網羅を達成するには、最低限2つのテストケースが必要です。例えば：\n1. amount=2000, customerType="premium", loyaltyYears=0 → 最初のif文（amount >= 1000）と2番目のif文のpremiumの分岐、最後のif文（割引上限）の命令を実行\n2. amount=500, customerType="standard", loyaltyYears=3 → 最初のif文をスキップし、2番目のif文のstandard && loyaltyYears > 2の分岐、最後のif文をスキップする命令を実行\nこの2つのテストケースで、関数内のすべての命令が少なくとも1回実行されます。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-005-3',
        questionText: '以下のコードの命令網羅率を100%にするために必要なテストケースを選択してください：\n\n```javascript\nfunction processAge(age) {\n  if (age < 0) {\n    return "無効な年齢";\n  }\n  if (age < 20) {\n    return "未成年";\n  }\n  return "成人";\n}\n```',
        options: [
          {
            id: 'q-005-3-a',
            text: 'age = 30 のみをテスト',
            isCorrect: false,
            explanation: 'このテストケースでは「age < 0」と「age < 20」の条件がどちらもfalseになるため、2つのif文の中の命令は実行されません。'
          },
          {
            id: 'q-005-3-b',
            text: 'age = -5 と age = 30 をテスト',
            isCorrect: false,
            explanation: 'これらのテストケースでは「age < 20」の条件がtrueになる場合が含まれていないため、2番目のif文の中の命令が実行されません。'
          },
          {
            id: 'q-005-3-c',
            text: 'age = 15 と age = 30 をテスト',
            isCorrect: false,
            explanation: 'これらのテストケースでは「age < 0」の条件がtrueになる場合が含まれていないため、最初のif文の中の命令が実行されません。'
          },
          {
            id: 'q-005-3-d',
            text: 'age = -5, age = 15, age = 30 をテスト',
            isCorrect: true,
            explanation: 'これらのテストケースでは、すべての条件分岐と命令が少なくとも1回実行されます。'
          }
        ],
        explanation: 'processAge関数の命令網羅率を100%にするには、以下の3つのパスをすべてテストする必要があります：\n1. age < 0 の場合（例：age = -5）→ "無効な年齢"を返す\n2. age >= 0 かつ age < 20 の場合（例：age = 15）→ "未成年"を返す\n3. age >= 20 の場合（例：age = 30）→ "成人"を返す\nこれら3つのテストケースで、関数内のすべての命令が少なくとも1回実行されます。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-005-4',
        questionText: '命令網羅テストの限界は何ですか？',
        options: [
          {
            id: 'q-005-4-a',
            text: '実行速度が非常に遅く、大規模なアプリケーションでは使用できない',
            isCorrect: false,
            explanation: '命令網羅テスト自体が特別に遅いわけではなく、テストの実行速度はテスト対象のコードとテスト方法によります。'
          },
          {
            id: 'q-005-4-b',
            text: '特殊なツールが必要で、一般的なテスト環境では実施できない',
            isCorrect: false,
            explanation: '命令網羅テストは一般的なテスト環境でも実施でき、多くのテストカバレッジツールでサポートされています。'
          },
          {
            id: 'q-005-4-c',
            text: '条件の組み合わせによるバグを検出できない場合がある',
            isCorrect: true,
            explanation: '命令網羅テストは各命令が実行されることを確認するだけで、条件の組み合わせによるバグを検出できない場合があります。'
          },
          {
            id: 'q-005-4-d',
            text: 'レガシーコードには適用できない',
            isCorrect: false,
            explanation: '命令網羅テストはレガシーコードを含む任意のコードに適用できます。'
          }
        ],
        explanation: '命令網羅テストの主な限界は、すべての命令が実行されていることを確認するだけで、条件の組み合わせや実行パスによるバグを検出できない場合があることです。例えば、以下のようなコードでは：\n```javascript\nif (a && b) {\n  doSomething();\n}\n```\na=true, b=falseのテストケースでdoSomething()が実行されなくても、命令網羅率は高くなります。しかし、a=true, b=trueのケースでバグが発生する可能性があります。このような条件の組み合わせによるバグを検出するには、分岐網羅や条件網羅などのより高度なカバレッジ基準が必要です。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-005-5',
        questionText: '以下のコードで命令網羅を達成するテストケースはどれですか？\n\n```javascript\nfunction getGrade(score) {\n  if (score < 0 || score > 100) {\n    return "無効な点数";\n  }\n  \n  if (score >= 90) {\n    return "A";\n  } else if (score >= 80) {\n    return "B";\n  } else if (score >= 70) {\n    return "C";\n  } else if (score >= 60) {\n    return "D";\n  } else {\n    return "F";\n  }\n}\n```',
        options: [
          {
            id: 'q-005-5-a',
            text: 'score = -10, score = 95, score = 85, score = 75, score = 65, score = 55',
            isCorrect: true,
            explanation: 'これらのテストケースでは、無効な点数、A、B、C、D、Fのすべての分岐が実行され、すべての命令が網羅されます。'
          },
          {
            id: 'q-005-5-b',
            text: 'score = 95, score = 85, score = 75, score = 65, score = 55',
            isCorrect: false,
            explanation: 'これらのテストケースでは、無効な点数の分岐が実行されないため、すべての命令が網羅されません。'
          },
          {
            id: 'q-005-5-c',
            text: 'score = -10, score = 110, score = 90, score = 80, score = 70, score = 60',
            isCorrect: false,
            explanation: 'これらのテストケースでは、score = 60のケースでは「D」を返す分岐が実行されますが、「F」を返す分岐が実行されないため、すべての命令が網羅されません。'
          },
          {
            id: 'q-005-5-d',
            text: 'score = 0, score = 100',
            isCorrect: false,
            explanation: 'これらのテストケースでは、score = 0は「F」を返し、score = 100は「A」を返しますが、「B」「C」「D」を返す分岐や無効な点数の分岐が実行されないため、すべての命令が網羅されません。'
          }
        ],
        explanation: 'getGrade関数の命令網羅を達成するには、以下のすべての分岐を実行する必要があります：\n1. 無効な点数のケース（例：score = -10）\n2. A評価のケース（例：score = 95）\n3. B評価のケース（例：score = 85）\n4. C評価のケース（例：score = 75）\n5. D評価のケース（例：score = 65）\n6. F評価のケース（例：score = 55）\nこれらの6つのテストケースで、関数内のすべての命令が少なくとも1回実行されます。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-005-6',
        questionText: '命令網羅テストの計測方法として正しいのはどれですか？',
        options: [
          {
            id: 'q-005-6-a',
            text: '実行された命令数 ÷ ソースコードの総行数 × 100',
            isCorrect: false,
            explanation: 'ソースコードの総行数にはコメントや空行も含まれるため、これは正確な命令網羅率の計算方法ではありません。'
          },
          {
            id: 'q-005-6-b',
            text: '実行された命令数 ÷ 実行可能な命令の総数 × 100',
            isCorrect: true,
            explanation: 'これが命令網羅率の正確な計算方法です。実行された命令数を実行可能な命令の総数で割り、100を掛けて百分率で表します。'
          },
          {
            id: 'q-005-6-c',
            text: 'テストケースの数 ÷ プログラム内の条件分岐の数 × 100',
            isCorrect: false,
            explanation: 'これは命令網羅率の計算方法ではなく、テストケースと条件分岐の比率を表しています。'
          },
          {
            id: 'q-005-6-d',
            text: '発見されたバグの数 ÷ テストケースの数 × 100',
            isCorrect: false,
            explanation: 'これはバグ検出効率を表す指標であり、命令網羅率の計算方法ではありません。'
          }
        ],
        explanation: '命令網羅率（Statement Coverage）は、以下の式で計算されます：\n\n命令網羅率(%) = (実行された命令数 ÷ 実行可能な命令の総数) × 100\n\n例えば、プログラムに100の実行可能な命令があり、テスト実行中に80の命令が実行された場合、命令網羅率は80%です。この測定にはカバレッジツール（JaCoCoやIstanbulなど）が使用されます。これらのツールは、実行されたコードを追跡し、どの命令が実行されたかを報告します。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-005-7',
        questionText: '命令網羅を100%達成した場合、以下のうち正しい説明はどれですか？',
        options: [
          {
            id: 'q-005-7-a',
            text: 'プログラム内のすべてのバグが検出される',
            isCorrect: false,
            explanation: '命令網羅が100%でも、条件の組み合わせや特定の実行パスに関連するバグは検出されない可能性があります。'
          },
          {
            id: 'q-005-7-b',
            text: 'コード内の各命令が少なくとも1回実行されている',
            isCorrect: true,
            explanation: '命令網羅が100%とは、まさにコード内の各命令が少なくとも1回実行されていることを意味します。'
          },
          {
            id: 'q-005-7-c',
            text: 'すべての条件分岐（true/false）が網羅されている',
            isCorrect: false,
            explanation: '命令網羅が100%でも、すべての条件分岐が網羅されているとは限りません。これは分岐網羅に関する説明です。'
          },
          {
            id: 'q-005-7-d',
            text: 'プログラムの品質が完璧であることが保証される',
            isCorrect: false,
            explanation: '命令網羅は基本的なコードカバレッジ指標の1つにすぎず、プログラムの品質を完全に保証するものではありません。'
          }
        ],
        explanation: '命令網羅を100%達成したということは、プログラム内のすべての実行可能な命令が少なくとも1回実行されたことを意味します。これはコードの基本的な実行可能性を確認する重要な指標ですが、以下の理由から、すべてのバグが検出されるわけではありません：\n\n1. 複雑な条件の組み合わせによるバグは検出されない可能性がある\n2. 並行処理の問題（競合状態など）は検出されない\n3. 特定のデータ値や境界条件に関連するバグは見逃される可能性がある\n4. 命令が実行されても、その結果が正しいかどうかは命令網羅テストでは検証されない\n\n命令網羅は基本的なテスト網羅基準であり、他のテスト技法と組み合わせて使用することが重要です。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-005-8',
        questionText: '以下のコードに対する命令網羅テストで見逃す可能性が高いバグはどれですか？\n\n```javascript\nfunction divideNumbers(a, b) {\n  if (b !== 0) {\n    return a / b;\n  } else {\n    return "エラー: ゼロでの除算";\n  }\n}\n```',
        options: [
          {
            id: 'q-005-8-a',
            text: 'b = 0の場合のゼロ除算エラー',
            isCorrect: false,
            explanation: 'このコードではb = 0の場合は明示的に処理されており、命令網羅テストでカバーされます。'
          },
          {
            id: 'q-005-8-b',
            text: 'a = 0の場合の戻り値が0になるケース',
            isCorrect: false,
            explanation: 'a = 0の場合は数学的に正しく0を返すはずであり、これはバグではありません。'
          },
          {
            id: 'q-005-8-c',
            text: 'b = null または undefined の場合の不適切な結果',
            isCorrect: true,
            explanation: 'b = null または undefined の場合、「b !== 0」は true になりますが、その後の除算でエラーが発生する可能性があります。命令網羅テストでは通常このようなケースはテストされません。'
          },
          {
            id: 'q-005-8-d',
            text: 'a と b が両方とも0の場合のエラー',
            isCorrect: false,
            explanation: 'a = 0, b = 0の場合は「b !== 0」の条件で false となり、"エラー: ゼロでの除算"が返されます。これは適切な処理であり、命令網羅テストでカバーされます。'
          }
        ],
        explanation: '命令網羅テストは、各命令が少なくとも1回実行されることを確認するだけで、すべての入力値や特殊なケースをテストするわけではありません。この例では、以下の2つのテストケースで命令網羅を達成できます：\n1. a = 10, b = 2 → 「b !== 0」が true で、a / b = 5 を返す\n2. a = 10, b = 0 → 「b !== 0」が false で、"エラー: ゼロでの除算" を返す\n\nしかし、b = null または undefined などの特殊なケースはテストされない可能性があります。JavaScript では「null !== 0」と「undefined !== 0」は true になるため、条件分岐は通過しますが、その後の「a / null」や「a / undefined」は「NaN」を返します。これはバグとなる可能性がありますが、命令網羅テストだけでは見逃される可能性が高いです。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-005-9',
        questionText: '命令網羅と分岐網羅の違いを最もよく説明しているのはどれですか？',
        options: [
          {
            id: 'q-005-9-a',
            text: '命令網羅はすべての命令が実行されることを確認し、分岐網羅はすべての条件分岐（true/false）が実行されることを確認する',
            isCorrect: true,
            explanation: 'これが命令網羅と分岐網羅の主な違いです。分岐網羅は条件式のすべての結果（trueとfalse）を網羅するのに対し、命令網羅は各命令が少なくとも1回実行されることを確認します。'
          },
          {
            id: 'q-005-9-b',
            text: '命令網羅はホワイトボックステスト技法で、分岐網羅はブラックボックステスト技法である',
            isCorrect: false,
            explanation: '両方ともホワイトボックステスト技法であり、コードの内部構造に基づいています。'
          },
          {
            id: 'q-005-9-c',
            text: '命令網羅はユニットテストで使用され、分岐網羅は統合テストで使用される',
            isCorrect: false,
            explanation: '両方ともさまざまなレベルのテスト（ユニットテスト、統合テストなど）で使用できます。'
          },
          {
            id: 'q-005-9-d',
            text: '命令網羅は自動テストで使用され、分岐網羅は手動テストで使用される',
            isCorrect: false,
            explanation: '両方とも自動テストと手動テストの両方で使用できます。'
          }
        ],
        explanation: '命令網羅と分岐網羅の主な違いは以下の通りです：\n\n- 命令網羅（Statement Coverage）：プログラム内のすべての命令（ステートメント）が少なくとも1回実行されることを確認します。\n\n- 分岐網羅（Branch Coverage）：すべての条件分岐（if、switch、for文などの制御構造の各分岐）が少なくとも1回実行されることを確認します。これは条件式の結果がtrue/falseの両方のケースを含みます。\n\n例えば、以下のコードでは：\n```javascript\nif (a > b) {\n  return a;\n} else {\n  return b;\n}\n```\n\n命令網羅を100%達成するには、if文が実行され、どちらかの分岐が実行されれば十分です。しかし、分岐網羅を100%達成するには、a > b が true と false の両方のケースをテストする必要があります。分岐網羅は通常、命令網羅よりも厳格なカバレッジ基準です。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-005-10',
        questionText: 'テストで命令網羅を考慮すべき主な理由は何ですか？',
        options: [
          {
            id: 'q-005-10-a',
            text: 'テストケースを削減し、テスト工数を最小化するため',
            isCorrect: false,
            explanation: '命令網羅は通常テストケースを増やす効果があり、工数を最小化するためのものではありません。'
          },
          {
            id: 'q-005-10-b',
            text: 'バグを100%検出するため',
            isCorrect: false,
            explanation: '命令網羅はバグを100%検出することを保証するものではありません。'
          },
          {
            id: 'q-005-10-c',
            text: '使用されていないコード（デッドコード）を検出するため',
            isCorrect: true,
            explanation: '命令網羅を測定することで、テストによって実行されていないコード（デッドコードや到達不能コード）を特定できます。'
          },
          {
            id: 'q-005-10-d',
            text: 'コードの実行時間を測定するため',
            isCorrect: false,
            explanation: '命令網羅はコードの実行時間を測定するためのものではありません。'
          }
        ],
        explanation: '命令網羅を考慮する主な理由の1つは、使用されていないコード（デッドコード）や到達不能なコードを検出するためです。命令網羅率が低い場合、それはテストによって実行されていないコードが存在することを示します。これは以下のような理由で問題となる可能性があります：\n\n1. テストされていないコードにバグが潜んでいる可能性がある\n2. 実際には必要のないコードがプログラムに含まれている（コード肥大化）\n3. 条件分岐に論理エラーがあり、特定のコードに到達できない\n\n命令網羅は基本的なコードカバレッジ指標であり、他のテスト技法と組み合わせることで、より包括的なテスト戦略を構築できます。',
        difficulty: 'easy',
        points: 5
      }
    ],
    techniqueName: '命令網羅',
    techniqueId: 'statement-coverage',
    categoryId: 'whitebox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '25分'
  },
  {
    id: 'ex-006',
    title: '分岐網羅テストの演習',
    description: '分岐網羅（Branch Coverage）テスト技法を使った実践演習です。',
    objective: 'この演習では、プログラムのすべての条件分岐（true/false）を少なくとも1回実行するテストケースを設計する方法を学びます。',
    scenarioDescription: 
      'あなたはソフトウェア開発会社のQAエンジニアとして、以下の関数をテストする任務を与えられました：\n\n' +
      '```javascript\n' +
      'function calculateInsurance(age, hasMedicalCondition, yearsWithCompany) {\n' +
      '  let premium = 5000; // 基本保険料\n' +
      '  \n' +
      '  if (age < 25) {\n' +
      '    premium += 1500; // 若年層リスク追加\n' +
      '  } else if (age >= 65) {\n' +
      '    premium += 2000; // 高齢層リスク追加\n' +
      '  }\n' +
      '  \n' +
      '  if (hasMedicalCondition) {\n' +
      '    premium *= 1.5; // 健康状態による増額\n' +
      '  }\n' +
      '  \n' +
      '  // 長期顧客割引\n' +
      '  if (yearsWithCompany > 5) {\n' +
      '    premium *= 0.9; // 10%割引\n' +
      '  } else if (yearsWithCompany > 2) {\n' +
      '    premium *= 0.95; // 5%割引\n' +
      '  }\n' +
      '  \n' +
      '  return premium;\n' +
      '}\n' +
      '```\n\n' +
      'この関数に対して分岐網羅（すべての条件分岐のtrue/falseの結果が少なくとも1回実行される）を達成するテストケースを設計してください。',
    steps: [
      {
        stepNumber: 1,
        description: 'コードを分析し、すべての条件分岐を特定する'
      },
      {
        stepNumber: 2,
        description: '各条件分岐のtrueとfalseの結果を少なくとも1回実行するテストケースを設計する'
      },
      {
        stepNumber: 3,
        description: 'テストケースが分岐網羅を達成できているか確認する'
      },
      {
        stepNumber: 4,
        description: '必要に応じてテストケースを追加または最適化する'
      }
    ],
    quiz: [
      {
        id: 'q-006-1',
        questionText: '分岐網羅（Branch Coverage）テストとは何ですか？',
        options: [
          {
            id: 'q-006-1-a',
            text: 'プログラム内のすべての命令が少なくとも1回実行されるようにテストすること',
            isCorrect: false,
            explanation: 'これは命令網羅（Statement Coverage）の説明です。'
          },
          {
            id: 'q-006-1-b',
            text: 'プログラム内のすべての条件分岐（true/false）が少なくとも1回実行されるようにテストすること',
            isCorrect: true,
            explanation: '分岐網羅は、if、switch、whileなどの制御構造のすべての条件分岐（trueとfalseの両方の結果）が少なくとも1回実行されることを確認するテスト手法です。'
          },
          {
            id: 'q-006-1-c',
            text: 'プログラム内のすべての可能なパスが実行されるようにテストすること',
            isCorrect: false,
            explanation: 'これはパス網羅（Path Coverage）の説明です。すべての可能なパスをテストすることは、複雑なプログラムでは現実的でない場合が多いです。'
          },
          {
            id: 'q-006-1-d',
            text: 'プログラム内のすべての関数が少なくとも1回呼び出されるようにテストすること',
            isCorrect: false,
            explanation: 'これは関数網羅（Function Coverage）の説明です。'
          }
        ],
        explanation: '分岐網羅（Branch Coverage）は、プログラム内のすべての条件分岐が少なくとも1回実行されることを確認するホワイトボックステスト技法です。例えば、if (condition)文がある場合、conditionがtrueになるケースとfalseになるケースの両方をテストします。これにより、条件分岐に関連するバグを見つけやすくなります。分岐網羅は命令網羅よりも厳格なテスト基準であり、より多くのテストケースが必要になる場合があります。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-006-2',
        questionText: '上記のcalculateInsurance関数の分岐網羅を達成するために必要なテストケースの最小数はいくつですか？',
        options: [
          {
            id: 'q-006-2-a',
            text: '3つ',
            isCorrect: false,
            explanation: '3つのテストケースでは、すべての条件分岐（trueとfalse）を網羅することはできません。'
          },
          {
            id: 'q-006-2-b',
            text: '4つ',
            isCorrect: true,
            explanation: '適切に設計された4つのテストケースで、この関数のすべての条件分岐を網羅することができます。'
          },
          {
            id: 'q-006-2-c',
            text: '6つ',
            isCorrect: false,
            explanation: '6つのテストケースは必要以上です。最小数は4つです。'
          },
          {
            id: 'q-006-2-d',
            text: '8つ',
            isCorrect: false,
            explanation: '8つのテストケースは必要以上です。最小数は4つです。'
          }
        ],
        explanation: 'calculateInsurance関数の分岐網羅を達成するには、以下の条件分岐をすべてカバーする必要があります：\n1. age < 25 (true/false)\n2. age >= 65 (true/false、ただしage < 25がfalseの場合のみ関連)\n3. hasMedicalCondition (true/false)\n4. yearsWithCompany > 5 (true/false)\n5. yearsWithCompany > 2 (true/false、ただしyearsWithCompany > 5がfalseの場合のみ関連)\n\nこれらをカバーする最小のテストケースセットは4つです：\n例：\n- TC1: age=20, hasMedicalCondition=true, yearsWithCompany=6 (age<25=true, hasMedicalCondition=true, yearsWithCompany>5=true)\n- TC2: age=30, hasMedicalCondition=false, yearsWithCompany=3 (age<25=false, age>=65=false, hasMedicalCondition=false, yearsWithCompany>5=false, yearsWithCompany>2=true)\n- TC3: age=70, hasMedicalCondition=true, yearsWithCompany=1 (age<25=false, age>=65=true, hasMedicalCondition=true, yearsWithCompany>5=false, yearsWithCompany>2=false)\n- TC4: age=30, hasMedicalCondition=false, yearsWithCompany=1 (yearsWithCompany>2=falseをカバー)',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-006-3',
        questionText: '次のコードの分岐網羅率を100%にするためには、どのようなテストケースが必要ですか？\n\n```javascript\nfunction validatePassword(password) {\n  if (!password || password.length < 8) {\n    return "パスワードは8文字以上必要です";\n  }\n  \n  if (!/[A-Z]/.test(password)) {\n    return "パスワードは少なくとも1つの大文字を含む必要があります";\n  }\n  \n  if (!/[0-9]/.test(password)) {\n    return "パスワードは少なくとも1つの数字を含む必要があります";\n  }\n  \n  return "パスワードは有効です";\n}\n```',
        options: [
          {
            id: 'q-006-3-a',
            text: 'password = "Password1" のみ',
            isCorrect: false,
            explanation: 'このテストケースではすべての条件がfalseになるため、trueの場合の分岐が実行されません。'
          },
          {
            id: 'q-006-3-b',
            text: 'password = "short", password = "Password1"',
            isCorrect: false,
            explanation: 'これらのテストケースでは、!/[0-9]/.test(password)がtrueになる分岐がカバーされていません。'
          },
          {
            id: 'q-006-3-c',
            text: 'password = null, password = "short", password = "password1", password = "PASSWORD", password = "Password1"',
            isCorrect: true,
            explanation: 'これらのテストケースはすべての条件分岐をカバーしています。'
          },
          {
            id: 'q-006-3-d',
            text: 'password = "short", password = "longpassword", password = "UPPERCASE", password = "12345678"',
            isCorrect: false,
            explanation: 'これらのテストケースでは、パスワードがnullまたは未定義の場合の分岐がカバーされていません。'
          }
        ],
        explanation: 'validatePassword関数の分岐網羅率を100%にするには、以下のすべての条件分岐をカバーする必要があります：\n\n1. !password || password.length < 8 (true/false)\n   - trueの場合：password = null または password = "short"\n   - falseの場合：password = "password1"など8文字以上\n\n2. !/[A-Z]/.test(password) (true/false、最初の条件がfalseの場合のみ実行)\n   - trueの場合：password = "password1" (大文字なし)\n   - falseの場合：password = "Password1"など大文字あり\n\n3. !/[0-9]/.test(password) (true/false、最初と2番目の条件がfalseの場合のみ実行)\n   - trueの場合：password = "Password" (数字なし)\n   - falseの場合：password = "Password1"など数字あり\n\nすべての分岐をカバーするには、少なくとも次のようなテストケースが必要です：\n- password = null（または未定義）：最初の条件のtrueをカバー\n- password = "short"：最初の条件のtrueをカバー（別の方法で）\n- password = "password1"：最初の条件のfalse、2番目の条件のtrueをカバー\n- password = "PASSWORD"：最初と2番目の条件のfalse、3番目の条件のtrueをカバー\n- password = "Password1"：すべての条件のfalseをカバー',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-006-4',
        questionText: '複合条件を含むif文の分岐網羅テストに関する説明として正しいのはどれですか？',
        options: [
          {
            id: 'q-006-4-a',
            text: '複合条件（a && b）は一つの条件として扱い、trueとfalseの2つの分岐のみをテストすればよい',
            isCorrect: false,
            explanation: 'これは単純な分岐網羅の考え方ですが、複合条件の場合は不十分です。複合条件の各部分の組み合わせをテストする必要があります。'
          },
          {
            id: 'q-006-4-b',
            text: '複合条件（a && b）の場合、分岐網羅を達成するには少なくとも3つのテストケースが必要である',
            isCorrect: true,
            explanation: '複合条件a && bの分岐網羅を達成するには、(true, true)、(false, *)、(true, false)の少なくとも3つのケースが必要です。ただし、条件の評価が短絡評価される言語では、(false, *)のケースで2番目の条件は評価されないことがあります。'
          },
          {
            id: 'q-006-4-c',
            text: '複合条件は各部分を個別の条件として分解し、それぞれを独立してテストするべきである',
            isCorrect: false,
            explanation: '各部分を独立してテストするだけでは不十分で、複合条件が全体としてどのように評価されるかをテストする必要があります。'
          },
          {
            id: 'q-006-4-d',
            text: 'if (a && b) {...} else {...}の分岐網羅テストは、単純なif (condition) {...} else {...}と同じように2つのテストケースで達成できる',
            isCorrect: false,
            explanation: '複合条件の場合、単純な条件より多くのテストケースが必要です。a && bの場合、少なくとも3つのテストケースが必要です。'
          }
        ],
        explanation: '複合条件（例：a && b）を含むif文の分岐網羅テストでは、単に条件全体がtrueまたはfalseになるケースをテストするだけでは不十分です。条件の各部分が結果にどのように影響するかを考慮する必要があります。\n\n例えば、if (a && b) {...}の場合：\n\n1. a=true, b=trueのとき、条件全体はtrueになる\n2. a=false, b=任意の値のとき、条件全体はfalseになる（短絡評価により、bは評価されない可能性がある）\n3. a=true, b=falseのとき、条件全体はfalseになる\n\nこれらの3つのケースをテストすることで、複合条件の分岐網羅が達成されます。ORの条件（a || b）も同様に考えることができます。\n\nこのように、複合条件を含むif文の分岐網羅テストでは、条件の各部分の組み合わせを考慮する必要があり、単純な条件よりも多くのテストケースが必要になります。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-006-5',
        questionText: '次のコードの分岐網羅テストに必要なテストケースの最小数はいくつですか？\n\n```javascript\nfunction checkEligibility(age, income, creditScore) {\n  if (age >= 18 && age <= 65) {\n    if (income >= 30000 || creditScore >= 700) {\n      return "適格";\n    }\n  }\n  return "不適格";\n}\n```',
        options: [
          {
            id: 'q-006-5-a',
            text: '2つ',
            isCorrect: false,
            explanation: '2つのテストケースでは、すべての条件分岐をカバーすることはできません。'
          },
          {
            id: 'q-006-5-b',
            text: '3つ',
            isCorrect: false,
            explanation: '3つのテストケースでは、すべての条件分岐をカバーすることはできません。'
          },
          {
            id: 'q-006-5-c',
            text: '4つ',
            isCorrect: true,
            explanation: '適切に設計された4つのテストケースで、この関数のすべての条件分岐をカバーすることができます。'
          },
          {
            id: 'q-006-5-d',
            text: '5つ',
            isCorrect: false,
            explanation: '5つのテストケースは必要以上です。最小数は4つです。'
          }
        ],
        explanation: 'checkEligibility関数の分岐網羅を達成するには、以下の条件分岐をすべてカバーする必要があります：\n\n1. age >= 18 && age <= 65 (true/false)\n   - true: 18 <= age <= 65\n   - false: age < 18 または age > 65\n\n2. income >= 30000 || creditScore >= 700 (true/false、最初の条件がtrueの場合のみ実行)\n   - true: income >= 30000 または creditScore >= 700\n   - false: income < 30000 かつ creditScore < 700\n\nこれらをカバーする最小のテストケースセットは4つです：\n\n1. age = 17, income = 任意, creditScore = 任意 (age >= 18 && age <= 65がfalseになるケース、age < 18)\n2. age = 70, income = 任意, creditScore = 任意 (age >= 18 && age <= 65がfalseになるケース、age > 65)\n3. age = 30, income = 35000, creditScore = 650 (age >= 18 && age <= 65がtrue、income >= 30000 || creditScore >= 700がtrueになるケース、income >= 30000)\n4. age = 30, income = 25000, creditScore = 650 (age >= 18 && age <= 65がtrue、income >= 30000 || creditScore >= 700がfalseになるケース)\n\n注: 3番目のテストケースは、income >= 30000がtrueでcreditScore >= 700がfalseです。同様に、age = 30, income = 25000, creditScore = 750のようなテストケース（income >= 30000がfalseでcreditScore >= 700がtrue）も作成できますが、論理和（OR）の分岐網羅には、どちらか一方がtrue、両方ともfalseの2ケースで十分です。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-006-6',
        questionText: '分岐網羅と条件網羅の違いを最もよく説明しているのはどれですか？',
        options: [
          {
            id: 'q-006-6-a',
            text: '分岐網羅はif文などの各分岐を実行するのに対し、条件網羅は複合条件の各条件の真偽をすべて組み合わせてテストする',
            isCorrect: true,
            explanation: 'これは分岐網羅と条件網羅の主な違いを正確に説明しています。条件網羅はより厳格なテスト基準です。'
          },
          {
            id: 'q-006-6-b',
            text: '分岐網羅はホワイトボックステストで、条件網羅はブラックボックステストである',
            isCorrect: false,
            explanation: '両方ともホワイトボックステスト技法です。'
          },
          {
            id: 'q-006-6-c',
            text: '分岐網羅はプログラムの全ての命令を実行し、条件網羅はすべての条件を実行する',
            isCorrect: false,
            explanation: 'これは正確ではありません。命令を実行するのは命令網羅です。分岐網羅はすべての分岐を実行します。'
          },
          {
            id: 'q-006-6-d',
            text: '分岐網羅は関数レベルで適用され、条件網羅はプログラム全体に適用される',
            isCorrect: false,
            explanation: '両方とも任意のレベル（関数、モジュール、プログラム全体）に適用できます。'
          }
        ],
        explanation: '分岐網羅と条件網羅の主な違いは以下の通りです：\n\n- 分岐網羅（Branch Coverage）：プログラム内のすべての分岐（if、while、for文などの制御構造の各分岐）が少なくとも1回実行されることを確認します。つまり、各条件の結果がtrueとfalseの両方の場合が実行されることを確認します。\n\n- 条件網羅（Condition Coverage）：複合条件の各部分が個別にtrueとfalseの両方の値を取ることを確認します。例えば、if (a && b)という条件の場合、条件網羅は以下の組み合わせをすべてテストすることを要求します：\n  * a=true, b=true\n  * a=true, b=false\n  * a=false, b=true\n  * a=false, b=false\n\n条件網羅は分岐網羅よりも厳格なテスト基準であり、より多くのテストケースが必要になります。条件の数が増えるにつれて、必要なテストケースの数は指数関数的に増加します。例えば、n個の条件がある場合、条件網羅には最大2^n個のテストケースが必要になる可能性があります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-006-7',
        questionText: '分岐網羅テストの限界に関する説明として正しいのはどれですか？',
        options: [
          {
            id: 'q-006-7-a',
            text: '分岐網羅テストは、複合条件内の個々の条件が結果に与える影響を完全に評価できない',
            isCorrect: true,
            explanation: 'これは分岐網羅テストの主な限界の1つです。複合条件内の各条件の組み合わせをすべてテストするには、条件網羅が必要です。'
          },
          {
            id: 'q-006-7-b',
            text: '分岐網羅テストは、プログラムのパフォーマンスの問題を検出できない',
            isCorrect: false,
            explanation: 'これはどのカバレッジ基準にも当てはまります。パフォーマンステストは別の種類のテストです。'
          },
          {
            id: 'q-006-7-c',
            text: '分岐網羅テストは、ユーザーインターフェースの使いやすさの問題を検出できない',
            isCorrect: false,
            explanation: 'これはどのカバレッジ基準にも当てはまります。使いやすさのテストは別の種類のテストです。'
          },
          {
            id: 'q-006-7-d',
            text: '分岐網羅テストは、オブジェクト指向プログラミングには適用できない',
            isCorrect: false,
            explanation: '分岐網羅テストはオブジェクト指向プログラミングを含むあらゆるプログラミングパラダイムに適用できます。'
          }
        ],
        explanation: '分岐網羅テストの主な限界の1つは、複合条件内の個々の条件が結果に与える影響を完全に評価できないことです。例えば、if (a && b)という条件があるとき、分岐網羅は条件全体がtrueとfalseの両方になるケースをテストしますが、aとbの個々の値のすべての組み合わせをテストするわけではありません。\n\n例えば、次のテストケースセットは分岐網羅を達成します：\n- a=true, b=true（条件全体はtrue）\n- a=false, b=true（条件全体はfalse）\n\nしかし、a=true, b=falseという組み合わせはテストされていません。この組み合わせでバグが発生する可能性があります。\n\n他の限界として、分岐網羅だけではループ内の繰り返し回数に関連するバグや、例外処理のすべてのパスをカバーできない場合があります。また、データの依存関係やタイミングの問題も検出できません。\n\nこれらの限界を克服するには、条件網羅、パス網羅、データフロー網羅などの他のテスト技法と組み合わせる必要があります。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-006-8',
        questionText: '次のコードが正しく動作するために、分岐網羅テストが特に重要な理由は何ですか？\n\n```javascript\nfunction processPayment(amount, accountBalance, isCreditCard) {\n  if (amount <= 0) {\n    return "無効な金額";\n  }\n  \n  if (!isCreditCard && amount > accountBalance) {\n    return "残高不足";\n  }\n  \n  // 支払い処理のコード...\n  \n  return "支払い完了";\n}\n```',
        options: [
          {
            id: 'q-006-8-a',
            text: '複雑なビジネスロジックが含まれているため',
            isCorrect: false,
            explanation: 'このコードのビジネスロジックは比較的単純です。'
          },
          {
            id: 'q-006-8-b',
            text: '金融トランザクションを扱うため、エラー条件のテストが重要である',
            isCorrect: true,
            explanation: '金融トランザクションを扱うコードでは、すべてのエラー条件と成功条件が適切に処理されることを確認することが重要です。分岐網羅テストはこれを達成するのに役立ちます。'
          },
          {
            id: 'q-006-8-c',
            text: 'ループを含む処理があるため',
            isCorrect: false,
            explanation: 'このコードにはループは含まれていません。'
          },
          {
            id: 'q-006-8-d',
            text: '再帰呼び出しがあるため',
            isCorrect: false,
            explanation: 'このコードには再帰呼び出しは含まれていません。'
          }
        ],
        explanation: '金融トランザクションを扱うコード（支払い処理など）では、セキュリティと正確性が非常に重要です。このようなコードでは、すべてのエラー条件が適切に検出され、処理されることを確認する必要があります。\n\n分岐網羅テストは、以下の重要な条件分岐をすべてテストすることを確実にします：\n\n1. amount <= 0 (true/false) - 無効な金額のチェック\n2. !isCreditCard && amount > accountBalance (true/false) - 残高不足のチェック\n\nこれらの条件が正しく処理されないと、以下のような問題が発生する可能性があります：\n- 負の金額での支払いが処理される\n- 残高不足の状態で支払いが処理される\n- 有効な支払いが誤って拒否される\n\n分岐網羅テストにより、これらの条件のすべての結果が適切に処理されることを確認できます。金融アプリケーションでは、このような徹底的なテストが不可欠です。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-006-9',
        questionText: '次のコードの分岐網羅テストを実施する際、見落としやすいテストケースはどれですか？\n\n```javascript\nfunction calculateShipping(weight, distance, isExpressDelivery) {\n  let cost = 0;\n  \n  if (weight <= 0 || distance <= 0) {\n    throw new Error("無効なパラメータ");\n  }\n  \n  if (weight < 5) {\n    cost = 500;\n  } else if (weight < 20) {\n    cost = 1000;\n  } else {\n    cost = 2000;\n  }\n  \n  if (distance > 100) {\n    cost += 500;\n  }\n  \n  if (isExpressDelivery) {\n    cost *= 1.5;\n  }\n  \n  return cost;\n}\n```',
        options: [
          {
            id: 'q-006-9-a',
            text: 'weight = 0, distance = 50, isExpressDelivery = false',
            isCorrect: false,
            explanation: 'これは無効なパラメータ（weight <= 0）のケースであり、明示的にチェックされています。テスターはこのケースを見落とさない可能性が高いです。'
          },
          {
            id: 'q-006-9-b',
            text: 'weight = 6, distance = 120, isExpressDelivery = true',
            isCorrect: false,
            explanation: 'これは通常のテストケースであり、見落とされる可能性は低いです。'
          },
          {
            id: 'q-006-9-c',
            text: 'weight = 5, distance = 50, isExpressDelivery = false',
            isCorrect: true,
            explanation: 'weight = 5は境界値であり、weight < 5とweight < 20の両方の条件でfalseとなります。このような境界値は見落とされやすいです。'
          },
          {
            id: 'q-006-9-d',
            text: 'weight = 25, distance = 0, isExpressDelivery = false',
            isCorrect: false,
            explanation: 'これは無効なパラメータ（distance <= 0）のケースであり、明示的にチェックされています。テスターはこのケースを見落とさない可能性が高いです。'
          }
        ],
        explanation: '分岐網羅テストでは、境界値や特殊なケースが見落とされやすいです。このコードでは、weight = 5は特に注意が必要な境界値です。\n\nweight = 5の場合：\n- weight < 5 は false\n- weight < 20 は true\n- したがって、cost = 1000が設定されます\n\nこの境界値をテストしないと、例えばプログラマーが誤って weight <= 5 と書いてしまった場合、バグを見逃す可能性があります。\n\n他にも以下のような境界値があります：\n- weight = 20: weight < 20 の境界値\n- distance = 100: distance > 100 の境界値\n\n分岐網羅テストを行う際は、単に各条件のtrueとfalseをテストするだけでなく、このような境界値も考慮することが重要です。テスターはしばしば「明白な」テストケース（非常に小さい値、非常に大きい値など）に集中し、境界値を見落とすことがあります。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-006-10',
        questionText: '分岐網羅テストを自動化する際の最適なアプローチはどれですか？',
        options: [
          {
            id: 'q-006-10-a',
            text: '手動でテストケースを作成し、それらを自動テストフレームワークで実行する',
            isCorrect: false,
            explanation: 'これは可能なアプローチですが、分岐網羅テストの自動化には最適ではありません。大規模なコードベースでは非効率的です。'
          },
          {
            id: 'q-006-10-b',
            text: 'カバレッジツールを使用して分岐網羅率を測定し、不足している分岐を特定する',
            isCorrect: true,
            explanation: 'カバレッジツールを使用することで、どの分岐がテストされていないかを特定し、効率的にテストケースを追加できます。'
          },
          {
            id: 'q-006-10-c',
            text: 'すべての可能な入力の組み合わせを網羅的にテストする',
            isCorrect: false,
            explanation: 'すべての入力の組み合わせをテストすることは、多くの場合、現実的ではありません。入力の数が増えると、組み合わせは指数関数的に増加します。'
          },
          {
            id: 'q-006-10-d',
            text: 'ランダムテスト（ファジングなど）を使用して、できるだけ多くの分岐をカバーする',
            isCorrect: false,
            explanation: 'ランダムテストは一部の分岐をカバーするのに役立ちますが、すべての分岐を系統的にカバーすることは保証されません。'
          }
        ],
        explanation: '分岐網羅テストを効果的に自動化するための最適なアプローチは、カバレッジツールを使用して分岐網羅率を測定し、不足している分岐を特定することです。\n\nこのアプローチの利点は以下の通りです：\n\n1. 客観的な測定: カバレッジツールは、どの分岐がテストされていないかを正確に報告します。\n\n2. 効率性: テスターは不足している分岐を特定し、それらをカバーするための特定のテストケースを作成できます。\n\n3. 継続的インテグレーション: カバレッジレポートを継続的インテグレーションプロセスに組み込むことで、分岐網羅率が低下した場合に警告を受けることができます。\n\n4. 可視化: 多くのカバレッジツールは、どの分岐がテストされていないかを視覚的に表示し、問題領域を特定するのに役立ちます。\n\n人気のあるカバレッジツールには以下のようなものがあります：\n- JavaScript: Istanbul, Jest\n- Java: JaCoCo, Cobertura\n- Python: Coverage.py\n- C#: NCover, dotCover\n- Ruby: SimpleCov\n\nこれらのツールを使用することで、分岐網羅テストをより効率的かつ効果的に自動化できます。',
        difficulty: 'medium',
        points: 10
      }
    ],
    techniqueName: '分岐網羅',
    techniqueId: 'branch-coverage',
    categoryId: 'whitebox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '30分'
  },
  {
    id: 'ex-007',
    title: '条件網羅テストの演習',
    description: '条件網羅（Condition Coverage）テスト技法を使った実践演習です。',
    objective: 'この演習では、複合条件内の各条件について、すべての真偽値の組み合わせをテストする方法を学びます。',
    scenarioDescription: 
      'あなたはセキュリティシステムの開発チームのテストエンジニアとして、以下のアクセス制御関数をテストする任務を与えられました：\n\n' +
      '```javascript\n' +
      'function checkAccess(user, resourceType, isAdmin, hasMfaEnabled) {\n' +
      '  // 管理者は多要素認証が有効であればすべてのリソースにアクセス可能\n' +
      '  if (isAdmin && hasMfaEnabled) {\n' +
      '    return "アクセス許可";\n' +
      '  }\n' +
      '  \n' +
      '  // 一般リソースへのアクセス\n' +
      '  if (resourceType === "public" || (user.role === "user" && user.isVerified)) {\n' +
      '    return "アクセス許可";\n' +
      '  }\n' +
      '  \n' +
      '  // 機密リソースへのアクセス\n' +
      '  if (resourceType === "confidential" && user.clearanceLevel >= 3 && hasMfaEnabled) {\n' +
      '    return "アクセス許可";\n' +
      '  }\n' +
      '  \n' +
      '  return "アクセス拒否";\n' +
      '}\n' +
      '```\n\n' +
      'この関数に対して条件網羅（複合条件内の各条件がtrueおよびfalseとなるすべての組み合わせをテスト）を達成するテストケースを設計してください。',
    steps: [
      {
        stepNumber: 1,
        description: '複合条件を特定し、各条件の真偽値の組み合わせを列挙する'
      },
      {
        stepNumber: 2,
        description: '各組み合わせをテストするためのテストケースを設計する'
      },
      {
        stepNumber: 3,
        description: 'テストケースが条件網羅を達成できているか確認する'
      },
      {
        stepNumber: 4,
        description: '必要に応じてテストケースを追加または最適化する'
      }
    ],
    quiz: [
      {
        id: 'q-007-1',
        questionText: '条件網羅（Condition Coverage）テストとは何ですか？',
        options: [
          {
            id: 'q-007-1-a',
            text: 'プログラム内のすべての命令が少なくとも1回実行されるようにテストすること',
            isCorrect: false,
            explanation: 'これは命令網羅（Statement Coverage）の説明です。'
          },
          {
            id: 'q-007-1-b',
            text: 'プログラム内のすべての分岐（条件の真偽）が少なくとも1回実行されるようにテストすること',
            isCorrect: false,
            explanation: 'これは分岐網羅（Branch Coverage）の説明です。'
          },
          {
            id: 'q-007-1-c',
            text: '複合条件内の各条件が個別にtrueとfalseの両方の値を取るようにテストすること',
            isCorrect: true,
            explanation: '条件網羅は、複合条件（例：A && B || C）内の各条件（A、B、C）が個別にtrueとfalseの両方の値を取るようにテストします。'
          },
          {
            id: 'q-007-1-d',
            text: 'プログラム内のすべての実行パスが少なくとも1回実行されるようにテストすること',
            isCorrect: false,
            explanation: 'これはパス網羅（Path Coverage）の説明です。'
          }
        ],
        explanation: '条件網羅（Condition Coverage）は、複合条件内の各条件が個別にtrueとfalseの両方の値を取るようにテストするホワイトボックステスト技法です。例えば、if (A && B)という条件があるとき、条件網羅はAとBの両方がtrueとfalseの値を取るテストケースを求めます。ただし、この網羅基準では、条件の組み合わせのすべてをテストするわけではありません。例えば、(A=true, B=false)と(A=false, B=true)の組み合わせは必須ではありません。より厳密な基準として「複合条件網羅（Multiple Condition Coverage）」があり、これはすべての組み合わせをテストします。',
        difficulty: 'easy',
        points: 5
      },
      {
        id: 'q-007-2',
        questionText: '次の複合条件 if (A && B || C) に対する条件網羅を達成するために必要な最小のテストケース数はいくつですか？',
        options: [
          {
            id: 'q-007-2-a',
            text: '2つ',
            isCorrect: false,
            explanation: '2つのテストケースでは、A、B、Cのすべてについてtrueとfalseの両方の値をテストすることはできません。'
          },
          {
            id: 'q-007-2-b',
            text: '3つ',
            isCorrect: true,
            explanation: '適切に設計された3つのテストケースで、A、B、Cのそれぞれについてtrueとfalseの両方の値をテストすることができます。'
          },
          {
            id: 'q-007-2-c',
            text: '4つ',
            isCorrect: false,
            explanation: '4つのテストケースは必要以上です。最小数は3つです。'
          },
          {
            id: 'q-007-2-d',
            text: '8つ',
            isCorrect: false,
            explanation: '8つは複合条件網羅（すべての組み合わせ）に必要なテストケース数ですが、条件網羅には必要ありません。'
          }
        ],
        explanation: '条件網羅では、各条件が個別にtrueとfalseの両方の値を取るテストケースが必要です。if (A && B || C)の場合、以下の3つのテストケースで条件網羅を達成できます：\n\n1. A=true, B=true, C=false → 条件全体はtrue（AとBがtrueのため）\n2. A=false, B=true, C=true → 条件全体はtrue（Cがtrueのため）\n3. A=false, B=false, C=false → 条件全体はfalse\n\nこれらのテストケースで、A、B、Cのそれぞれについてtrueとfalseの両方の値がテストされます。条件網羅は各条件の個別の真偽のみを求めるため、8つのすべての組み合わせをテストする必要はありません。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-007-3',
        questionText: '条件網羅と複合条件網羅（Multiple Condition Coverage）の違いを最もよく説明しているのはどれですか？',
        options: [
          {
            id: 'q-007-3-a',
            text: '条件網羅は各条件の真偽をテストし、複合条件網羅はすべての条件の組み合わせをテストする',
            isCorrect: true,
            explanation: 'これが正確な違いです。複合条件網羅はより厳格で、すべての可能な組み合わせをテストします。'
          },
          {
            id: 'q-007-3-b',
            text: '条件網羅はホワイトボックステスト技法で、複合条件網羅はブラックボックステスト技法である',
            isCorrect: false,
            explanation: '両方ともホワイトボックステスト技法です。'
          },
          {
            id: 'q-007-3-c',
            text: '条件網羅はANDとOR演算子を扱い、複合条件網羅はより複雑な演算子を扱う',
            isCorrect: false,
            explanation: '両方とも同じ種類の論理演算子を扱います。違いはテストの網羅範囲です。'
          },
          {
            id: 'q-007-3-d',
            text: '条件網羅は関数レベルで適用され、複合条件網羅はプログラム全体に適用される',
            isCorrect: false,
            explanation: '両方とも任意のレベル（関数、モジュール、プログラム全体）に適用できます。'
          }
        ],
        explanation: '条件網羅と複合条件網羅の主な違いは以下の通りです：\n\n- 条件網羅（Condition Coverage）：複合条件内の各条件が個別にtrueとfalseの両方の値を取るようにテストします。例えば、if (A && B)という条件の場合、条件網羅はAとBのそれぞれがtrueとfalseの値を取るテストケースを求めます。必要なテストケース数は少なくなりますが、すべての条件の組み合わせをテストするわけではありません。\n\n- 複合条件網羅（Multiple Condition Coverage）：複合条件内のすべての条件の組み合わせをテストします。例えば、if (A && B)の場合、以下の組み合わせすべてをテストします：\n  * A=true, B=true\n  * A=true, B=false\n  * A=false, B=true\n  * A=false, B=false\n\n複合条件網羅はより徹底的ですが、条件の数が増えると必要なテストケース数が2^n（nは条件数）で増加するため、実用的でない場合があります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-007-4',
        questionText: '上記のcheckAccess関数内の最初の複合条件 "isAdmin && hasMfaEnabled" に対する条件網羅を達成するために必要なテストケースはどれですか？',
        options: [
          {
            id: 'q-007-4-a',
            text: 'isAdmin=true, hasMfaEnabled=true のみ',
            isCorrect: false,
            explanation: 'このテストケースはisAdminとhasMfaEnabledの両方がtrueの場合のみをカバーします。条件網羅には各条件のfalseの場合も必要です。'
          },
          {
            id: 'q-007-4-b',
            text: 'isAdmin=true, hasMfaEnabled=true と isAdmin=false, hasMfaEnabled=false',
            isCorrect: false,
            explanation: 'この2つのテストケースでは、isAdmin=true, hasMfaEnabled=falseとisAdmin=false, hasMfaEnabled=trueの組み合わせがカバーされていません。これらは条件網羅に必要です。'
          },
          {
            id: 'q-007-4-c',
            text: 'isAdmin=true, hasMfaEnabled=true と isAdmin=false, hasMfaEnabled=true と isAdmin=true, hasMfaEnabled=false',
            isCorrect: true,
            explanation: 'これらの3つのテストケースで、isAdminとhasMfaEnabledのそれぞれについてtrueとfalseの両方の値がテストされます。これが条件網羅に必要な最小のセットです。'
          },
          {
            id: 'q-007-4-d',
            text: 'isAdmin=true, hasMfaEnabled=true と isAdmin=false, hasMfaEnabled=false と isAdmin=false, hasMfaEnabled=true と isAdmin=true, hasMfaEnabled=false',
            isCorrect: false,
            explanation: 'これらの4つのテストケースはすべての組み合わせをカバーしており、複合条件網羅を達成します。しかし、条件網羅に必要なのは3つのテストケースのみです。'
          }
        ],
        explanation: 'isAdmin && hasMfaEnabledという複合条件の条件網羅を達成するには、以下の条件を満たすテストケースが必要です：\n\n1. isAdminがtrueの場合とfalseの場合をテスト\n2. hasMfaEnabledがtrueの場合とfalseの場合をテスト\n\nこれを達成するために必要な最小のテストケースセットは以下の通りです：\n\n1. isAdmin=true, hasMfaEnabled=true\n2. isAdmin=false, hasMfaEnabled=true（isAdminがfalseの場合をテスト）\n3. isAdmin=true, hasMfaEnabled=false（hasMfaEnabledがfalseの場合をテスト）\n\n4番目の組み合わせ（isAdmin=false, hasMfaEnabled=false）は複合条件網羅には必要ですが、単純な条件網羅には必要ありません。なぜなら、上記の3つのテストケースですでにisAdminとhasMfaEnabledの両方についてtrueとfalseの値がテストされているからです。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-007-5',
        questionText: '条件網羅テストの主な限界はどれですか？',
        options: [
          {
            id: 'q-007-5-a',
            text: '複合条件内の条件の組み合わせによる相互作用を完全にテストできない',
            isCorrect: true,
            explanation: 'これは条件網羅の主な限界です。条件の組み合わせによるバグを見逃す可能性があります。'
          },
          {
            id: 'q-007-5-b',
            text: '大規模なプログラムでは実施が困難である',
            isCorrect: false,
            explanation: '大規模プログラムでも条件網羅テストは実施可能です。複合条件網羅の方が実施が困難です。'
          },
          {
            id: 'q-007-5-c',
            text: 'テスト実行中の性能問題を検出できない',
            isCorrect: false,
            explanation: 'これはどのカバレッジ基準にも当てはまります。性能テストは別のテスト種類です。'
          },
          {
            id: 'q-007-5-d',
            text: 'オブジェクト指向プログラミングには適用できない',
            isCorrect: false,
            explanation: '条件網羅テストはオブジェクト指向プログラミングを含むすべてのプログラミングパラダイムに適用できます。'
          }
        ],
        explanation: '条件網羅テストの主な限界は、複合条件内の条件の組み合わせによる相互作用を完全にテストできないことです。各条件のtrueとfalseの値が個別にテストされても、特定の組み合わせによるバグが見逃される可能性があります。\n\n例えば、if (A && B)という条件において、A=true、B=trueの場合にのみ発生するバグは、必ずしも条件網羅テストでは検出されません。A=true、B=falseとA=false、B=trueの組み合わせのみをテストした場合、A=true、B=trueの組み合わせはテストされない可能性があります。\n\nこの限界を克服するには、複合条件網羅（Multiple Condition Coverage）を使用して、すべての条件の組み合わせをテストする必要があります。ただし、条件の数が増えると組み合わせの数が指数関数的に増加するため、完全な複合条件網羅は常に実用的とは限りません。そのため、リスク分析に基づいて重要な組み合わせを選択するなどの戦略が必要になることがあります。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-007-6',
        questionText: '次のコードの2番目の複合条件（resourceType === "public" || (user.role === "user" && user.isVerified)）の条件網羅を達成するために必要なテストケースの最小数はいくつですか？',
        options: [
          {
            id: 'q-007-6-a',
            text: '2つ',
            isCorrect: false,
            explanation: '2つのテストケースでは、3つの条件（resourceType === "public"、user.role === "user"、user.isVerified）のそれぞれについてtrueとfalseの両方の値をテストすることはできません。'
          },
          {
            id: 'q-007-6-b',
            text: '3つ',
            isCorrect: false,
            explanation: '3つのテストケースでも、3つの条件のそれぞれについてtrueとfalseの両方の値をテストすることはできません。'
          },
          {
            id: 'q-007-6-c',
            text: '4つ',
            isCorrect: true,
            explanation: '適切に設計された4つのテストケースで、3つの条件のそれぞれについてtrueとfalseの両方の値をテストすることができます。'
          },
          {
            id: 'q-007-6-d',
            text: '8つ',
            isCorrect: false,
            explanation: '8つは複合条件網羅（すべての組み合わせ）に必要なテストケース数です。条件網羅には必要ありません。'
          }
        ],
        explanation: 'resourceType === "public" || (user.role === "user" && user.isVerified)という複合条件の条件網羅を達成するには、以下の条件を満たすテストケースが必要です：\n\n1. resourceType === "public"がtrueの場合とfalseの場合をテスト\n2. user.role === "user"がtrueの場合とfalseの場合をテスト\n3. user.isVerifiedがtrueの場合とfalseの場合をテスト\n\nこれを達成するために必要な最小のテストケースセットは以下の通りです：\n\n1. resourceType="public", user.role="admin", user.isVerified=false\n   - resourceType === "public"がtrue\n   - user.role === "user"がfalse\n   - user.isVerifiedがfalse\n\n2. resourceType="private", user.role="user", user.isVerified=true\n   - resourceType === "public"がfalse\n   - user.role === "user"がtrue\n   - user.isVerifiedがtrue\n\n3. resourceType="private", user.role="admin", user.isVerified=true\n   - resourceType === "public"がfalse\n   - user.role === "user"がfalse\n   - user.isVerifiedがtrue\n\n4. resourceType="private", user.role="user", user.isVerified=false\n   - resourceType === "public"がfalse\n   - user.role === "user"がtrue\n   - user.isVerifiedがfalse\n\nこれらの4つのテストケースで、3つの条件のそれぞれについてtrueとfalseの両方の値がテストされます。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-007-7',
        questionText: '次のコードに対する条件網羅テストで見落としやすいバグはどれですか？\n\n```javascript\nfunction processOrder(order, user) {\n  if (order.total > 0 && (user.isPremium || user.credits >= order.total)) {\n    // 注文処理\n    return "注文処理完了";\n  } else {\n    return "注文処理失敗";\n  }\n}\n```',
        options: [
          {
            id: 'q-007-7-a',
            text: 'order.totalが0の場合に注文が拒否されるバグ',
            isCorrect: false,
            explanation: 'これは条件網羅テストで検出されます。order.total > 0がfalseの場合のテストケースが含まれるためです。'
          },
          {
            id: 'q-007-7-b',
            text: 'user.isPremiumがtrueでuser.creditsが不足している場合に発生するバグ',
            isCorrect: false,
            explanation: 'これは正常な動作です。条件の論理によれば、ユーザーがプレミアムの場合、クレジットに関係なく注文は処理されるべきです。'
          },
          {
            id: 'q-007-7-c',
            text: 'order.totalが負の値で、user.isPremiumがtrueの場合に発生するバグ',
            isCorrect: true,
            explanation: 'これは条件網羅テストで見落とされやすいバグです。各条件の真偽をテストしても、この特定の組み合わせ（order.total < 0, user.isPremium = true）はテストされない可能性があります。'
          },
          {
            id: 'q-007-7-d',
            text: 'user.creditsがundefinedの場合に発生するバグ',
            isCorrect: false,
            explanation: 'これは条件網羅テストの範囲外の問題です。有効な入力値のテストと関連しています。'
          }
        ],
        explanation: '条件網羅テストでは、条件の特定の組み合わせによって発生するバグが見落とされる可能性があります。この例では、order.total > 0 && (user.isPremium || user.credits >= order.total)という複合条件があります。\n\n条件網羅テストでは、order.totalが負の値（order.total > 0がfalse）かつuser.isPremiumがtrueの場合が明示的にテストされない可能性があります。この組み合わせでは、注文合計が無効（負の値）であるにもかかわらず、ユーザーがプレミアムであるため注文が処理されてしまうバグが発生する可能性があります。\n\n適切なコードは、注文合計が有効であることを最初に確認し、その後でユーザーの支払い能力をチェックするべきでしょう。例えば：\n\n```javascript\nif (order.total <= 0) {\n  return "無効な注文金額";\n} else if (user.isPremium || user.credits >= order.total) {\n  // 注文処理\n  return "注文処理完了";\n} else {\n  return "支払い方法が不足しています";\n}\n```\n\nこのようなバグを検出するには、複合条件網羅テストや境界値分析などの追加のテスト技法が必要です。',
        difficulty: 'hard',
        points: 15
      },
      {
        id: 'q-007-8',
        questionText: '次のコードに対する条件網羅テストを実施する際、テストケースの設計でよく犯すミスはどれですか？\n\n```javascript\nfunction validatePassword(password) {\n  if (password && password.length >= 8 && /[A-Z]/.test(password) && /[0-9]/.test(password)) {\n    return "有効なパスワード";\n  } else {\n    return "無効なパスワード";\n  }\n}\n```',
        options: [
          {
            id: 'q-007-8-a',
            text: '複合条件全体が常にtrueまたはfalseになるテストケースのみを使用すること',
            isCorrect: true,
            explanation: 'これは条件網羅テストでよく犯すミスです。各条件が個別にtrueとfalseの値を取るテストケースが必要です。'
          },
          {
            id: 'q-007-8-b',
            text: 'passwordがnullの場合をテストしないこと',
            isCorrect: false,
            explanation: 'passwordがnullの場合は、最初の条件（password）がfalseとなるテストケースです。条件網羅テストでは、この条件もテストする必要があります。'
          },
          {
            id: 'q-007-8-c',
            text: '短すぎるパスワードをテストしないこと',
            isCorrect: false,
            explanation: '短すぎるパスワードは、2番目の条件（password.length >= 8）がfalseとなるテストケースです。条件網羅テストでは、この条件もテストする必要があります。'
          },
          {
            id: 'q-007-8-d',
            text: '関数の戻り値を検証しないこと',
            isCorrect: false,
            explanation: 'これはテストの検証ステップの問題であり、条件網羅テストの設計とは直接関係ありません。'
          }
        ],
        explanation: '条件網羅テストを実施する際のよくある誤りは、複合条件全体が常にtrueまたはfalseになるテストケースのみを使用することです。validatePassword関数の場合、以下の4つの条件があります：\n\n1. password（パスワードが存在するか）\n2. password.length >= 8（パスワードが十分な長さか）\n3. /[A-Z]/.test(password)（パスワードに大文字が含まれるか）\n4. /[0-9]/.test(password)（パスワードに数字が含まれるか）\n\n条件網羅テストでは、これらの各条件が個別にtrueとfalseの値を取るテストケースが必要です。例えば：\n\n- 条件1のfalseをテスト：password = null または undefined\n- 条件2のfalseをテスト：password = "Abc1"（8文字未満）\n- 条件3のfalseをテスト：password = "abcdefg123"（大文字なし）\n- 条件4のfalseをテスト：password = "Abcdefghijk"（数字なし）\n- すべての条件がtrueの場合：password = "Abcdefg123"\n\nこれらのテストケースを使用することで、各条件が個別にテストされます。テスト設計で注意すべき点は、一部の条件がfalseの場合、短絡評価により後続の条件が評価されない可能性があることです。例えば、passwordがnullの場合、他の条件は評価されません。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-007-9',
        questionText: '条件網羅テストと分岐網羅テストの関係について正しい説明はどれですか？',
        options: [
          {
            id: 'q-007-9-a',
            text: '条件網羅が100%の場合、分岐網羅も必ず100%になる',
            isCorrect: false,
            explanation: 'これは正しくありません。条件網羅が100%でも、分岐網羅が100%にならない場合があります。'
          },
          {
            id: 'q-007-9-b',
            text: '分岐網羅が100%の場合、条件網羅も必ず100%になる',
            isCorrect: false,
            explanation: 'これも正しくありません。分岐網羅が100%でも、条件網羅が100%にならない場合があります。'
          },
          {
            id: 'q-007-9-c',
            text: '条件網羅と分岐網羅は互いに独立しており、一方が高くても他方が低い場合がある',
            isCorrect: true,
            explanation: 'これが正しい説明です。条件網羅と分岐網羅は異なる基準であり、一方が高くても他方が低い場合があります。'
          },
          {
            id: 'q-007-9-d',
            text: '条件網羅と分岐網羅は同じテスト技法の異なる名称である',
            isCorrect: false,
            explanation: 'これは誤りです。条件網羅と分岐網羅は異なるテスト技法です。'
          }
        ],
        explanation: '条件網羅と分岐網羅は互いに独立した異なるテスト基準であり、一方が高くても他方が低い場合があります。\n\n例えば、次のコードを考えてみましょう：\n```javascript\nif (A && B) {\n  // コードブロック\n}\n```\n\n- 分岐網羅は、if文の結果（真と偽）の両方がテストされることを要求します。これは2つのテストケースで達成できます：\n  * A=true, B=true（条件全体がtrue）\n  * A=false, B=any（条件全体がfalse）\n\n- 条件網羅は、AとBの両方が個別にtrueとfalseの値を取ることを要求します。これは以下のテストケースで達成できます：\n  * A=true, B=true（AとBがともにtrue）\n  * A=false, B=true（Aがfalse、Bがtrue）\n  * A=true, B=false（Aがtrue、Bがfalse）\n\nこの例では、分岐網羅を100%達成しても（2つのテストケース）、条件網羅を完全に達成できない場合があります（3つのテストケースが必要）。逆に、条件網羅を達成するテストケースで分岐網羅も達成できますが、これは常に当てはまるわけではありません。\n\n特に短絡評価を行うプログラミング言語（JavaScriptなど）では、条件の評価が途中で終了するため、条件網羅と分岐網羅の関係はより複雑になります。したがって、両方のテスト基準を組み合わせることで、より効果的なテストが可能になります。',
        difficulty: 'medium',
        points: 10
      },
      {
        id: 'q-007-10',
        questionText: '条件網羅テストを自動化する際の最も効果的なアプローチはどれですか？',
        options: [
          {
            id: 'q-007-10-a',
            text: 'ランダムテスト（ファジング）を使用して、できるだけ多くの条件の組み合わせをカバーする',
            isCorrect: false,
            explanation: 'ランダムテストは条件のカバレッジを保証しません。特定の組み合わせが偶然テストされない可能性があります。'
          },
          {
            id: 'q-007-10-b',
            text: '各条件を分析し、必要なテストケースを手動で設計した後、それらを自動テストとして実装する',
            isCorrect: true,
            explanation: '各条件を分析して必要なテストケースを特定し、それらを自動テストとして実装することが最も効果的です。'
          },
          {
            id: 'q-007-10-c',
            text: 'すべての可能な入力の組み合わせを生成して実行する',
            isCorrect: false,
            explanation: 'すべての入力の組み合わせをテストすることは、多くの場合、実用的ではありません。条件の数が増えると、組み合わせは指数関数的に増加します。'
          },
          {
            id: 'q-007-10-d',
            text: 'テスト対象の関数をリファクタリングして、複合条件を単純な条件に分解する',
            isCorrect: false,
            explanation: 'テスト対象のコードをリファクタリングすることは、テスト自体の自動化アプローチではありません。また、コードの振る舞いを変える可能性があります。'
          }
        ],
        explanation: '条件網羅テストを自動化する最も効果的なアプローチは、各条件を分析して必要なテストケースを特定し、それらを自動テストとして実装することです。このアプローチでは以下のステップを踏みます：\n\n1. コード内の複合条件を特定する\n2. 各条件がtrueとfalseになるために必要なテストケースを分析する\n3. 各条件がtrueとfalseの両方の値を取るように最小のテストケースセットを設計する\n4. これらのテストケースを自動テストフレームワーク（Jest、JUnit、pytestなど）で実装する\n5. カバレッジツールを使用して、条件網羅が達成されているかを検証する\n\nこのアプローチの利点は、テストの目的が明確であり、各テストケースが特定の条件をカバーするように設計されていることです。また、テストケースの数を最小限に抑えながら、必要なカバレッジを達成できます。\n\n多くの場合、モックやスタブを使用して、特定の条件を制御しやすくすることも有効です。例えば、外部サービスやデータベースに依存する条件をテストする場合、これらの依存関係をモック化することで、条件の真偽を制御しやすくなります。\n\n注意点として、プログラミング言語の短絡評価（例：JavaScriptのA && B では A が false の場合 B は評価されない）を考慮する必要があります。これにより、一部の条件がテストされない可能性があるため、テストケースの設計時に注意が必要です。',
        difficulty: 'medium',
        points: 10
      }
    ],
    techniqueName: '条件網羅',
    techniqueId: 'condition-coverage',
    categoryId: 'whitebox',
    passingScore: 70,
    totalPoints: 100,
    estimatedTime: '30分'
  }
];

// バッジ定義
export const badges: BadgeDefinition[] = [
  {
    id: 'badge-technique-001',
    name: '同値分割マスター',
    description: '同値分割法の演習を高得点で完了しました。効率的なテストケース設計のスキルを証明します。',
    imageUrl: '/badges/equivalence-partitioning.svg',
    type: 'technique',
    relatedId: 'equivalence-partitioning',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-001']
    }
  },
  {
    id: 'badge-technique-002',
    name: '境界値の守護者',
    description: '境界値分析の演習を高得点で完了しました。エッジケースを見つける鋭い目を持っています。',
    imageUrl: '/badges/boundary-value.svg',
    type: 'technique',
    relatedId: 'boundary-value-analysis',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-002']
    }
  },
  {
    id: 'badge-technique-003',
    name: '決定表マスター',
    description: '決定表テストの演習を高得点で完了しました。複雑な条件のロジックを正確に分析できます。',
    imageUrl: '/badges/black-box.svg',
    type: 'technique',
    relatedId: 'decision-table',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-003']
    }
  },
  {
    id: 'badge-technique-004',
    name: '状態遷移の達人',
    description: '状態遷移テストの演習を高得点で完了しました。システムの状態と遷移を理解し、効果的にテストできます。',
    imageUrl: '/badges/black-box.svg',
    type: 'technique',
    relatedId: 'state-transition',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-004']
    }
  },
  {
    id: 'badge-technique-005',
    name: '命令網羅マスター',
    description: '命令網羅テストの演習を高得点で完了しました。ソースコードの実行網羅性を効果的に検証できます。',
    imageUrl: '/badges/black-box.svg',
    type: 'technique',
    relatedId: 'statement-coverage',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-005']
    }
  },
  {
    id: 'badge-technique-006',
    name: '分岐網羅マスター',
    description: '分岐網羅テストの演習を高得点で完了しました。条件分岐を効果的に検証するスキルを証明します。',
    imageUrl: '/badges/black-box.svg',
    type: 'technique',
    relatedId: 'branch-coverage',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-006']
    }
  },
  {
    id: 'badge-technique-007',
    name: '条件網羅マスター',
    description: '条件網羅テストの演習を高得点で完了しました。複合条件の各要素を効果的に検証するスキルを証明します。',
    imageUrl: '/badges/black-box.svg',
    type: 'technique',
    relatedId: 'condition-coverage',
    requirement: {
      type: 'exercise_completion',
      threshold: 0.8, // 80%以上のスコア
      exerciseIds: ['ex-007']
    }
  },
  {
    id: 'badge-category-001',
    name: 'ブラックボックステストの達人',
    description: 'ブラックボックステストカテゴリのすべての演習を完了しました。入力と出力の関係を分析する専門家です。',
    imageUrl: '/badges/black-box.svg',
    type: 'category',
    relatedId: 'blackbox',
    requirement: {
      type: 'category_mastery',
      threshold: 0.7 // 70%以上の平均スコア
    }
  },
  {
    id: 'badge-category-002',
    name: 'ホワイトボックステストの達人',
    description: 'ホワイトボックステストカテゴリのすべての演習を完了しました。コードの内部構造を解析する専門家です。',
    imageUrl: '/badges/black-box.svg', // 後で適切なアイコンに変更予定
    type: 'category',
    relatedId: 'whitebox',
    requirement: {
      type: 'category_mastery',
      threshold: 0.7 // 70%以上の平均スコア
    }
  },
  {
    id: 'badge-achievement-all',
    name: 'テストマエストロ',
    description: 'すべてのテスト技法を習得しました。あなたはソフトウェアテストの真のマエストロです！',
    imageUrl: '/badges/test-maestro.svg',
    type: 'achievement',
    requirement: {
      type: 'all_techniques'
    }
  }
];